<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>VolleyLab – Q-Learning & Double Deep RL</title>
  <style>
    :root {
      --bg1:#050516;
      --panel:rgba(18,24,56,.82);
      --ink:#f1f5ff;
      --muted:#a1a9d8;
      --accent:#f472b6;
      --accent-cyan:#38bdf8;
      --accent-emerald:#2dd4bf;
      --silver:rgba(222,231,255,.55);
      --ok:#34d399;
      --warn:#f59e0b;
    }
    *{box-sizing:border-box}
    body{margin:0; min-height:100vh; display:flex; flex-direction:column; background:radial-gradient(circle at 42% 18%, rgba(87,51,183,.55) 0%, rgba(39,56,121,.78) 40%, var(--bg1) 100%); color:var(--ink); font-family:"Inter",system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;}

    .main-nav{position:sticky; top:0; z-index:100; padding:22px 48px; display:flex; align-items:center; justify-content:space-between; background:linear-gradient(120deg, rgba(15,20,48,.92) 0%, rgba(10,14,34,.75) 60%, rgba(10,14,34,.35) 100%); backdrop-filter:blur(14px); border-bottom:1px solid var(--silver); box-shadow:0 22px 45px rgba(5,9,25,.55)}
    .brand{display:flex; align-items:center; gap:12px; font-size:22px; font-weight:700; letter-spacing:.02em; color:var(--ink)}
    .brand-dot{width:14px; height:14px; border-radius:50%; background:linear-gradient(135deg, var(--accent) 0%, #8b5cf6 100%); box-shadow:0 0 18px rgba(244,114,182,.6)}
    .nav-links{display:flex; align-items:center; gap:12px; flex-wrap:wrap}
    .pill-link,.pill-button{display:inline-flex; align-items:center; justify-content:center; padding:10px 20px; border-radius:999px; border:1px solid rgba(56,189,248,.45); background:linear-gradient(120deg, rgba(56,189,248,.18), rgba(139,92,246,.18)); color:var(--ink); text-decoration:none; font-size:14px; font-weight:600; letter-spacing:.03em; transition:transform .2s ease, box-shadow .2s ease, filter .2s ease}
    .pill-link.secondary{border-color:rgba(139,92,246,.45); background:linear-gradient(120deg, rgba(139,92,246,.18), rgba(244,114,182,.18))}
    .pill-link:hover,.pill-button:hover{transform:translateY(-1px); filter:brightness(1.05); box-shadow:0 16px 32px rgba(56,189,248,.25)}
    .pill-link:focus-visible,.pill-button:focus-visible{outline:2px solid rgba(56,189,248,.65); outline-offset:3px}
    .pill-button{cursor:pointer; border-color:rgba(244,114,182,.45); background:linear-gradient(120deg, rgba(244,114,182,.25), rgba(59,130,246,.22))}
    .pill-link[aria-current="page"]{border-color:rgba(244,114,182,.65); background:linear-gradient(120deg, rgba(244,114,182,.22), rgba(59,130,246,.22)); box-shadow:0 18px 38px rgba(244,114,182,.28)}

    main{flex:1; display:flex; justify-content:center; align-items:flex-start; padding:40px 48px 64px}
    .wrap{display:flex; width:100%; max-width:2000px; gap:40px; align-items:flex-start; justify-content:center}
    .field-area{flex:1 1 auto; display:flex; flex-direction:column; align-items:stretch; gap:18px; min-width:0}
    .playfield-frame{position:relative; padding:18px; border-radius:30px; background:rgba(4,8,26,.85); box-shadow:0 18px 36px rgba(9,14,36,.55); border:1px solid rgba(148,163,209,.22)}
    canvas{width:100%; height:auto; max-width:1100px; border-radius:24px; background:#04091f; box-shadow:0 0 45px rgba(15,23,61,.65), inset 0 0 22px rgba(118,133,255,.12); border:1px solid var(--silver)}

    .stats-bar{display:grid; grid-template-columns:repeat(auto-fit,minmax(160px,1fr)); gap:16px; padding:18px 22px; border-radius:18px; background:rgba(11,16,44,.78); border:1px solid var(--silver); box-shadow:0 18px 32px rgba(5,9,25,.45)}
    .stat-card{display:flex; flex-direction:column; gap:6px}
    .stat-label{font-size:12px; text-transform:uppercase; letter-spacing:.12em; color:var(--muted)}
    .stat-value{font-size:26px; font-weight:700; letter-spacing:.02em; color:var(--ink)}

    .chart-panel{display:flex; flex-direction:column; gap:12px; padding:20px 22px; border-radius:20px; background:rgba(11,16,44,.78); border:1px solid var(--silver); box-shadow:0 18px 32px rgba(5,9,25,.45)}
    .chart-header{display:flex; align-items:center; justify-content:space-between; gap:12px}
    .chart-header h2{margin:0; font-size:16px; letter-spacing:.02em}
    .chart-note{font-size:12px; color:var(--muted)}
    .fitness-chart{position:relative; display:flex; align-items:flex-end; gap:10px; height:160px; padding:14px 16px; border-radius:16px; border:1px dashed rgba(148,163,209,.35); background:rgba(6,12,34,.72); overflow:visible}
    .fitness-chart.is-empty::after{content:'Training will populate this chart'; position:absolute; inset:0; display:flex; align-items:center; justify-content:center; font-size:13px; color:var(--muted); letter-spacing:.02em}
    .fitness-bar{flex:1; min-width:12px; background:linear-gradient(180deg, rgba(56,189,248,.85) 0%, rgba(139,92,246,.65) 70%, rgba(15,23,42,.8) 100%); border-radius:12px 12px 0 0; border:1px solid rgba(148,163,209,.45); position:relative; transition:height .35s ease, transform .2s ease}
    .fitness-bar--emerald{background:linear-gradient(180deg, rgba(45,212,191,.85) 0%, rgba(34,197,94,.65) 70%, rgba(15,23,42,.8) 100%); border-color:rgba(52,211,153,.45)}
    .fitness-bar span{position:absolute; bottom:calc(100% + 6px); left:50%; transform:translateX(-50%); font-size:11px; font-weight:600; color:var(--muted); white-space:nowrap; letter-spacing:.02em}
    .fitness-bar small{position:absolute; bottom:4px; left:50%; transform:translateX(-50%); font-size:10px; color:rgba(241,245,255,.78); letter-spacing:.08em; text-shadow:0 1px 2px rgba(2,6,23,.6)}

    .side{width:360px; flex:0 1 360px; display:flex; flex-direction:column; gap:20px}
    .panel{background:var(--panel); border:1px solid var(--silver); padding:22px; border-radius:20px; backdrop-filter:blur(16px); box-shadow:0 18px 45px rgba(5,7,24,.55)}
    .panel h2{margin:0 0 12px; font-size:18px; letter-spacing:.02em}
    .panel p{margin:0 0 14px; font-size:13px; line-height:1.6; color:var(--muted)}
    .control-grid{display:grid; grid-template-columns:repeat(auto-fit,minmax(220px,1fr)); gap:16px}
    .control{display:flex; flex-direction:column; gap:10px; padding:12px 14px; border-radius:14px; border:1px solid rgba(148,163,209,.24); background:rgba(10,16,46,.55); box-shadow:inset 0 0 12px rgba(56,189,248,.08)}
    .control-header{display:flex; align-items:center; justify-content:space-between; gap:12px}
    .label{font-size:13px; color:var(--muted); letter-spacing:.02em}
    .val{font-family:ui-monospace,Menlo,Consolas,monospace; font-size:12px; padding:4px 8px; border-radius:8px; background:rgba(10,16,46,.7); border:1px solid var(--silver); color:var(--accent-cyan); box-shadow:inset 0 0 12px rgba(56,189,248,.12)}
    input[type=range]{width:100%; accent-color:var(--accent-cyan)}
    input[type=number]{width:100%; padding:6px 10px; border-radius:10px; border:1px solid rgba(148,163,209,.28); background:rgba(10,16,46,.55); color:var(--ink); font-family:inherit}
    .btn{display:block; width:100%; padding:12px 14px; border-radius:12px; border:1px solid rgba(45,212,191,.45); background:linear-gradient(120deg, rgba(45,212,191,.18), rgba(59,130,246,.18)); color:var(--ink); cursor:pointer; text-align:center; margin-top:14px; font-weight:600; letter-spacing:.02em; transition:transform .2s ease, box-shadow .2s ease, filter .2s ease}
    .btn:hover{filter:brightness(1.08); transform:translateY(-1px); box-shadow:0 20px 36px rgba(45,212,191,.28)}
    .btn:disabled{opacity:.55; cursor:not-allowed; filter:saturate(.5); box-shadow:none}

    .legend{border-radius:18px; border:1px solid rgba(148,163,209,.28); background:rgba(11,16,44,.72); padding:18px; display:grid; gap:10px; font-size:12px; color:var(--muted)}
    .legend strong{color:var(--ink)}
    .sr-only{position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0}

    @media (max-width:1200px){
      .wrap{flex-direction:column; align-items:center}
      .side{width:100%; max-width:720px}
    }
    @media (max-width:900px){
      main{padding:32px 28px 56px}
    }
    @media (max-width:768px){
      .main-nav{flex-direction:column; align-items:flex-start; gap:16px; padding:18px 24px}
      main{padding:28px 20px 52px}
      .wrap{gap:28px}
      .stats-bar{grid-template-columns:repeat(auto-fit,minmax(130px,1fr)); gap:12px; padding:16px 18px}
      .stat-value{font-size:22px}
      canvas{width:100%; height:auto}
    }
  </style>
</head>
<body>
  <header class="main-nav">
    <div class="brand"><span class="brand-dot"></span>VolleyLab RL</div>
    <nav class="nav-links" aria-label="Primary navigation">
      <a class="pill-link" href="index.html">← Start</a>
      <a class="pill-link" href="volleyball.html">Volley NEAT lab</a>
      <a class="pill-link secondary" href="volleyball-rl.html" aria-current="page">Volley RL lab</a>
      <a class="pill-link" href="balllab.html">BallLab</a>
      <a class="pill-link" href="learn-neat.html">How NEAT works</a>
    </nav>
  </header>
  <main>
    <div class="wrap">
      <aside class="side">
        <section class="panel" aria-labelledby="rl-overview">
          <h2 id="rl-overview">Reinforcement learners</h2>
          <p>Version 2.0 rebuild. Character rigs now have legs, arms and jersey numbers and the physics are tuned for a softer ball so both agents can really learn passing, setting and spiking. The left team uses tabular Q-learning while the right side fields a Double Deep Q-network with replay and target syncing.</p>
          <div class="legend">
            <div><strong>Left team:</strong> Fast tabular Q-learning over discretised rally states with contact and control shaping.</div>
            <div><strong>Right team:</strong> Double Deep Q-network with two-layer dense model, replay buffer and soft serves.</div>
            <div>The rally reward reshaping rewards cooperative touches, aerial control and finishing the point on the opponent’s floor.</div>
          </div>
        </section>

        <section class="panel" aria-labelledby="q-controls">
          <h2 id="q-controls">Q-learning controls</h2>
          <div class="control">
            <div class="control-header">
              <label class="label" for="slQLearningRate">Learning rate</label>
              <span class="val" id="lbQLearningRate">0.18</span>
            </div>
            <input id="slQLearningRate" type="range" min="0.05" max="0.6" step="0.01" value="0.18">
          </div>
          <div class="control">
            <div class="control-header">
              <label class="label" for="slQDiscount">Discount γ</label>
              <span class="val" id="lbQDiscount">0.94</span>
            </div>
            <input id="slQDiscount" type="range" min="0.6" max="0.99" step="0.01" value="0.94">
          </div>
          <div class="control">
            <div class="control-header">
              <label class="label" for="slQEpsilon">Exploration ε</label>
              <span class="val" id="lbQEpsilon">0.35</span>
            </div>
            <input id="slQEpsilon" type="range" min="0.01" max="1" step="0.01" value="0.35">
          </div>
          <div class="control">
            <div class="control-header">
              <label class="label" for="slQEpsilonDecay">ε decay per episode</label>
              <span class="val" id="lbQEpsilonDecay">0.993</span>
            </div>
            <input id="slQEpsilonDecay" type="range" min="0.90" max="0.999" step="0.001" value="0.993">
          </div>
        </section>

        <section class="panel" aria-labelledby="ddqn-controls">
          <h2 id="ddqn-controls">Double Deep Q controls</h2>
          <div class="control">
            <div class="control-header">
              <label class="label" for="slDqnLearningRate">Learning rate</label>
              <span class="val" id="lbDqnLearningRate">0.0015</span>
            </div>
            <input id="slDqnLearningRate" type="range" min="0.0005" max="0.01" step="0.0005" value="0.0015">
          </div>
          <div class="control">
            <div class="control-header">
              <label class="label" for="slDqnGamma">Discount γ</label>
              <span class="val" id="lbDqnGamma">0.98</span>
            </div>
            <input id="slDqnGamma" type="range" min="0.7" max="0.999" step="0.001" value="0.98">
          </div>
          <div class="control">
            <div class="control-header">
              <label class="label" for="slDqnEpsilon">Exploration ε</label>
              <span class="val" id="lbDqnEpsilon">0.40</span>
            </div>
            <input id="slDqnEpsilon" type="range" min="0.01" max="1" step="0.01" value="0.40">
          </div>
          <div class="control">
            <div class="control-header">
              <label class="label" for="slDqnEpsilonDecay">ε decay per episode</label>
              <span class="val" id="lbDqnEpsilonDecay">0.995</span>
            </div>
            <input id="slDqnEpsilonDecay" type="range" min="0.90" max="0.999" step="0.001" value="0.995">
          </div>
          <div class="control">
            <div class="control-header">
              <label class="label" for="slTargetSync">Target sync (steps)</label>
              <span class="val" id="lbTargetSync">480</span>
            </div>
            <input id="slTargetSync" type="range" min="60" max="2000" step="20" value="480">
          </div>
          <div class="control">
            <div class="control-header">
              <label class="label" for="slBatchSize">Batch size</label>
              <span class="val" id="lbBatchSize">64</span>
            </div>
            <input id="slBatchSize" type="range" min="8" max="128" step="4" value="64">
          </div>
        </section>

        <section class="panel" aria-labelledby="sim-controls">
          <h2 id="sim-controls">Simulation</h2>
          <div class="control">
            <div class="control-header">
              <label class="label" for="slSimSpeed">Sim speed</label>
              <span class="val" id="lbSimSpeed">6×</span>
            </div>
            <input id="slSimSpeed" type="range" min="1" max="20" step="1" value="6">
          </div>
          <button class="btn" id="btnToggleTraining">Start training</button>
          <button class="btn" id="btnReset">Reset learners</button>
        </section>
      </aside>

      <div class="field-area">
        <section class="playfield-frame" aria-labelledby="canvas-heading">
          <h2 class="sr-only" id="canvas-heading">VolleyLab arena</h2>
          <canvas id="playfield" width="1100" height="620" role="img" aria-label="VolleyLab RL simulation"></canvas>
        </section>

        <section class="stats-bar" aria-live="polite">
          <div class="stat-card">
            <span class="stat-label">Episodes</span>
            <span class="stat-value" id="lbEpisodes">0</span>
          </div>
          <div class="stat-card">
            <span class="stat-label">Left avg reward</span>
            <span class="stat-value" id="lbLeftReward">0.00</span>
          </div>
          <div class="stat-card">
            <span class="stat-label">Right avg reward</span>
            <span class="stat-value" id="lbRightReward">0.00</span>
          </div>
          <div class="stat-card">
            <span class="stat-label">Left ε</span>
            <span class="stat-value" id="lbLeftEpsilon">0.35</span>
          </div>
          <div class="stat-card">
            <span class="stat-label">Right ε</span>
            <span class="stat-value" id="lbRightEpsilon">0.40</span>
          </div>
        </section>

        <section class="chart-panel" aria-labelledby="chart-heading">
          <div class="chart-header">
            <h2 id="chart-heading">Episode reward history</h2>
            <span class="chart-note">Rolling 24 most recent episodes</span>
          </div>
          <div class="fitness-chart" id="rewardChart"></div>
        </section>
      </div>
    </div>
  </main>

  <script>
    const canvas = document.getElementById('playfield');
    const ctx = canvas.getContext('2d');

    const FIELD_WIDTH = canvas.width;
    const FIELD_HEIGHT = canvas.height;
    const FLOOR_Y = FIELD_HEIGHT - 70;
    const NET_X = FIELD_WIDTH / 2;
    const NET_WIDTH = 16;
    const NET_HEIGHT = 240;
    const GRAVITY = 540;
    const DT = 1 / 120;

    const PLAYER_BODY_RADIUS = 32;
    const PLAYER_REACH = 82;
    const PLAYER_HIT_RADIUS = PLAYER_BODY_RADIUS + PLAYER_REACH - 4;
    const PLAYER_MAX_SPEED = 320;
    const PLAYER_JUMP = 460;
    const PLAYER_ACCEL = 1100;

    const BALL_RADIUS = 20;
    const BALL_MAX_SPEED = 420;
    const BALL_DAMP = 0.985;

    const ACTIONS = [
      {name:'idle', vx:0, jump:false},
      {name:'left', vx:-1, jump:false},
      {name:'right', vx:1, jump:false},
      {name:'jump', vx:0, jump:true},
      {name:'left+jump', vx:-1, jump:true},
      {name:'right+jump', vx:1, jump:true}
    ];

    function clamp(value, min, max){
      return Math.max(min, Math.min(max, value));
    }

    function lerp(a, b, t){
      return a + (b - a) * t;
    }

    class Player{
      constructor(side, number){
        this.side = side;
        this.number = number;
        this.reset();
      }
      reset(){
        this.x = this.side === 'left' ? FIELD_WIDTH * 0.27 : FIELD_WIDTH * 0.73;
        this.y = FLOOR_Y - PLAYER_BODY_RADIUS;
        this.vx = 0;
        this.vy = 0;
        this.grounded = true;
        this.touches = 0;
      }
      applyAction(action){
        if(action.vx !== 0){
          this.vx += action.vx * PLAYER_ACCEL * DT;
        } else {
          this.vx *= 0.82;
        }
        this.vx = clamp(this.vx, -PLAYER_MAX_SPEED, PLAYER_MAX_SPEED);
        if(action.jump && this.grounded){
          this.vy = -PLAYER_JUMP;
          this.grounded = false;
        }
      }
      integrate(){
        this.vy += GRAVITY * DT;
        this.x += this.vx * DT;
        this.y += this.vy * DT;

        const minX = this.side === 'left' ? 90 : NET_X + NET_WIDTH/2 + PLAYER_BODY_RADIUS;
        const maxX = this.side === 'left' ? NET_X - NET_WIDTH/2 - PLAYER_BODY_RADIUS : FIELD_WIDTH - 90;
        this.x = clamp(this.x, minX, maxX);

        if(this.y + PLAYER_BODY_RADIUS >= FLOOR_Y){
          this.y = FLOOR_Y - PLAYER_BODY_RADIUS;
          this.vy = 0;
          this.grounded = true;
        } else {
          this.grounded = false;
        }
      }
      draw(context){
        context.save();
        context.translate(this.x, this.y);

        const baseColor = this.side === 'left' ? '#38bdf8' : '#f472b6';
        const accentColor = this.side === 'left' ? '#0ea5e9' : '#fb7185';
        const jerseyColor = this.side === 'left' ? '#1d4ed8' : '#be185d';

        context.fillStyle = baseColor;
        context.beginPath();
        context.arc(0, 0, PLAYER_BODY_RADIUS, 0, Math.PI * 2);
        context.fill();
        context.lineWidth = 4;
        context.strokeStyle = 'rgba(15,23,61,0.55)';
        context.stroke();

        context.fillStyle = 'rgba(255,255,255,0.2)';
        context.beginPath();
        context.ellipse(-PLAYER_BODY_RADIUS * 0.3, -PLAYER_BODY_RADIUS * 0.35, PLAYER_BODY_RADIUS * 0.45, PLAYER_BODY_RADIUS * 0.32, -0.4, 0, Math.PI * 2);
        context.fill();

        context.fillStyle = '#fefefe';
        context.beginPath();
        context.arc(0, -PLAYER_BODY_RADIUS * 0.65, PLAYER_BODY_RADIUS * 0.45, 0, Math.PI * 2);
        context.fill();
        context.strokeStyle = 'rgba(15,23,61,0.25)';
        context.lineWidth = 3;
        context.stroke();

        context.fillStyle = jerseyColor;
        context.beginPath();
        context.ellipse(0, PLAYER_BODY_RADIUS * 0.15, PLAYER_BODY_RADIUS * 0.9, PLAYER_BODY_RADIUS * 0.95, 0, 0, Math.PI * 2);
        context.fill();

        context.fillStyle = '#f8fafc';
        context.font = `${PLAYER_BODY_RADIUS * 0.95}px "Bebas Neue", "Inter", sans-serif`;
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillText(this.number, 0, PLAYER_BODY_RADIUS * 0.2);

        context.strokeStyle = accentColor;
        context.lineWidth = 9;
        context.lineCap = 'round';
        const reach = PLAYER_REACH;
        const armY = -PLAYER_BODY_RADIUS * 0.1;
        context.beginPath();
        context.moveTo(-PLAYER_BODY_RADIUS + 6, armY);
        context.lineTo(-reach - 16, armY + 2);
        context.moveTo(PLAYER_BODY_RADIUS - 6, armY);
        context.lineTo(reach + 16, armY + 2);
        context.stroke();

        context.strokeStyle = '#0f172a';
        context.lineWidth = 10;
        context.beginPath();
        context.moveTo(-PLAYER_BODY_RADIUS * 0.45, PLAYER_BODY_RADIUS * 0.9);
        context.lineTo(-PLAYER_BODY_RADIUS * 0.6, PLAYER_BODY_RADIUS * 1.8);
        context.moveTo(PLAYER_BODY_RADIUS * 0.45, PLAYER_BODY_RADIUS * 0.9);
        context.lineTo(PLAYER_BODY_RADIUS * 0.6, PLAYER_BODY_RADIUS * 1.8);
        context.stroke();

        context.restore();
      }
    }

    class Ball{
      constructor(){
        this.x = NET_X;
        this.y = FLOOR_Y - 240;
        this.vx = 0;
        this.vy = 0;
        this.lastTouchSide = 'left';
        this.lastTouchedBy = null;
        this.prevX = this.x;
        this.prevY = this.y;
      }
      reset(servingSide, leftX, rightX){
        const targetX = servingSide === 'left'
          ? (leftX ?? NET_X - 120)
          : (rightX ?? NET_X + 120);
        const dropApex = Math.max(70, FLOOR_Y - PLAYER_BODY_RADIUS - PLAYER_REACH - BALL_RADIUS - 140);
        this.x = targetX;
        this.y = dropApex;
        this.vx = 0;
        this.vy = 0;
        this.lastTouchSide = servingSide;
        this.lastTouchedBy = null;
        this.prevX = this.x;
        this.prevY = this.y;
      }
      step(){
        this.prevX = this.x;
        this.prevY = this.y;

        this.vy += GRAVITY * DT;
        this.vx *= BALL_DAMP;
        this.vy *= BALL_DAMP;

        this.x += this.vx * DT;
        this.y += this.vy * DT;

        if(this.vx > BALL_MAX_SPEED) this.vx = BALL_MAX_SPEED;
        if(this.vx < -BALL_MAX_SPEED) this.vx = -BALL_MAX_SPEED;
        if(this.vy > BALL_MAX_SPEED) this.vy = BALL_MAX_SPEED;
        if(this.vy < -BALL_MAX_SPEED) this.vy = -BALL_MAX_SPEED;

        if(this.x - BALL_RADIUS < 40){
          this.x = 40 + BALL_RADIUS;
          this.vx *= -0.7;
        }
        if(this.x + BALL_RADIUS > FIELD_WIDTH - 40){
          this.x = FIELD_WIDTH - 40 - BALL_RADIUS;
          this.vx *= -0.7;
        }
        if(this.y - BALL_RADIUS < 40){
          this.y = 40 + BALL_RADIUS;
          this.vy *= -0.6;
        }
      }
      draw(context){
        const gradient = context.createRadialGradient(this.x - 6, this.y - 6, 6, this.x, this.y, BALL_RADIUS + 4);
        gradient.addColorStop(0, '#f8fafc');
        gradient.addColorStop(0.5, '#cbd5f5');
        gradient.addColorStop(1, '#1e293b');
        context.fillStyle = gradient;
        context.beginPath();
        context.arc(this.x, this.y, BALL_RADIUS, 0, Math.PI * 2);
        context.fill();

        context.strokeStyle = 'rgba(148,163,209,0.55)';
        context.lineWidth = 4;
        context.beginPath();
        context.arc(this.x, this.y, BALL_RADIUS * 0.7, Math.PI * 0.15, Math.PI * 1.15);
        context.stroke();
      }
    }

    class GameEnv{
      constructor(){
        this.left = new Player('left', 7);
        this.right = new Player('right', 10);
        this.ball = new Ball();
        this.serveSide = 'left';
        this.events = {};
        this.ball.reset(this.serveSide, this.left.x, this.right.x);
      }
      reset(nextServe){
        this.left.reset();
        this.right.reset();
        this.serveSide = nextServe ?? (Math.random() < 0.5 ? 'left' : 'right');
        this.ball.reset(this.serveSide, this.left.x, this.right.x);
        this.left.touches = 0;
        this.right.touches = 0;
      }
      step(leftActionIdx, rightActionIdx){
        this.events = {
          leftTouch:false,
          rightTouch:false,
          netHit:false,
          floorSide:null,
          rallyTime:DT
        };

        const leftAction = ACTIONS[leftActionIdx];
        const rightAction = ACTIONS[rightActionIdx];

        this.left.applyAction(leftAction);
        this.right.applyAction(rightAction);
        this.left.integrate();
        this.right.integrate();

        this.ball.step();

        if(this.resolvePlayerBall(this.left)){
          this.events.leftTouch = true;
        }
        if(this.resolvePlayerBall(this.right)){
          this.events.rightTouch = true;
        }
        const netHit = this.resolveNet();
        if(netHit){
          this.events.netHit = netHit;
        }

        if(this.ball.y + BALL_RADIUS >= FLOOR_Y){
          this.events.floorSide = this.ball.x < NET_X ? 'left' : 'right';
          this.ball.y = FLOOR_Y - BALL_RADIUS;
          this.ball.vy *= -0.4;
        }

        const done = Boolean(this.events.floorSide);
        return {done};
      }
      resolvePlayerBall(player){
        const dx = this.ball.x - player.x;
        const dy = this.ball.y - (player.y - PLAYER_BODY_RADIUS * 0.15);
        const distSq = dx*dx + dy*dy;
        const minDist = PLAYER_HIT_RADIUS + BALL_RADIUS;
        if(distSq > minDist * minDist){
          return false;
        }
        const dist = Math.sqrt(distSq) || 1;
        const nx = dx / dist;
        const ny = dy / dist;
        this.ball.x = player.x + nx * (minDist + 2);
        this.ball.y = player.y - PLAYER_BODY_RADIUS * 0.15 + ny * (minDist + 2);

        const relativeVX = this.ball.vx - player.vx;
        const relativeVY = this.ball.vy - player.vy;
        const boost = 340 + Math.random() * 40;

        this.ball.vx = lerp(this.ball.vx, nx * boost, 0.65) + player.vx * 0.25;
        this.ball.vy = lerp(this.ball.vy, ny * boost, 0.65) + player.vy * 0.15;

        this.ball.lastTouchSide = player.side;
        this.ball.lastTouchedBy = player;
        player.touches++;
        return true;
      }
      resolveNet(){
        const netTop = FLOOR_Y - NET_HEIGHT;
        const netLeft = NET_X - NET_WIDTH/2;
        const netRight = NET_X + NET_WIDTH/2;
        let hitSide = null;

        if(this.ball.y + BALL_RADIUS > netTop && this.ball.y - BALL_RADIUS < FLOOR_Y){
          if(this.ball.x + BALL_RADIUS > netLeft && this.ball.x - BALL_RADIUS < netRight){
            if(this.ball.prevX <= netLeft && this.ball.x > netLeft){
              this.ball.x = netLeft - BALL_RADIUS;
              this.ball.vx *= -0.4;
            } else if(this.ball.prevX >= netRight && this.ball.x < netRight){
              this.ball.x = netRight + BALL_RADIUS;
              this.ball.vx *= -0.4;
            } else {
              this.ball.vy = Math.abs(this.ball.vy) * -0.3;
              this.ball.y = netTop - BALL_RADIUS;
            }
            hitSide = this.ball.lastTouchSide || 'left';
          }
        }
        return hitSide;
      }
    }

    class QLearningAgent{
      constructor(){
        this.q = new Map();
        this.learningRate = 0.18;
        this.gamma = 0.94;
        this.epsilon = 0.35;
        this.epsilonDecay = 0.993;
        this.minEpsilon = 0.02;
        this.episodes = 0;
        this.totalReward = 0;
      }
      setParams({learningRate, gamma, epsilon, epsilonDecay}){
        this.learningRate = learningRate;
        this.gamma = gamma;
        this.epsilon = epsilon;
        this.epsilonDecay = epsilonDecay;
      }
      buildState(env){
        const player = env.left;
        const ball = env.ball;
        const px = Math.floor(clamp((player.x - 80) / (NET_X - NET_WIDTH/2 - 80), 0, 0.999) * 6);
        const py = player.grounded ? 0 : (player.y < FLOOR_Y - 180 ? 2 : 1);
        const pvx = player.vx > 80 ? 2 : player.vx < -80 ? 0 : 1;
        const bx = Math.floor(clamp((ball.x - 40) / (NET_X - 40), 0, 0.999) * 6);
        const by = Math.floor(clamp((ball.y) / FLOOR_Y, 0, 0.999) * 6);
        const bvx = ball.vx > 90 ? 2 : ball.vx < -90 ? 0 : 1;
        const bvy = ball.vy > 80 ? 2 : ball.vy < -80 ? 0 : 1;
        const last = ball.lastTouchSide === 'left' ? 2 : ball.lastTouchSide === 'right' ? 1 : 0;
        const touches = Math.min(player.touches, 3);
        return `${px}|${py}|${pvx}|${bx}|${by}|${bvx}|${bvy}|${last}|${touches}`;
      }
      ensureState(key){
        if(!this.q.has(key)){
          this.q.set(key, new Float32Array(ACTIONS.length));
        }
        return this.q.get(key);
      }
      act(stateKey, training){
        const values = this.ensureState(stateKey);
        if(training && Math.random() < this.epsilon){
          return Math.floor(Math.random() * ACTIONS.length);
        }
        let best = 0;
        let bestVal = values[0];
        for(let i=1;i<values.length;i++){
          if(values[i] > bestVal){
            bestVal = values[i];
            best = i;
          }
        }
        return best;
      }
      learn(stateKey, action, reward, nextKey, done){
        const values = this.ensureState(stateKey);
        const current = values[action];
        let target = reward;
        if(!done){
          const nextValues = this.ensureState(nextKey);
          let maxNext = nextValues[0];
          for(let i=1;i<nextValues.length;i++){
            if(nextValues[i] > maxNext) maxNext = nextValues[i];
          }
          target += this.gamma * maxNext;
        }
        values[action] = current + this.learningRate * (target - current);
      }
      endEpisode(totalReward){
        this.episodes++;
        this.totalReward += totalReward;
        this.epsilon = Math.max(this.minEpsilon, this.epsilon * this.epsilonDecay);
      }
      reset(){
        this.q.clear();
        this.episodes = 0;
        this.totalReward = 0;
      }
    }

    function randomWeight(scale){
      return (Math.random() * 2 - 1) * scale;
    }

    function zeroMatrix(rows, cols){
      const matrix = new Array(rows);
      for(let r=0;r<rows;r++){
        matrix[r] = new Float32Array(cols);
      }
      return matrix;
    }

    class DenseNetwork{
      constructor(inputSize, hiddenSize, outputSize, learningRate){
        this.inputSize = inputSize;
        this.hiddenSize = hiddenSize;
        this.outputSize = outputSize;
        this.learningRate = learningRate;
        this.W1 = zeroMatrix(hiddenSize, inputSize);
        this.b1 = new Float32Array(hiddenSize);
        this.W2 = zeroMatrix(outputSize, hiddenSize);
        this.b2 = new Float32Array(outputSize);
        const scale1 = Math.sqrt(2 / (inputSize + hiddenSize));
        const scale2 = Math.sqrt(2 / (hiddenSize + outputSize));
        for(let i=0;i<hiddenSize;i++){
          for(let j=0;j<inputSize;j++){
            this.W1[i][j] = randomWeight(scale1);
          }
        }
        for(let k=0;k<outputSize;k++){
          for(let i=0;i<hiddenSize;i++){
            this.W2[k][i] = randomWeight(scale2);
          }
        }
      }
      forward(input){
        const hiddenRaw = new Float32Array(this.hiddenSize);
        const hidden = new Float32Array(this.hiddenSize);
        for(let i=0;i<this.hiddenSize;i++){
          let sum = this.b1[i];
          const row = this.W1[i];
          for(let j=0;j<this.inputSize;j++){
            sum += row[j] * input[j];
          }
          hiddenRaw[i] = sum;
          hidden[i] = sum > 0 ? sum : 0;
        }
        const output = new Float32Array(this.outputSize);
        for(let k=0;k<this.outputSize;k++){
          let sum = this.b2[k];
          const row = this.W2[k];
          for(let i=0;i<this.hiddenSize;i++){
            sum += row[i] * hidden[i];
          }
          output[k] = sum;
        }
        return {output, hidden, hiddenRaw, input};
      }
      predict(input){
        return this.forward(input).output;
      }
      train(batch){
        if(batch.length === 0) return;
        const gradW1 = zeroMatrix(this.hiddenSize, this.inputSize);
        const gradB1 = new Float32Array(this.hiddenSize);
        const gradW2 = zeroMatrix(this.outputSize, this.hiddenSize);
        const gradB2 = new Float32Array(this.outputSize);

        for(const sample of batch){
          const {cache, target} = sample;
          const {output, hidden, hiddenRaw, input} = cache;
          const gradOut = new Float32Array(this.outputSize);
          for(let k=0;k<this.outputSize;k++){
            gradOut[k] = output[k] - target[k];
            gradB2[k] += gradOut[k];
            const row = gradW2[k];
            for(let i=0;i<this.hiddenSize;i++){
              row[i] += gradOut[k] * hidden[i];
            }
          }
          const gradHidden = new Float32Array(this.hiddenSize);
          for(let i=0;i<this.hiddenSize;i++){
            let sum = 0;
            for(let k=0;k<this.outputSize;k++){
              sum += gradOut[k] * this.W2[k][i];
            }
            gradHidden[i] = hiddenRaw[i] > 0 ? sum : 0;
            gradB1[i] += gradHidden[i];
            const row = gradW1[i];
            for(let j=0;j<this.inputSize;j++){
              row[j] += gradHidden[i] * input[j];
            }
          }
        }

        const scale = this.learningRate / batch.length;
        for(let i=0;i<this.hiddenSize;i++){
          this.b1[i] -= gradB1[i] * scale;
          const row = this.W1[i];
          for(let j=0;j<this.inputSize;j++){
            row[j] -= gradW1[i][j] * scale;
          }
        }
        for(let k=0;k<this.outputSize;k++){
          this.b2[k] -= gradB2[k] * scale;
          const row = this.W2[k];
          for(let i=0;i<this.hiddenSize;i++){
            row[i] -= gradW2[k][i] * scale;
          }
        }
      }
      copyFrom(other){
        for(let i=0;i<this.hiddenSize;i++){
          this.b1[i] = other.b1[i];
          for(let j=0;j<this.inputSize;j++){
            this.W1[i][j] = other.W1[i][j];
          }
        }
        for(let k=0;k<this.outputSize;k++){
          this.b2[k] = other.b2[k];
          for(let i=0;i<this.hiddenSize;i++){
            this.W2[k][i] = other.W2[k][i];
          }
        }
      }
    }

    class ReplayBuffer{
      constructor(size){
        this.size = size;
        this.buffer = [];
        this.index = 0;
      }
      push(sample){
        if(this.buffer.length < this.size){
          this.buffer.push(sample);
        } else {
          this.buffer[this.index] = sample;
        }
        this.index = (this.index + 1) % this.size;
      }
      sample(batchSize){
        const result = [];
        for(let i=0;i<batchSize;i++){
          const idx = Math.floor(Math.random() * this.buffer.length);
          result.push(this.buffer[idx]);
        }
        return result;
      }
      get length(){
        return this.buffer.length;
      }
      clear(){
        this.buffer.length = 0;
        this.index = 0;
      }
    }

    class DoubleDQNAgent{
      constructor(){
        this.inputSize = 10;
        this.actions = ACTIONS.length;
        this.gamma = 0.98;
        this.epsilon = 0.40;
        this.epsilonDecay = 0.995;
        this.minEpsilon = 0.05;
        this.learningRate = 0.0015;
        this.batchSize = 64;
        this.targetSync = 480;
        this.replay = new ReplayBuffer(6000);
        this.online = new DenseNetwork(this.inputSize, 64, this.actions, this.learningRate);
        this.target = new DenseNetwork(this.inputSize, 64, this.actions, this.learningRate);
        this.target.copyFrom(this.online);
        this.stepCounter = 0;
        this.episodes = 0;
        this.totalReward = 0;
      }
      setParams({learningRate, gamma, epsilon, epsilonDecay, batchSize, targetSync}){
        if(learningRate !== undefined){
          this.learningRate = learningRate;
          this.online.learningRate = learningRate;
          this.target.learningRate = learningRate;
        }
        if(gamma !== undefined) this.gamma = gamma;
        if(epsilon !== undefined) this.epsilon = epsilon;
        if(epsilonDecay !== undefined) this.epsilonDecay = epsilonDecay;
        if(batchSize !== undefined) this.batchSize = Math.max(4, Math.floor(batchSize));
        if(targetSync !== undefined) this.targetSync = Math.max(20, Math.floor(targetSync));
      }
      stateVector(env){
        const player = env.right;
        const ball = env.ball;
        const dx = (ball.x - player.x) / FIELD_WIDTH;
        const dy = (ball.y - player.y) / FLOOR_Y;
        const norm = (value, scale) => clamp(value / scale, -1, 1);
        return new Float32Array([
          (player.x / FIELD_WIDTH) * 2 - 1,
          (player.y / FLOOR_Y) * 2 - 1,
          norm(player.vx, PLAYER_MAX_SPEED),
          norm(player.vy, PLAYER_JUMP),
          (ball.x / FIELD_WIDTH) * 2 - 1,
          (ball.y / FLOOR_Y) * 2 - 1,
          norm(ball.vx, BALL_MAX_SPEED),
          norm(ball.vy, BALL_MAX_SPEED),
          clamp(dx, -1, 1),
          clamp(dy, -1, 1)
        ]);
      }
      act(state, training){
        if(training && Math.random() < this.epsilon){
          return Math.floor(Math.random() * this.actions);
        }
        const values = this.online.predict(state);
        let best = 0;
        let bestVal = values[0];
        for(let i=1;i<values.length;i++){
          if(values[i] > bestVal){
            bestVal = values[i];
            best = i;
          }
        }
        return best;
      }
      remember(sample){
        this.replay.push(sample);
      }
      train(){
        if(this.replay.length < this.batchSize) return;
        const batchSamples = this.replay.sample(this.batchSize);
        const batch = [];
        for(const sample of batchSamples){
          const cache = this.online.forward(sample.state);
          const targetBase = cache.output;
          const updated = new Float32Array(targetBase);
          let targetValue = sample.reward;
          if(!sample.done){
            const nextOnline = this.online.predict(sample.nextState);
            let best = 0;
            let bestVal = nextOnline[0];
            for(let i=1;i<nextOnline.length;i++){
              if(nextOnline[i] > bestVal){
                bestVal = nextOnline[i];
                best = i;
              }
            }
            const nextTarget = this.target.predict(sample.nextState);
            targetValue += this.gamma * nextTarget[best];
          }
          updated[sample.action] = targetValue;
          batch.push({cache, target: updated});
        }
        this.online.train(batch);
        this.stepCounter++;
        if(this.stepCounter % this.targetSync === 0){
          this.target.copyFrom(this.online);
        }
      }
      endEpisode(totalReward){
        this.episodes++;
        this.totalReward += totalReward;
        this.epsilon = Math.max(this.minEpsilon, this.epsilon * this.epsilonDecay);
      }
      reset(){
        this.replay.clear();
        this.online = new DenseNetwork(this.inputSize, 64, this.actions, this.learningRate);
        this.target = new DenseNetwork(this.inputSize, 64, this.actions, this.learningRate);
        this.target.copyFrom(this.online);
        this.stepCounter = 0;
        this.episodes = 0;
        this.totalReward = 0;
      }
    }

    const env = new GameEnv();
    const qAgent = new QLearningAgent();
    const dqnAgent = new DoubleDQNAgent();

    let training = false;
    let episodes = 0;
    const maxSteps = 3600;
    let stepCount = 0;
    let episodeLeftReward = 0;
    let episodeRightReward = 0;
    const rewardHistory = [];

    function shapeRewards(){
      const {events} = env;
      let leftReward = 0.002;
      let rightReward = 0.002;

      if(events.leftTouch){
        leftReward += 0.45;
        rightReward -= 0.05;
      }
      if(events.rightTouch){
        rightReward += 0.45;
        leftReward -= 0.05;
      }
      if(events.netHit){
        if(events.netHit === 'left'){
          leftReward -= 0.35;
          rightReward += 0.08;
        } else {
          rightReward -= 0.35;
          leftReward += 0.08;
        }
      }
      if(env.ball.lastTouchSide === 'left' && env.ball.x > NET_X){
        leftReward += 0.12;
      }
      if(env.ball.lastTouchSide === 'right' && env.ball.x < NET_X){
        rightReward += 0.12;
      }

      if(events.floorSide){
        if(events.floorSide === 'left'){
          leftReward -= 2.5;
          rightReward += 2.5;
        } else {
          rightReward -= 2.5;
          leftReward += 2.5;
        }
      }

      return {leftReward, rightReward};
    }

    function simulateStep(){
      const leftState = qAgent.buildState(env);
      const rightState = dqnAgent.stateVector(env);
      const leftAction = qAgent.act(leftState, training);
      const rightAction = dqnAgent.act(rightState, training);

      const {done} = env.step(leftAction, rightAction);
      const {leftReward, rightReward} = shapeRewards();

      const nextLeftState = qAgent.buildState(env);
      const nextRightState = dqnAgent.stateVector(env);

      if(training){
        qAgent.learn(leftState, leftAction, leftReward, nextLeftState, done);
        dqnAgent.remember({state:rightState, action:rightAction, reward:rightReward, nextState:nextRightState, done});
        dqnAgent.train();
      }

      episodeLeftReward += leftReward;
      episodeRightReward += rightReward;
      stepCount++;

      let serveSide = env.ball.lastTouchSide === 'left' ? 'right' : 'left';
      if(done || stepCount >= maxSteps){
        episodes++;
        qAgent.endEpisode(episodeLeftReward);
        dqnAgent.endEpisode(episodeRightReward);
        rewardHistory.push({left:episodeLeftReward, right:episodeRightReward});
        if(rewardHistory.length > 24) rewardHistory.shift();
        serveSide = env.events.floorSide === 'left' ? 'right' : 'left';
        env.reset(serveSide);
        stepCount = 0;
        episodeLeftReward = 0;
        episodeRightReward = 0;
        updateStats();
        renderChart();
      }
    }

    function drawEnvironment(){
      ctx.clearRect(0, 0, FIELD_WIDTH, FIELD_HEIGHT);
      const grd = ctx.createLinearGradient(0, 0, 0, FIELD_HEIGHT);
      grd.addColorStop(0, '#0b1433');
      grd.addColorStop(0.6, '#13204d');
      grd.addColorStop(1, '#0f172a');
      ctx.fillStyle = grd;
      ctx.fillRect(0, 0, FIELD_WIDTH, FIELD_HEIGHT);

      ctx.fillStyle = '#0f172a';
      ctx.fillRect(0, FLOOR_Y, FIELD_WIDTH, FIELD_HEIGHT - FLOOR_Y);
      ctx.strokeStyle = 'rgba(148,163,209,0.4)';
      ctx.lineWidth = 4;
      ctx.strokeRect(60, FLOOR_Y - 6, FIELD_WIDTH - 120, 8);

      const netTop = FLOOR_Y - NET_HEIGHT;
      ctx.fillStyle = 'rgba(226,232,240,0.92)';
      ctx.fillRect(NET_X - NET_WIDTH/2, netTop, NET_WIDTH, NET_HEIGHT);
      ctx.strokeStyle = 'rgba(15,23,61,0.45)';
      ctx.lineWidth = 3;
      ctx.strokeRect(NET_X - NET_WIDTH/2, netTop, NET_WIDTH, NET_HEIGHT);

      ctx.strokeStyle = 'rgba(148,163,209,0.25)';
      ctx.lineWidth = 1;
      for(let i=1;i<6;i++){
        const y = netTop + (NET_HEIGHT / 6) * i;
        ctx.beginPath();
        ctx.moveTo(NET_X - NET_WIDTH/2, y);
        ctx.lineTo(NET_X + NET_WIDTH/2, y);
        ctx.stroke();
      }
    }

    function drawScene(){
      drawEnvironment();
      env.left.draw(ctx);
      env.right.draw(ctx);
      env.ball.draw(ctx);
    }

    function renderChart(){
      const chart = document.getElementById('rewardChart');
      chart.innerHTML = '';
      if(rewardHistory.length === 0){
        chart.classList.add('is-empty');
        return;
      }
      chart.classList.remove('is-empty');
      const maxReward = Math.max(...rewardHistory.map(entry => Math.max(Math.abs(entry.left), Math.abs(entry.right), 0.1)));
      rewardHistory.forEach((entry, index)=>{
        const leftBar = document.createElement('div');
        leftBar.className = 'fitness-bar';
        leftBar.style.height = `${clamp(Math.abs(entry.left) / (maxReward || 1), 0, 1) * 100}%`;
        leftBar.title = `Episode ${episodes - rewardHistory.length + index + 1} – Left reward ${entry.left.toFixed(2)}`;
        leftBar.innerHTML = `<span>L${episodes - rewardHistory.length + index + 1}</span><small>${entry.left.toFixed(1)}</small>`;
        chart.appendChild(leftBar);

        const rightBar = document.createElement('div');
        rightBar.className = 'fitness-bar fitness-bar--emerald';
        rightBar.style.height = `${clamp(Math.abs(entry.right) / (maxReward || 1), 0, 1) * 100}%`;
        rightBar.title = `Episode ${episodes - rewardHistory.length + index + 1} – Right reward ${entry.right.toFixed(2)}`;
        rightBar.innerHTML = `<span>R${episodes - rewardHistory.length + index + 1}</span><small>${entry.right.toFixed(1)}</small>`;
        chart.appendChild(rightBar);
      });
    }

    function updateStats(){
      document.getElementById('lbEpisodes').textContent = episodes.toString();
      const leftAvg = qAgent.episodes ? qAgent.totalReward / qAgent.episodes : 0;
      const rightAvg = dqnAgent.episodes ? dqnAgent.totalReward / dqnAgent.episodes : 0;
      document.getElementById('lbLeftReward').textContent = leftAvg.toFixed(2);
      document.getElementById('lbRightReward').textContent = rightAvg.toFixed(2);
      document.getElementById('lbLeftEpsilon').textContent = qAgent.epsilon.toFixed(2);
      document.getElementById('lbRightEpsilon').textContent = dqnAgent.epsilon.toFixed(2);
    }

    const simSpeedInput = document.getElementById('slSimSpeed');
    let simSpeed = simSpeedInput ? parseInt(simSpeedInput.value, 10) : 1;

    const controlBindings = [
      ['slQLearningRate','lbQLearningRate', value => { qAgent.learningRate = parseFloat(value); }],
      ['slQDiscount','lbQDiscount', value => { qAgent.gamma = parseFloat(value); }],
      ['slQEpsilon','lbQEpsilon', value => { qAgent.epsilon = parseFloat(value); }],
      ['slQEpsilonDecay','lbQEpsilonDecay', value => { qAgent.epsilonDecay = parseFloat(value); }],
      ['slDqnLearningRate','lbDqnLearningRate', value => { dqnAgent.learningRate = parseFloat(value); dqnAgent.online.learningRate = parseFloat(value); dqnAgent.target.learningRate = parseFloat(value); }],
      ['slDqnGamma','lbDqnGamma', value => { dqnAgent.gamma = parseFloat(value); }],
      ['slDqnEpsilon','lbDqnEpsilon', value => { dqnAgent.epsilon = parseFloat(value); }],
      ['slDqnEpsilonDecay','lbDqnEpsilonDecay', value => { dqnAgent.epsilonDecay = parseFloat(value); }],
      ['slTargetSync','lbTargetSync', value => { dqnAgent.targetSync = Math.max(20, parseInt(value, 10)); }],
      ['slBatchSize','lbBatchSize', value => { dqnAgent.batchSize = Math.max(4, parseInt(value, 10)); }],
      ['slSimSpeed','lbSimSpeed', value => { simSpeed = parseInt(value, 10); }]
    ];

    controlBindings.forEach(([inputId, labelId, handler]) => {
      const input = document.getElementById(inputId);
      const label = document.getElementById(labelId);
      if(!input || !label) return;
      const update = () => {
        if(inputId === 'slSimSpeed'){
          label.textContent = `${input.value}×`;
        } else {
          const step = Math.abs(parseFloat(input.step || '1'));
          let decimals = 0;
          if(step && step < 1){
            if(step < 0.001){
              decimals = 4;
            } else if(step < 0.01){
              decimals = 3;
            } else if(step < 0.1){
              decimals = 2;
            } else {
              decimals = 1;
            }
          }
          label.textContent = parseFloat(input.value).toFixed(decimals);
        }
        handler(input.value);
        updateStats();
      };
      input.addEventListener('input', update);
      update();
    });

    document.getElementById('btnToggleTraining').addEventListener('click', () => {
      training = !training;
      document.getElementById('btnToggleTraining').textContent = training ? 'Pause training' : 'Start training';
    });

    document.getElementById('btnReset').addEventListener('click', () => {
      training = false;
      document.getElementById('btnToggleTraining').textContent = 'Start training';
      qAgent.reset();
      dqnAgent.reset();
      episodes = 0;
      rewardHistory.length = 0;
      env.reset('left');
      stepCount = 0;
      episodeLeftReward = 0;
      episodeRightReward = 0;
      updateStats();
      renderChart();
    });

    updateStats();
    renderChart();

    function loop(){
      requestAnimationFrame(loop);
      for(let i=0;i<simSpeed;i++){
        if(training){
          simulateStep();
        }
      }
      drawScene();
    }

    loop();
  </script>
</body>
</html>
