<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>FoodSim ‚Äì Two Teams with NEAT-lite</title>
  <style>
    :root {
      --bg1:#050516;
      --bg2:#0f1536;
      --panel:rgba(14,19,48,.9);
      --ink:#f5f7ff;
      --muted:#a0accf;
      --accent:#f472b6;
      --accent-emerald:#7cf29d;
      --accent-cyan:#38bdf8;
      --silver:rgba(148,163,209,.35);
    }
    *{box-sizing:border-box}
    body{margin:0; min-height:100vh; display:flex; flex-direction:column; background:radial-gradient(circle at 18% 10%, rgba(56,189,248,.18) 0%, transparent 46%), radial-gradient(circle at 82% 8%, rgba(244,114,182,.16) 0%, transparent 54%), radial-gradient(circle at 12% 78%, rgba(124,242,157,.12) 0%, transparent 55%), linear-gradient(160deg, var(--bg1) 0%, var(--bg2) 55%, #1a2344 100%); color:var(--ink); font-family:"Inter",system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;}

    .main-nav{position:sticky; top:0; z-index:200; padding:22px 48px; display:flex; align-items:center; justify-content:space-between; background:linear-gradient(120deg, rgba(15,20,48,.92) 0%, rgba(10,14,34,.75) 60%, rgba(10,14,34,.35) 100%); backdrop-filter:blur(14px); border-bottom:1px solid var(--silver); box-shadow:0 22px 45px rgba(5,9,25,.55)}
    .brand{display:flex; align-items:center; gap:12px; font-size:22px; font-weight:700; letter-spacing:.02em; color:var(--ink)}
    .brand-dot{width:14px; height:14px; border-radius:50%; background:linear-gradient(135deg, var(--accent) 0%, #8b5cf6 100%); box-shadow:0 0 18px rgba(244,114,182,.6)}
    .nav-links{display:flex; align-items:center; gap:12px}
    .pill-link,.pill-button{display:inline-flex; align-items:center; justify-content:center; padding:10px 20px; border-radius:999px; border:1px solid rgba(45,212,191,.45); background:linear-gradient(120deg, rgba(45,212,191,.18), rgba(59,130,246,.18)); color:var(--ink); text-decoration:none; font-size:14px; font-weight:600; letter-spacing:.03em; transition:transform .2s ease, box-shadow .2s ease, filter .2s ease, border-color .2s ease; cursor:pointer; font-family:inherit}
    .pill-link.secondary{border-color:rgba(139,92,246,.45); background:linear-gradient(120deg, rgba(139,92,246,.18), rgba(244,114,182,.18))}
    .pill-link:hover,.pill-button:hover{transform:translateY(-1px); filter:brightness(1.05); box-shadow:0 16px 32px rgba(45,212,191,.25)}
    .pill-link:focus-visible,.pill-button:focus-visible{outline:2px solid rgba(56,189,248,.65); outline-offset:3px}
    .pill-button{background:linear-gradient(120deg, rgba(139,92,246,.22), rgba(56,189,248,.22)); border-color:rgba(56,189,248,.45)}
    .pill-button.pill-button--active{border-color:rgba(244,114,182,.65); background:linear-gradient(120deg, rgba(244,114,182,.25), rgba(59,130,246,.25)); box-shadow:0 18px 40px rgba(244,114,182,.32)}

    main{flex:1; display:flex; justify-content:center; align-items:flex-start; padding:40px 48px 64px}
    .wrap{display:flex; align-items:flex-start; justify-content:center; gap:40px; width:100%; max-width:2000px}
    .field-area{flex:1 1 auto; display:flex; flex-direction:column; align-items:stretch; gap:18px; min-width:0}
    .playfield-frame{position:relative; padding:18px; border-radius:30px; background:rgba(4,8,26,.85); box-shadow:0 18px 36px rgba(9,14,36,.55); border:1px solid rgba(148,163,209,.22); transition:box-shadow .3s ease, transform .3s ease, background .3s ease, border-color .3s ease; width:100%; max-width:min(1100px, 100%)}
    .playfield-frame::before{content:""; position:absolute; inset:-8px; border-radius:inherit; background:linear-gradient(135deg, rgba(56,189,248,.35), rgba(244,114,182,.32)); opacity:0; filter:blur(12px); transition:opacity .35s ease, filter .35s ease; z-index:0}
    .info-overlay{position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); z-index:3; width:min(480px, 92%); pointer-events:auto}
    .info-overlay .brain-guide{margin-top:0}
    .info-overlay .intro-guide{box-shadow:0 22px 48px rgba(4,8,26,.75)}
    .playfield-frame canvas{position:relative; z-index:1; width:100%; height:auto; display:block}
    canvas{border-radius:24px; background:#04091f; box-shadow:0 0 45px rgba(15,23,61,.65), inset 0 0 22px rgba(118,133,255,.12); cursor:crosshair; border:1px solid var(--silver);}
    .stats-bar{display:grid; grid-template-columns:repeat(auto-fit,minmax(150px,1fr)); gap:16px; padding:18px 22px; border-radius:18px; background:rgba(11,16,44,.78); border:1px solid var(--silver); box-shadow:0 18px 32px rgba(5,9,25,.45)}
    .stat-card{display:flex; flex-direction:column; gap:6px; padding:6px 0}
    .stat-label{font-size:12px; text-transform:uppercase; letter-spacing:.12em; color:var(--muted)}
    .stat-value{font-size:26px; font-weight:700; letter-spacing:.02em; color:var(--ink)}

    .brain-viz{padding:20px 24px; border-radius:22px; background:rgba(11,16,44,.82); border:1px solid var(--silver); box-shadow:0 18px 32px rgba(5,9,25,.4); display:flex; flex-direction:column; gap:14px}
    .brain-viz.brain-viz--hidden{box-shadow:0 12px 24px rgba(5,9,25,.35)}
    .brain-head{display:flex; align-items:flex-start; justify-content:space-between; gap:18px; flex-wrap:wrap}
    .brain-title{font-size:16px; font-weight:600; letter-spacing:.03em}
    .brain-sub{font-size:12px; color:var(--muted); margin-top:4px; max-width:420px}
    .brain-controls{display:flex; align-items:center; flex-wrap:wrap; gap:10px; margin-top:12px}
    .brain-select{padding:7px 16px; border-radius:999px; border:1px solid rgba(56,189,248,.35); background:rgba(12,20,46,.75); color:var(--ink); font-size:12px; font-weight:600; letter-spacing:.05em; text-transform:uppercase; cursor:pointer; appearance:none; position:relative; min-width:190px; box-shadow:inset 0 0 16px rgba(56,189,248,.12)}
    .brain-select:focus-visible{outline:2px solid rgba(56,189,248,.65); outline-offset:3px}
    .brain-toggle{padding:6px 14px; border-radius:999px; border:1px solid rgba(56,189,248,.45); background:rgba(15,23,61,.6); color:var(--ink); font-size:11px; font-weight:600; letter-spacing:.12em; text-transform:uppercase; cursor:pointer; transition:transform .18s ease, box-shadow .2s ease, filter .2s ease}
    .brain-toggle:hover{filter:brightness(1.05); transform:translateY(-1px); box-shadow:0 12px 24px rgba(56,189,248,.25)}
    .brain-toggle[aria-pressed="false"]{border-color:rgba(244,114,182,.45); background:rgba(24,16,38,.65); color:var(--muted)}
    .brain-score{display:flex; flex-direction:column; align-items:flex-end; min-width:120px}
    .brain-score-label{font-size:11px; text-transform:uppercase; letter-spacing:.12em; color:var(--muted)}
    .brain-score-value{font-size:30px; font-weight:700; color:var(--ink)}
    .brain-team{display:flex; align-items:center; gap:10px; font-size:13px; color:var(--muted); flex-wrap:wrap}
    .brain-badge{display:inline-flex; align-items:center; justify-content:center; width:26px; height:26px; border-radius:50%; background:rgba(56,189,248,.3); color:#020617; font-size:15px; font-weight:700; box-shadow:0 0 18px rgba(56,189,248,.28)}
    .brain-gen{margin-left:auto; font-size:11px; color:var(--muted); letter-spacing:.08em; text-transform:uppercase}
    .brain-visual-wrap{display:flex; flex-wrap:wrap; gap:18px; align-items:stretch}
    .brain-canvas-wrap{flex:1 1 360px; min-width:0; display:flex; flex-direction:column; gap:10px}
    .brain-canvas{width:100%; height:220px; border-radius:18px; background:linear-gradient(135deg, rgba(15,23,61,.65), rgba(12,18,44,.92)); border:1px solid rgba(148,163,209,.28)}
    .brain-paused{padding:12px 14px; border-radius:14px; border:1px dashed rgba(148,163,209,.4); background:rgba(15,23,61,.55); font-size:12px; line-height:1.6; color:var(--muted)}
    .brain-legend{flex:0 1 240px; min-width:220px; align-self:stretch; border-radius:18px; border:1px solid rgba(148,163,209,.22); background:linear-gradient(135deg, rgba(10,18,46,.65), rgba(7,12,30,.82)); padding:16px 18px; display:flex; flex-direction:column; gap:14px; box-shadow:inset 0 0 18px rgba(59,130,246,.08)}
    .brain-legend.brain-legend--under{flex:1 1 100%; min-width:0; width:100%; margin-top:4px}
    .brain-legend-title{font-size:12px; font-weight:700; text-transform:uppercase; letter-spacing:.08em; color:var(--muted)}
    .brain-legend-list{list-style:none; margin:0; padding:0; display:grid; gap:10px}
    .brain-legend-item{display:flex; align-items:center; gap:10px; font-size:12px; line-height:1.5; color:var(--ink)}
    .brain-legend-dot{width:14px; height:14px; border-radius:50%; box-shadow:0 0 10px rgba(56,189,248,.45)}
    .brain-legend-dot-pair{display:inline-flex; align-items:center; gap:6px}
    .brain-legend-dot--target{background:linear-gradient(135deg, rgba(56,189,248,.9), rgba(96,165,250,.75))}
    .brain-legend-dot--target-home{background:linear-gradient(135deg, rgba(251,191,36,.9), rgba(253,224,71,.75)); box-shadow:0 0 10px rgba(251,191,36,.45)}
    .brain-legend-dot--gradient{background:linear-gradient(135deg, rgba(45,212,191,.9), rgba(16,185,129,.75)); box-shadow:0 0 10px rgba(45,212,191,.45)}
    .brain-legend-dot--separation{background:linear-gradient(135deg, rgba(244,114,182,.9), rgba(251,191,188,.75)); box-shadow:0 0 10px rgba(244,114,182,.45)}
    .brain-legend-dot--velocity{background:linear-gradient(135deg, rgba(167,139,250,.9), rgba(129,140,248,.75)); box-shadow:0 0 10px rgba(167,139,250,.45)}
    .brain-legend-dot--obstacle{background:linear-gradient(135deg, rgba(248,113,113,.9), rgba(239,68,68,.75)); box-shadow:0 0 10px rgba(248,113,113,.45)}
    .brain-legend-dot--boundary{background:linear-gradient(135deg, rgba(96,165,250,.9), rgba(59,130,246,.75)); box-shadow:0 0 10px rgba(96,165,250,.45)}
    .brain-legend-note{font-size:11px; line-height:1.6; color:var(--muted); border-top:1px dashed rgba(148,163,209,.3); padding-top:10px}
    .brain-guide{margin-top:16px; padding:18px 20px; border-radius:18px; border:1px solid var(--silver); background:rgba(11,16,44,.78); box-shadow:0 12px 28px rgba(5,9,25,.35);}
    .intro-guide{border-color:rgba(45,212,191,.45); background:rgba(9,18,42,.82)}
    .intro-guide summary{color:var(--ink)}
    .intro-list{margin:0; padding-left:18px; display:grid; gap:8px; font-size:13px; color:var(--ink); line-height:1.6}
    .intro-list li{margin:0}
    .brain-guide summary{cursor:pointer; font-weight:600; letter-spacing:.04em; text-transform:uppercase; font-size:12px; color:var(--muted); display:flex; align-items:center; justify-content:space-between; gap:12px}
    .brain-guide summary::-webkit-details-marker{display:none}
    .brain-guide summary::after{content:'‚ñæ'; font-size:12px; transition:transform .25s ease}
    .brain-guide[open] summary::after{transform:rotate(-180deg)}
    .brain-guide-body{margin-top:14px; display:grid; gap:16px}
    .brain-guide-body p{margin:0; font-size:13px; color:var(--ink); line-height:1.7}
    .brain-diagram{border-radius:16px; border:1px solid rgba(148,163,209,.28); background:linear-gradient(135deg, rgba(15,23,61,.55), rgba(12,18,44,.9)); padding:14px}
    .brain-diagram svg{width:100%; height:auto}
    .brain-diagram text{fill:rgba(226,232,255,0.82); font-family:"Inter",system-ui,-apple-system,sans-serif; font-size:12px; letter-spacing:.02em}
    .brain-diagram .label{font-size:13px; font-weight:600}

    .side{width:420px; flex:0 1 420px; display:flex; flex-direction:column; gap:20px}
    .panel{background:var(--panel); border:1px solid var(--silver); padding:22px; border-radius:20px; backdrop-filter:blur(16px); box-shadow:0 18px 45px rgba(5,7,24,.55); position:relative}
    .panel-info{border-color:rgba(124,242,157,.5); background:rgba(8,18,40,.88)}
    .panel-info .panel-head{border-bottom-color:rgba(124,242,157,.35)}
    .panel-info .panel-head .h{color:var(--accent-emerald)}
    .panel-head{display:flex; align-items:center; justify-content:space-between; gap:12px; cursor:pointer; user-select:none; padding-bottom:10px; margin-bottom:14px; border-bottom:1px dashed rgba(189,206,255,.28)}
    .panel-head .h{margin:0; font-size:17px; letter-spacing:.03em}
    .chev{font-weight:900; font-size:16px; opacity:.75; transition:transform .25s ease}
    .panel-body{max-height:none; overflow:visible; transition:opacity .25s ease; opacity:1}
    .panel.collapsed .panel-body{max-height:0; opacity:0; overflow:hidden; pointer-events:none}
    .panel.collapsed .chev{transform:rotate(-90deg)}

    .grid{display:grid; grid-template-columns: 1fr 1.3fr auto; gap:12px 12px; align-items:center}
    .label{font-size:13px; color:var(--muted); letter-spacing:.02em}
    .val{font-family:ui-monospace,Menlo,Consolas,monospace; font-size:12px; padding:4px 8px; border-radius:8px; background:rgba(10,16,46,.7); border:1px solid var(--silver); color:var(--accent-cyan); box-shadow:inset 0 0 12px rgba(56,189,248,.12)}
    input[type=range]{width:100%; accent-color:var(--accent-cyan)}
    .fruit-placement-options{grid-column:2 / span 2; display:flex; flex-wrap:wrap; gap:8px}
    .fruit-placement-option{position:relative; display:inline-flex; align-items:center; gap:8px; padding:8px 12px; border-radius:12px; border:1px solid var(--silver); background:rgba(12,18,44,.65); color:var(--muted); font-size:12px; font-weight:600; letter-spacing:.03em; cursor:pointer; transition:filter .2s ease, transform .2s ease, box-shadow .2s ease, border-color .2s ease}
    .fruit-placement-option:hover{filter:brightness(1.05); transform:translateY(-1px)}
    .fruit-placement-option.active{border-color:rgba(56,189,248,.55); color:var(--ink); background:rgba(12,22,56,.9); box-shadow:0 10px 24px rgba(56,189,248,.18)}
    .fruit-placement-option input{position:absolute; inset:0; opacity:0; pointer-events:none}
    .btn{display:block; width:100%; padding:12px 14px; border-radius:12px; border:1px solid rgba(45,212,191,.45); background:linear-gradient(120deg, rgba(45,212,191,.18), rgba(59,130,246,.18)); color:var(--ink); cursor:pointer; text-align:center; margin-top:14px; font-weight:600; letter-spacing:.02em; transition:transform .2s ease, box-shadow .2s ease, filter .2s ease}
    .btn:hover{filter:brightness(1.08); transform:translateY(-1px); box-shadow:0 20px 36px rgba(45,212,191,.28)}
    .btn:disabled{opacity:.55; cursor:not-allowed; filter:saturate(.5); box-shadow:none}
    .tool-hint{margin:0 0 14px; font-size:12px; line-height:1.6; color:var(--muted)}
    .info-list{margin:0; padding-left:18px; display:grid; gap:8px; font-size:12px; color:var(--ink); line-height:1.6}
    .tool-buttons{display:grid; grid-template-columns:repeat(auto-fit,minmax(120px,1fr)); gap:10px}
    .tool-btn{padding:10px 12px; border-radius:12px; border:1px solid rgba(59,130,246,.28); background:rgba(18,27,66,.6); color:var(--ink); font-size:13px; font-weight:600; letter-spacing:.02em; cursor:pointer; transition:transform .2s ease, box-shadow .2s ease, filter .2s ease, border-color .2s ease}
    .tool-btn:hover{filter:brightness(1.05); transform:translateY(-1px); box-shadow:0 12px 26px rgba(59,130,246,.22)}
    .tool-btn.active{border-color:rgba(45,212,191,.65); background:linear-gradient(120deg, rgba(45,212,191,.24), rgba(59,130,246,.24)); box-shadow:0 14px 28px rgba(45,212,191,.24)}
    .sub{font-weight:800; font-size:14px; opacity:.9; margin:10px 0 8px; letter-spacing:.05em; color:var(--ink)}
    .team-roster{display:grid; grid-template-columns:repeat(auto-fit,minmax(160px,1fr)); gap:12px}
    .team-card{position:relative; display:flex; flex-direction:column; gap:6px; padding:14px 16px; border-radius:14px; border:1px solid var(--silver); background:rgba(12,18,44,.72); box-shadow:0 10px 24px rgba(5,9,28,.4); transition:transform .2s ease, box-shadow .2s ease, border-color .2s ease}
    .team-card:hover{transform:translateY(-2px); box-shadow:0 16px 32px rgba(5,9,28,.5)}
    .team-card.active{border-color:rgba(45,212,191,.6); box-shadow:0 18px 36px rgba(45,212,191,.22)}
    .team-card input[type=checkbox]{position:absolute; inset:0; opacity:0; cursor:pointer; border-radius:14px}
    .team-card .team-header{display:flex; align-items:center; gap:10px}
    .team-card .team-name{font-weight:600; letter-spacing:.02em}
    .team-card .team-meta{font-size:12px; color:var(--muted)}
    .team-score{font-size:12px; color:var(--ink); font-weight:600; margin-top:2px}
    .team-score span{color:var(--muted); font-weight:500}
    .team-badge{display:inline-flex; align-items:center; justify-content:center; width:28px; height:28px; border-radius:50%; font-size:16px; box-shadow:0 0 18px rgba(255,255,255,.2); color:#020617}
    .team-configs{display:grid; gap:16px; margin-top:16px}
    .team-config-card{border:1px solid var(--silver); border-radius:16px; background:rgba(12,18,44,.72); padding:18px 20px; box-shadow:0 12px 28px rgba(5,9,28,.45); display:grid; gap:14px; transition:filter .2s ease, border-color .2s ease}
    .team-config-card.inactive{filter:saturate(.65) brightness(.85); border-color:rgba(148,163,209,.28)}
    .team-config-header{display:flex; align-items:center; justify-content:space-between; gap:12px}
    .team-config-title{display:flex; align-items:center; gap:10px; font-weight:600; letter-spacing:.02em}
    .team-config-badge{display:inline-flex; align-items:center; justify-content:center; width:26px; height:26px; border-radius:50%; box-shadow:0 0 12px rgba(148,163,209,.28); font-size:15px}
    .team-config-status{font-size:12px; color:var(--muted)}
    .team-config-grid{display:grid; grid-template-columns: minmax(90px,0.9fr) 1fr auto; gap:10px 12px; align-items:center}
    .team-config-grid .label{font-size:12px; text-transform:uppercase; letter-spacing:.08em}
    .team-config-grid .val{min-width:56px; text-align:right}
    .music-lead{font-size:13px; line-height:1.6; opacity:.85; margin:0 0 14px}
    .music-select{display:flex; flex-direction:column; gap:6px}
    .music-dropdown{width:100%; padding:10px 12px; border-radius:12px; border:1px solid var(--silver); background:rgba(12,18,44,.82); color:var(--ink); font-size:13px; font-family:inherit; letter-spacing:.01em; box-shadow:inset 0 0 12px rgba(118,133,255,.15)}
    .music-controls{display:flex; align-items:center; gap:12px; margin-top:12px; flex-wrap:wrap}
    .music-controls .btn{flex:0 0 auto; width:auto; padding:10px 18px; margin-top:0}
    .music-volume{display:flex; flex:1; align-items:center; gap:10px; min-width:200px}
    .music-volume .label{min-width:60px}
    .music-volume input[type=range]{flex:1}
    .music-meta{margin-top:14px; font-size:12px; line-height:1.6; background:rgba(11,16,44,.65); border:1px solid var(--silver); padding:12px 14px; border-radius:14px; box-shadow:inset 0 0 14px rgba(138,92,246,.12)}
    .music-status{display:flex; align-items:center; gap:8px; font-size:12px; text-transform:uppercase; letter-spacing:.08em; opacity:.82; color:var(--accent-cyan)}
    .music-attr{opacity:.72}
    .sr-only{position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0}

    body.performance-mode{background:radial-gradient(circle at 50% 18%, rgba(59,130,246,.22) 0%, rgba(15,23,42,.9) 55%, #030513 100%);}
    body.performance-mode .brand, body.performance-mode .nav-links{display:none}
    body.performance-mode .main-nav{background:transparent; border:none; box-shadow:none; padding:20px 28px; justify-content:flex-end}
    body.performance-mode .main-nav::before{display:none}
    body.performance-mode .wrap{max-width:none; justify-content:center}
    body.performance-mode main{padding:40px 0 60px}
    body.performance-mode .side, body.performance-mode .stats-bar, body.performance-mode .brain-viz, body.performance-mode .brain-guide{display:none !important}
    body.performance-mode .field-area{align-items:center; gap:28px}
    body.performance-mode .field-area > :not(.playfield-frame){display:none !important}
    body.performance-mode .playfield-frame{max-width:min(1100px, 92vw); width:100%; padding:28px; border:1px solid rgba(148,163,209,.35); background:rgba(8,12,30,.82); box-shadow:0 0 40px rgba(56,189,248,.35), 0 0 140px rgba(244,114,182,.25)}
    body.performance-mode .playfield-frame::before{opacity:1; filter:blur(22px)}
    body.performance-mode canvas{width:100%; height:auto; box-shadow:0 0 55px rgba(56,189,248,.22), inset 0 0 28px rgba(148,163,209,.16); border:1px solid rgba(148,163,209,.45)}
    body.performance-mode #btnPerformance{pointer-events:auto}

    @media (max-width:1200px){
      .wrap{flex-direction:column; align-items:center}
      .field-area{width:100%}
      .side{width:100%; max-width:720px}
    }
    @media (max-width:900px){
      main{padding:32px 28px 56px}
    }
    @media (max-width:768px){
      .main-nav{flex-direction:column; align-items:flex-start; gap:16px; padding:18px 24px}
      .nav-links{flex-wrap:wrap}
      main{padding:28px 20px 56px}
      .wrap{gap:28px}
      canvas{width:100%; height:auto}
      .stats-bar{grid-template-columns:repeat(auto-fit,minmax(130px,1fr)); gap:12px; padding:16px 18px}
      .stat-value{font-size:22px}
      .side{max-width:100%}
      .brain-canvas{height:200px}
      .brain-visual-wrap{flex-direction:column}
      .brain-legend{width:100%; min-width:0}
      .info-overlay{width:min(520px, 92%); top:52%}
    }
  </style>
</head>
<body>
  <header class="main-nav">
    <div class="brand"><span class="brand-dot"></span>FoodSim NEAT Lab</div>
    <nav class="nav-links" aria-label="Primary navigation">
      <a class="pill-link secondary" href="foodsim-about.html">FoodSim guide</a>
      <a class="pill-link secondary" href="learn-neat.html">How NEAT works</a>
      <a class="pill-link" href="index.html">‚Üê Start</a>
    </nav>
    <button type="button" id="btnPerformance" class="pill-button" aria-pressed="false" title="Focus on the playfield and boost frame rates">Performance</button>
  </header>
  <main>
  <div class="wrap">
    <!-- Left panel: Learning (NEAT) -->
    <aside class="side" id="left-panel">
      <div class="panel panel-info" id="panel-info">
        <div class="panel-head" role="button" tabindex="0" aria-expanded="true" aria-controls="panel-info-body"><div class="h">Simulation overview</div><span class="chev">‚ñæ</span></div>
        <div class="panel-body" id="panel-info-body">
          <p class="tool-hint">Jump back into FoodSim quickly with these essentials.</p>
          <p>
                You are watching tiny teams learn to collect fruit and bring it back to their home base. They start out clumsy, but the
                longer you let the sim run, the smarter their routes become. The default settings is really easy to learn for the AI so adjust for more advance experiance.
              </p>
              <ul class="intro-list">
                <li><strong>Look at the field:</strong> snakes try to reach fruit, then return home with it and get points.</li>
                <li><strong>Avoid obstacles:</strong> the rocks block paths, so teams learn to go around them.</li>
                <li><strong>Try an easy tweak:</strong> move the <em>Obstacles or Home</em> slider or switch the <em>Navigation preset</em>.</li>
                <li><strong>Restart anytime:</strong> hit <em>Restart</em> to reshuffle and watch a new learning run.</li>
                <li><strong>Add Blockers:</strong> <em></em>to see how they learn to block the agents from gathering food.</li>
              </ul>
              <p>
                Want to see what the agents sense? Toggle <em>Sensor overlay</em> in Global controls to paint their guidance signals on
                the field.
                You adjust the learning and obstacles in this panel to the left and global control and team adjustments to the rigth. In the middle you can follow the neural network.
              </p>
            
          </ul>
        </div>
      </div>
      <div class="panel" id="panel-learn">
        <div class="panel-head" role="button" tabindex="0" aria-expanded="true" aria-controls="panel-learn-body"><div class="h">Learning (NEAT-lite)</div><span class="chev">‚ñæ</span></div>
        <div class="panel-body" id="panel-learn-body">
          <div class="grid">
            <div class="label" title="Number of simulation steps each generation runs before evaluating fitness.">Steps / gen</div>
            <input id="slGenSteps" type="range" min="150" max="100000" value="1500" title="Number of simulation steps each generation runs before evaluating fitness."><div class="val" id="lbGenSteps">1500</div>

            <div class="label" title="Hidden neurons connecting the sensory inputs to the outputs.">Hidden neurons</div>
            <input id="slHidden" type="range" min="4" max="96" value="16" title="Hidden neurons connecting the sensory inputs to the outputs."><div class="val" id="lbHidden">16 neurons</div>

            <div class="label" title="Percentage of offspring genomes that receive random mutations.">Mutation %</div>
            <input id="slMut" type="range" min="1" max="80" value="16" title="Percentage of offspring genomes that receive random mutations."><div class="val" id="lbMut">16%</div>

            <div class="label" title="Share of the best performers copied directly into the next generation.">Elite ratio</div>
            <input id="slElite" type="range" min="1" max="100" value="20" title="Share of the best performers copied directly into the next generation."><div class="val" id="lbElite">20%</div>

            <div class="label" title="Strength of the random adjustments applied to neural network connection weights.">Mutate weights</div>
            <input id="slMutStrengthW" type="range" min="5" max="100" value="20" title="Strength of the random adjustments applied to neural network connection weights."><div class="val" id="lbMutStrengthW">0.20</div>

            <div class="label" title="Strength of the random adjustments applied to neuron bias values.">Mutate biases</div>
            <input id="slMutStrengthB" type="range" min="5" max="100" value="20" title="Strength of the random adjustments applied to neuron bias values."><div class="val" id="lbMutStrengthB">0.20</div>

            <div class="label" title="Chance that crossover keeps genes from parent A versus parent B.">Crossover bias</div>
            <input id="slCrossover" type="range" min="0" max="100" value="50" title="Chance that crossover keeps genes from parent A versus parent B."><div class="val" id="lbCrossover">50% A</div>

            <div class="label" title="Number of contenders in the tournament pool when picking parents.">Selection pool</div>
            <input id="slTournament" type="range" min="10" max="60" value="20" step="1" title="Number of contenders in the tournament pool when picking parents."><div class="val" id="lbTournament">√ó2.0</div>

            <div class="label" title="Percentage of brand new genomes injected into each generation.">Fresh spawn %</div>
            <input id="slFresh" type="range" min="0" max="40" value="0" title="Percentage of brand new genomes injected into each generation."><div class="val" id="lbFresh">0%</div>

            <div class="label" title="Automatically advance once the current generation finishes simulating.">Auto next gen</div>
            <input id="chkAuto" type="checkbox" checked title="Automatically advance once the current generation finishes simulating."><div class="val" id="lbAuto">on</div>
          </div>
          <button id="btnNextGen" class="btn">Advance generation now</button>
          <button id="btnResetTraining" class="btn">Reset training</button>
          <button id="btnSaveTraining" class="btn">Save training (.json)</button>
          <button id="btnLoadTraining" class="btn">Load training‚Ä¶</button>
          <input type="file" id="inputLoadTraining" accept="application/json" style="display:none">
        </div>
      </div>

      <div class="panel" id="panel-toolbox">
        <div class="panel-head" role="button" tabindex="0" aria-expanded="true" aria-controls="panel-toolbox-body"><div class="h">Obstacle toolbox</div><span class="chev">‚ñæ</span></div>
        <div class="panel-body" id="panel-toolbox-body">
          <p class="tool-hint">Choose a tool to draw glowing obstacles directly on the field.</p>
          <div class="tool-buttons" role="group" aria-label="Obstacle drawing tools">
            <button class="tool-btn active" data-tool="select" aria-pressed="true">Move</button>
            <button class="tool-btn" data-tool="circle" aria-pressed="false">Circle</button>
            <button class="tool-btn" data-tool="rect" aria-pressed="false">Rectangle</button>
            <button class="tool-btn" data-tool="line" aria-pressed="false">Line</button>
            <button class="tool-btn" data-tool="half" aria-pressed="false">Half circle</button>
          </div>
          <button id="btnUndoManual" class="btn" disabled>Undo last manual obstacle</button>
          <button id="btnClearManual" class="btn">Clear manual obstacles</button>
          <button id="btnGenerateLabyrinth" class="btn">Generate labyrinth</button>
          <button id="btnSaveObstacles" class="btn">Save obstacles (.json)</button>
          <button id="btnLoadObstacles" class="btn">Load obstacles‚Ä¶</button>
          <input type="file" id="inputLoadObstacles" accept="application/json" style="display:none">
        </div>
      </div>

      <div class="panel" id="panel-music">
        <div class="panel-head" role="button" tabindex="0" aria-expanded="false" aria-controls="panel-music-body"><div class="h">Ambient Sound Lounge</div><span class="chev">‚ñæ</span></div>
        <div class="panel-body" id="panel-music-body">
          <p class="music-lead">Play MP3 files from your audio folder. Add your own tracks to the list!</p>
          <div class="music-select">
            <label class="label" for="selMusic">Curated playlist</label>
            <select id="selMusic" class="music-dropdown"></select>
          </div>
          <div class="music-controls">
            <button id="btnMusicToggle" class="btn">Play</button>
            <div class="music-volume">
              <span class="label">Volume</span>
              <input id="slMusicVolume" type="range" min="0" max="100" value="55">
              <span class="val" id="lbMusicVolume">55%</span>
            </div>
          </div>
          <div class="music-meta">
            <div class="music-status"><span id="lbMusicState">Paused</span></div>
            <div id="lbMusicNow" class="music-attr">Choose a track to begin.</div>
            <div id="lbMusicSource" class="music-attr">Royalty-free ambient selections streamed from Pixabay artists.</div>
          </div>
        </div>
      </div>
    </aside>

    <!-- Middle: playfield -->
    <div class="field-area">
      <div class="playfield-frame" title="Welcome to Foodsim! Two AI teams roam the arena, learn over generations, and try to deliver fruit back home. Watch how they adapt, dodge obstacles, and cooperate as the simulation scores their choices and slowly evolves their strategies into smarter runs.">
       
        <canvas id="world" width="1100" height="640"></canvas>
      </div>
      <section class="stats-bar" aria-label="Simulation progress" aria-live="polite">
        <div class="stat-card">
          <span class="stat-label">Generation</span>
          <span class="stat-value" id="stat-gen">1</span>
        </div>
        <div class="stat-card">
          <span class="stat-label">Teams active</span>
          <span class="stat-value" id="stat-teams">2</span>
        </div>
        <div class="stat-card">
          <span class="stat-label">Fruits on field</span>
          <span class="stat-value" id="stat-fruits">0</span>
        </div>
        <div class="stat-card">
          <span class="stat-label">Deliveries</span>
          <span class="stat-value" id="stat-deliveries">0</span>
        </div>
        <div class="stat-card">
          <span class="stat-label">Steps</span>
          <span class="stat-value" id="stat-steps">0 / 0</span>
        </div>
        <div class="stat-card">
          <span class="stat-label">Top fitness</span>
          <span class="stat-value" id="stat-top">0</span>
        </div>
      </section>
      <section class="brain-viz brain-viz--hidden" aria-live="polite" aria-label="Best performing neural network">
        <div class="brain-head">
          <div>
            <div class="brain-title">Neural Network Monitor</div>
            <div class="brain-sub" id="brain-subtitle">The leading brain will appear here once a team starts scoring.</div>
            <div class="brain-controls">
              <label class="sr-only" for="brainTeamSelect">Choose the team to visualize</label>
              <select id="brainTeamSelect" class="brain-select">
                <option value="auto">Auto ‚Äî top performer</option>
              </select>
              <button type="button" id="brainToggleBtn" class="brain-toggle" aria-pressed="false">
                Show visualization
              </button>
            </div>
          </div>
          <div class="brain-score">
            <span class="brain-score-label">Fitness</span>
            <span class="brain-score-value" id="brain-fitness">‚Äî</span>
          </div>
        </div>
        <div class="brain-team">
          <span class="brain-badge" id="brain-badge">‚óè</span>
          <span id="brain-team">No leader yet</span>
          <span class="brain-gen" id="brain-generation">Gen ‚Äî</span>
        </div>
        <div class="brain-visual-wrap">
          <div class="brain-canvas-wrap">
            <canvas id="brainVizCanvas" class="brain-canvas" width="560" height="240" hidden role="img" aria-label="Visualization of the current top neural network"></canvas>
            <div id="brainPausedNotice" class="brain-paused" hidden>
              Visualization hidden to save performance. Toggle it back on anytime to resume live updates.
            </div>
          </div>
          <aside class="brain-legend brain-legend--under" aria-label="Neural network legend">
            <div class="brain-legend-section">
              <div class="brain-legend-title">Inputs</div>
              <ul class="brain-legend-list">
                <li class="brain-legend-item"><span class="brain-legend-dot-pair" aria-hidden="true"><span class="brain-legend-dot brain-legend-dot--target"></span><span class="brain-legend-dot brain-legend-dot--target-home"></span></span><span>Fruit direction turns cyan ‚Äî it glows amber while carrying food home.</span></li>
                <li class="brain-legend-item"><span class="brain-legend-dot brain-legend-dot--gradient" aria-hidden="true"></span><span>Trail gradient pointing toward food or back to base.</span></li>
                <li class="brain-legend-item"><span class="brain-legend-dot brain-legend-dot--separation" aria-hidden="true"></span><span>Repulsion from nearby teammates to prevent crowding.</span></li>
                <li class="brain-legend-item"><span class="brain-legend-dot brain-legend-dot--obstacle" aria-hidden="true"></span><span>Obstacle avoidance pulse steering away from hazards.</span></li>
                <li class="brain-legend-item"><span class="brain-legend-dot brain-legend-dot--boundary" aria-hidden="true"></span><span>Wall clearance hint nudging agents toward open space.</span></li>
                <li class="brain-legend-item"><span class="brain-legend-dot brain-legend-dot--velocity" aria-hidden="true"></span><span>Blocker-only: predicted movement of the closest rival.</span></li>
              </ul>
            </div>
            <div class="brain-legend-note">Toggle ‚ÄúSensor overlay‚Äù in Global controls to paint these signals directly on the field.</div>
            <div class="brain-legend-section">
              <div class="brain-legend-title">Outputs</div>
              <ul class="brain-legend-list">
                <li class="brain-legend-item">Drive X / Drive Y ‚Äî steering left &amp; right</li>
                <li class="brain-legend-item">Speed + ‚Äî accelerate</li>
                <li class="brain-legend-item">Speed ‚àí ‚Äî brake</li>
              </ul>
            </div>
          </aside>
        </div>
      </section>
      <details class="brain-guide" id="brainGuide">
        <summary>Neural network visual guide</summary>
        <div class="brain-guide-body">
          <p>
            This panel shows the brain of whichever team is winning the food race right now. Circles on the left are the signals the
            agents feel ‚Äî fruit direction, teammate distance, obstacle pings and the round timer. The middle dots mix those signals,
            and the four outputs on the right tell the agent how to turn and how fast to move.
          </p>
          <figure class="brain-diagram">
            <svg viewBox="0 0 520 220" role="img" aria-labelledby="brain-diagram-title brain-diagram-desc">
              <title id="brain-diagram-title">Neural network layers</title>
              <desc id="brain-diagram-desc">Inputs flow to hidden neurons and then to four output commands.</desc>
              <defs>
                <linearGradient id="nodeInput" x1="0" x2="1" y1="0" y2="1">
                  <stop offset="0%" stop-color="#38bdf8" stop-opacity="0.6" />
                  <stop offset="100%" stop-color="#38bdf8" stop-opacity="0.2" />
                </linearGradient>
                <linearGradient id="nodeHidden" x1="0" x2="1" y1="0" y2="1">
                  <stop offset="0%" stop-color="#2dd4bf" stop-opacity="0.6" />
                  <stop offset="100%" stop-color="#2dd4bf" stop-opacity="0.2" />
                </linearGradient>
                <linearGradient id="nodeOutput" x1="0" x2="1" y1="0" y2="1">
                  <stop offset="0%" stop-color="#f472b6" stop-opacity="0.6" />
                  <stop offset="100%" stop-color="#f472b6" stop-opacity="0.2" />
                </linearGradient>
              </defs>
              <g stroke="rgba(148,163,209,0.35)" stroke-width="1.2">
                <line x1="110" y1="40" x2="260" y2="40" />
                <line x1="110" y1="40" x2="260" y2="100" />
                <line x1="110" y1="40" x2="260" y2="160" />
                <line x1="110" y1="100" x2="260" y2="40" />
                <line x1="110" y1="100" x2="260" y2="100" />
                <line x1="110" y1="100" x2="260" y2="160" />
                <line x1="110" y1="160" x2="260" y2="40" />
                <line x1="110" y1="160" x2="260" y2="100" />
                <line x1="110" y1="160" x2="260" y2="160" />
                <line x1="260" y1="40" x2="410" y2="40" />
                <line x1="260" y1="40" x2="410" y2="90" />
                <line x1="260" y1="40" x2="410" y2="140" />
                <line x1="260" y1="40" x2="410" y2="190" />
                <line x1="260" y1="100" x2="410" y2="40" />
                <line x1="260" y1="100" x2="410" y2="90" />
                <line x1="260" y1="100" x2="410" y2="140" />
                <line x1="260" y1="100" x2="410" y2="190" />
                <line x1="260" y1="160" x2="410" y2="40" />
                <line x1="260" y1="160" x2="410" y2="90" />
                <line x1="260" y1="160" x2="410" y2="140" />
                <line x1="260" y1="160" x2="410" y2="190" />
              </g>
              <g fill="url(#nodeInput)">
                <circle cx="110" cy="40" r="18"></circle>
                <circle cx="110" cy="100" r="18"></circle>
                <circle cx="110" cy="160" r="18"></circle>
              </g>
              <g fill="url(#nodeHidden)">
                <circle cx="260" cy="40" r="16"></circle>
                <circle cx="260" cy="100" r="16"></circle>
                <circle cx="260" cy="160" r="16"></circle>
              </g>
              <g fill="url(#nodeOutput)">
                <circle cx="410" cy="40" r="18"></circle>
                <circle cx="410" cy="90" r="18"></circle>
                <circle cx="410" cy="140" r="18"></circle>
                <circle cx="410" cy="190" r="18"></circle>
              </g>
              <text class="label" x="110" y="200" text-anchor="middle">Inputs</text>
              <text class="label" x="260" y="200" text-anchor="middle">Hidden layer</text>
              <text class="label" x="410" y="200" text-anchor="middle">Outputs</text>
              <text x="440" y="40" text-anchor="start" dominant-baseline="middle">Drive X</text>
              <text x="440" y="90" text-anchor="start" dominant-baseline="middle">Drive Y</text>
              <text x="440" y="140" text-anchor="start" dominant-baseline="middle">Speed +</text>
              <text x="440" y="190" text-anchor="start" dominant-baseline="middle">Speed ‚àí</text>
            </svg>
          </figure>
          <p>
            Bright lines mean a strong signal. Cyan edges push movement in the same direction as the input, while magenta edges flip
            the response. Watching the colours change makes it easier to spot why a team turns, speeds up or slows down.
          </p>
          <p>
            The badge above the diagram lists which team owns the brain and which generation discovered it so you always know whose
            strategy you are following.
          </p>
        </div>
      </details>
    </div>

    <!-- Right panels: controls and teams -->
    <aside class="side" id="right-panel">
     
      <div class="panel" id="panel-global">
        <div class="panel-head" role="button" tabindex="0" aria-expanded="true" aria-controls="panel-global-body"><div class="h">Global controls</div><span class="chev">‚ñæ</span></div>
        <div class="panel-body" id="panel-global-body">
          <div class="grid">
            <div class="label">Fruit (max)</div>
            <input id="slFruits" type="range" min="2" max="1000" value="150"><div class="val" id="lbFruits">150</div>

            <div class="label" id="fruitPlacementLabel">Fruit placement</div>
            <div class="fruit-placement-options" role="group" aria-labelledby="fruitPlacementLabel">
              <label class="fruit-placement-option">
                <input type="checkbox" name="fruitPlacement" value="sw">
                <span aria-hidden="true">BL</span>
                <span class="sr-only">Bottom left</span>
              </label>
              <label class="fruit-placement-option">
                <input type="checkbox" name="fruitPlacement" value="se">
                <span aria-hidden="true">BR</span>
                <span class="sr-only">Bottom right</span>
              </label>
              <label class="fruit-placement-option">
                <input type="checkbox" name="fruitPlacement" value="ne">
                <span aria-hidden="true">TR</span>
                <span class="sr-only">Top right</span>
              </label>
              <label class="fruit-placement-option">
                <input type="checkbox" name="fruitPlacement" value="nw">
                <span aria-hidden="true">TL</span>
                <span class="sr-only">Top left</span>
              </label>
              <label class="fruit-placement-option">
                <input type="checkbox" name="fruitPlacement" value="center" checked>
                <span aria-hidden="true">C</span>
                <span class="sr-only">Center</span>
              </label>
              <label class="fruit-placement-option">
                <input type="checkbox" name="fruitPlacement" value="random">
                <span aria-hidden="true">R</span>
                <span class="sr-only">Random</span>
              </label>
            </div>

            <div class="label">Spawn (ms)</div>
            <input id="slSpawn" type="range" min="120" max="15000" value="900"><div class="val" id="lbSpawn">900</div>

            <div class="label">Simulation speed</div>
            <input id="slSimSpeed" type="range" min="10" max="600" value="100" step="5"><div class="val" id="lbSimSpeed">1.00√ó</div>

            <div class="label">Obstacles</div>
            <input id="slObst" type="range" min="0" max="40" value="25"><div class="val" id="lbObst">25</div>

            <div class="label">Trail length</div>
            <input id="slTail" type="range" min="4" max="1500" value="24"><div class="val" id="lbTail">24</div>

            <div class="label">Snake size</div>
            <input id="slAgentScale" type="range" min="50" max="150" value="100" step="5"><div class="val" id="lbAgentScale">1.00√ó</div>

            <div class="label">Agent collisions</div>
            <input id="chkAgentCollisions" type="checkbox"><div class="val" id="lbAgentCollisions">off</div>

            <div class="label">Top performer glow</div>
            <input id="chkTopHighlight" type="checkbox" checked><div class="val" id="lbTopHighlight">on</div>

            <div class="label">Energy rings</div>
            <input id="chkEnergyHalo" type="checkbox" checked><div class="val" id="lbEnergyHalo">on</div>

            <div class="label">Energy empty speed</div>
            <input id="slEnergyEmptySpeed" type="range" min="10" max="100" value="45" step="5"><div class="val" id="lbEnergyEmptySpeed">45%</div>

            <div class="label">Energy capacity</div>
            <input id="slEnergyCapacity" type="range" min="0" max="300" value="120" step="10"><div class="val" id="lbEnergyCapacity">120</div>

            <div class="label">Awareness boost</div>
            <input id="slAwarenessBoost" type="range" min="50" max="200" value="100" step="5"><div class="val" id="lbAwarenessBoost">100%</div>

            <div class="label" title="Agents that run out of energy will be removed and penalized.">Energy exhaustion death</div>
            <input id="chkEnergyDeath" type="checkbox" checked><div class="val" id="lbEnergyDeath">on</div>

            <div class="label">Sensor overlay</div>
            <input id="chkSensorRadar" type="checkbox"><div class="val" id="lbSensorRadar">off</div>

            <div class="label">Navigation preset</div>
            <select id="selNavPreset" class="music-dropdown">
              <option value="open">Open Field</option>
              <option value="lab" selected>Labyrinth</option>
            </select><div class="val" id="lbNavPreset">Labyrinth</div>
          </div>
          <button id="btnReset" class="btn">Restart</button>
        </div>
      </div>

      <div class="panel" id="panel-teams">
        <div class="panel-head" role="button" tabindex="0" aria-expanded="true" aria-controls="panel-teams-body"><div class="h">Team settings</div><span class="chev">‚ñæ</span></div>
        <div class="panel-body" id="panel-teams-body">
          <div class="sub">Teams</div>
          <div class="team-roster" id="teamRoster"></div>
          <div class="sub" style="margin-top:14px">Attributes per team</div>
          <div class="team-configs" id="teamConfigs"></div>
        </div>
      </div>
    </aside>
  </div>
  </main>


<script>
// ===== Utils for UI =====
const Q = (id)=>document.getElementById(id);
function bindRange(sl, lb, fmt=(v)=>v){ const s=Q(sl), l=Q(lb); const apply=()=>{ l.textContent = fmt(+s.value); readParams(); }; s.addEventListener('input', apply); apply(); }

function setRangeValue(id, value){
  const el = Q(id);
  if(!el) return;
  const min = el.min !== undefined ? Number(el.min) : Number(value);
  const max = el.max !== undefined ? Number(el.max) : Number(value);
  const clamped = Math.min(max, Math.max(min, Number(value)));
  if(String(el.value) !== String(clamped)){
    el.value = clamped;
  }
  el.dispatchEvent(new Event('input', { bubbles:true }));
}

function setToggleValue(id, checked){
  const el = Q(id);
  if(!el) return;
  const next = !!checked;
  if(el.checked !== next){
    el.checked = next;
    el.dispatchEvent(new Event('change', { bubbles:true }));
  }
}

function getNow(){
  return (typeof performance !== 'undefined' && performance.now)
    ? performance.now()
    : Date.now();
}

// === Make panels collapsible ===
(function makePanelsCollapsible(){
  const panels = document.querySelectorAll('.panel');
  panels.forEach((p)=>{
    const head = p.querySelector('.panel-head');
    const body = p.querySelector('.panel-body');
    if(!head || !body) return;

    if(!body.id){
      body.id = `${p.id || 'panel'}-body`;
    }
    head.setAttribute('aria-controls', body.id);

    const updateAria = ()=>{
      const expanded = !p.classList.contains('collapsed');
      head.setAttribute('aria-expanded', String(expanded));
    };
    updateAria();

    const toggle = ()=>{
      p.classList.toggle('collapsed');
      updateAria();
    };

    head.addEventListener('click', (e)=>{
      if(e.target.closest('button, a, input, select, textarea')) return;
      toggle();
    });
    head.addEventListener('keydown', (e)=>{
      if(e.key === 'Enter' || e.key === ' '){
        e.preventDefault();
        toggle();
      }
    });
  });
})();

// ===== Colors =====
const TAU = Math.PI * 2;

const COLORS = {
  fruit: '#ffd43b',
  goal:  '#3b82f6',
  goalFill: 'rgba(59,130,246,0.18)',
  fruitOutline:'#000'
};

const FRUIT_PLACEMENT_LABELS = {
  random: 'Random',
  center: 'Center',
  nw: 'Top left',
  ne: 'Top right',
  sw: 'Bottom left',
  se: 'Bottom right'
};
const FRUIT_PLACEMENT_MODES = Object.keys(FRUIT_PLACEMENT_LABELS);

const TEAM_PRESETS = [
  { id:'green', label:'Greens', icon:'üü¢', color:'#00ff91', outline:'#003322', badge:'#bbf7d0', goalAnchor:{ x:0.86, y:0.35 }, spawn:{ x:[0.05,0.96], y:[0.04,0.12] } },
  { id:'red', label:'Reds', icon:'üî¥', color:'#ff0055', outline:'#5a001a', badge:'#fecdd3', goalAnchor:{ x:0.14, y:0.65 }, spawn:{ x:[0.04,0.12], y:[0.5,0.96] } },
  { id:'blocker', label:'Blockers', icon:'üõ°Ô∏è', color:'#a855f7', outline:'#581c87', badge:'#e9d5ff', role:'blocker', goalAnchor:{ x:0.48, y:0.50 }, spawn:{ x:[0.42,0.58], y:[0.76,0.94] } },
  { id:'blue', label:'Blues', icon:'üîµ', color:'#60a5fa', outline:'#1e3a8a', badge:'#bfdbfe', goalAnchor:{ x:0.22, y:0.24 }, spawn:{ x:[0.18,0.52], y:[0.06,0.42] } },
  { id:'amber', label:'Ambers', icon:'üü†', color:'#f97316', outline:'#7c2d12', badge:'#fed7aa', goalAnchor:{ x:0.80, y:0.76 }, spawn:{ x:[0.52,0.90], y:[0.58,0.94] } }
];
const TEAM_PRESET_MAP = new Map(TEAM_PRESETS.map((preset)=> [preset.id, preset]));

const NAV_PRESETS = {
  lab: {
    name: "Labyrinth",
    obstacleGenerator:'labyrinth',
    ui: { awarenessBoostPct:160, team:{speed:3.8,smart:3.0,strat:2.6,sep:1.1},
          agentScalePct:90, energyEmptyPct:60, energyCapacity:180,
          agentCollisions:false, learn:{steps:1500, mutPct:24, elitePct:12} },
    nav: { obstacleThreshold:22, boundaryPadding:16, avoidPushGain:0.08, safeNavReward:0.10 }
  },
  open: {
    name: "Open Field",
    ui: { awarenessBoostPct:110, team:{speed:4.8,smart:2.4,strat:2.2,sep:1.0},
          agentScalePct:100, energyEmptyPct:45, energyCapacity:120,
          agentCollisions:true, learn:{steps:1500, mutPct:16, elitePct:20} },
    nav: { obstacleThreshold:12, boundaryPadding:10, avoidPushGain:0.055, safeNavReward:0.06 }
  }
};

const teamControlRefs = new Map();

const OBSTACLE_COLORS = ['#38bdf8', '#f472b6', '#2dd4bf'];
const LINE_OBSTACLE_COLOR = '#dbe7ff';

function clamp(value, min, max){
  return Math.max(min, Math.min(max, value));
}

const SPEED_FACTOR_MIN = 0.35;
const SPEED_FACTOR_MAX = 1.0;
const SPEED_FACTOR_ADJUST = 0.03;
const ENERGY_MULTIPLIER_MIN = 0.10;
const ENERGY_MULTIPLIER_MAX = 1.0;
const COLLECTOR_ENERGY_CAPACITY_DEFAULT = 120;
const COLLECTOR_ENERGY_CAPACITY_MIN = 0;
const COLLECTOR_ENERGY_CAPACITY_MAX = 300;
const AWARENESS_BOOST_MIN = 0.50;
const AWARENESS_BOOST_MAX = 2.00;
const COLLECTOR_ENERGY_DECAY = 0.08;
const COLLECTOR_ENERGY_PICKUP_BOOST = 80;
const COLLECTOR_ENERGY_SPEED_MIN_DEFAULT = 0.45;
const NAV = {
  obstacleThreshold: 12,
  boundaryPadding: 10,
  avoidPushGain: 0.055,
  safeNavReward: 0.06
};
const ENERGY_DEATH_PENALTY = 150;
const SIM_SPEED_MIN = 0.10;
const SIM_SPEED_MAX = 6.00;
const SIMULATION_STEP_MS = 1000 / 60;
const MAX_SIM_STEPS_PER_FRAME = 360;
const MAX_FRAME_DELTA_MS = 250;

function hexToRgba(hex, alpha){
  const h = hex.replace('#','');
  const bigint = parseInt(h,16);
  const r=(bigint>>16)&255;
  const g=(bigint>>8)&255;
  const b=bigint&255;
  return `rgba(${r},${g},${b},${alpha})`;
}

const canvas = document.getElementById('world');
const ctx = canvas.getContext('2d');
if(canvas){
  canvas.style.touchAction = 'none';
}
let canvasBounds = null;
let canvasBoundsTimestamp = 0;
const CANVAS_BOUNDS_MAX_AGE = 250;
function updateCanvasBounds(){
  if(!canvas) return;
  canvasBounds = canvas.getBoundingClientRect();
  canvasBoundsTimestamp = getNow();
}
function invalidateCanvasBounds(){
  canvasBoundsTimestamp = 0;
}
if(canvas){
  updateCanvasBounds();
  if(typeof window !== 'undefined'){
    window.addEventListener('resize', updateCanvasBounds);
    window.addEventListener('scroll', invalidateCanvasBounds, true);
  }
}
const W = canvas.width, H = canvas.height;

const brainCanvas = document.getElementById('brainVizCanvas');
const brainCtx = brainCanvas ? brainCanvas.getContext('2d') : null;
const brainSubtitleEl = Q('brain-subtitle');
const brainTeamEl = Q('brain-team');
const brainBadgeEl = Q('brain-badge');
const brainFitnessEl = Q('brain-fitness');
const brainGenEl = Q('brain-generation');
const brainToggleBtn = Q('brainToggleBtn');
const brainPausedEl = Q('brainPausedNotice');
const brainVizSection = document.querySelector('.brain-viz');
const brainTeamSelect = Q('brainTeamSelect');
const performanceBtn = document.getElementById('btnPerformance');
const navPresetSelect = Q('selNavPreset');
const navPresetLabel = Q('lbNavPreset');
const statElements = {
  gen: document.getElementById('stat-gen'),
  teams: document.getElementById('stat-teams'),
  fruits: document.getElementById('stat-fruits'),
  deliveries: document.getElementById('stat-deliveries'),
  steps: document.getElementById('stat-steps'),
  top: document.getElementById('stat-top')
};
const statCache = { gen:null, teams:null, fruits:null, deliveries:null, steps:null, top:null };
let brainCanvasWidth = brainCanvas ? brainCanvas.clientWidth : 0;
let brainCanvasHeight = brainCanvas ? brainCanvas.clientHeight : 0;
let brainVizEnabled = false;
let performanceModeActive = false;
const performanceModePrefs = { topHighlight:null, energyHalo:null, brainViz:null, sensorRadar:null };
const AGENT_BASE_RADIUS = 5.2;
const AGENT_BASE_PICKUP_RADIUS = 9;
const AGENT_BASE_SEPARATION_RADIUS = 22;
const AGENT_TRAIL_WIDTH = 2;
let currentTopAgent = null;
let currentTopFitness = -Infinity;

const TOOL_SELECT='select';
const TOOL_CIRCLE='circle';
const TOOL_RECT='rect';
const TOOL_LINE='line';
const TOOL_HALF='half';

let currentTool = TOOL_SELECT;
let drawingState = null;
let manualPaletteCursor = 0;
let dragRadius = 0;
let activePointerId = null;

// Neural network hidden layer constraints must be defined before params
// because the default params.learn.hidden value reads NET_HIDDEN.
const NET_HIDDEN_MIN = 4;
const NET_HIDDEN_MAX = 96;
let NET_HIDDEN = 16;

// ===== Parameters =====
const params = {
  maxFruits: 150,
  spawnMs: 900,
  simSpeed: 1.0,
  obstacles: 25,
  tailLen: 24,
  agentScale: 1.00,
  agentCollisions: false,
  showTopHighlight: true,
  showEnergyHalo: true,
  energyCapacity: COLLECTOR_ENERGY_CAPACITY_DEFAULT,
  energyEmptySpeed: COLLECTOR_ENERGY_SPEED_MIN_DEFAULT,
  dieOnEnergyLoss: true,
  showSensorRadar: false,
  awarenessBoost: 1.0,
  fruitPlacement: 'center',
  teams: TEAM_PRESETS.map((preset, index)=>({
    id:preset.id,
    label:preset.label,
    icon:preset.icon,
    color:preset.color,
    outline:preset.outline,
    badge:preset.badge,
    role:preset.role || 'collector',
    goalAnchor:Object.assign({}, preset.goalAnchor),
    spawn:preset.spawn
      ? (preset.spawn.areas
        ? { areas: preset.spawn.areas.map((area)=> ({ x: area.x.slice(), y: area.y.slice() })) }
        : { x:preset.spawn.x.slice(), y:preset.spawn.y.slice() })
      : { x:[0.1,0.9], y:[0.1,0.9] },
    active:index < 2,
    count:(preset.id === 'green' || preset.id === 'red') ? 80 : 28,
    speed:4.60,
    smart:2.80,
    strat:2.40,
    sep:1.10
  })),
  learn: { genSteps:1500, hidden: NET_HIDDEN, mut:0.16, elite:0.20, mutStrengthW:0.20, mutStrengthB:0.20, crossoverBias:0.50, tournamentFactor:2.0, fresh:0, auto:true }
};
let lastObstCount = params.obstacles;

function getEnergyEmptySpeedSetting(){
  const value = params?.energyEmptySpeed;
  if(!Number.isFinite(value)) return COLLECTOR_ENERGY_SPEED_MIN_DEFAULT;
  return clamp(value, ENERGY_MULTIPLIER_MIN, ENERGY_MULTIPLIER_MAX);
}

function getCollectorEnergyCapacity(){
  const value = params?.energyCapacity;
  if(!Number.isFinite(value)) return COLLECTOR_ENERGY_CAPACITY_DEFAULT;
  return clamp(value, COLLECTOR_ENERGY_CAPACITY_MIN, COLLECTOR_ENERGY_CAPACITY_MAX);
}

function applyCollectorEnergyCapacity(){
  if(!Array.isArray(activeTeamStates) || activeTeamStates.length === 0) return;
  const capacity = getCollectorEnergyCapacity();
  for(const team of activeTeamStates){
    if(!team || !Array.isArray(team.agents)) continue;
    for(const agent of team.agents){
      if(!agent || agent.role !== 'collector') continue;
      const prevMax = Number(agent.energyMax);
      if(Number.isFinite(prevMax) && Math.abs(prevMax - capacity) < 1e-6){
        if(typeof agent.updateEnergyThrottle === 'function'){
          agent.updateEnergyThrottle();
        }
        continue;
      }
      const prevEnergy = Number(agent.energy);
      const ratio = prevMax > 0 ? clamp(prevEnergy / prevMax, 0, 1) : 1;
      agent.enableEnergy(capacity);
      if(capacity > 0){
        agent.energy = clamp(capacity * ratio, 0, capacity);
      } else {
        agent.energy = 0;
      }
      if(typeof agent.updateEnergyThrottle === 'function'){
        agent.updateEnergyThrottle();
      }
    }
  }
}

function getAwarenessBoost(){
  const value = params?.awarenessBoost;
  if(!Number.isFinite(value)) return 1;
  return clamp(value, AWARENESS_BOOST_MIN, AWARENESS_BOOST_MAX);
}

function getEffectiveSmartValue(teamConfig){
  const baseSmart = Number(teamConfig?.smart);
  if(!Number.isFinite(baseSmart)) return 0;
  return baseSmart * getAwarenessBoost();
}

// Dynamically discovered MP3 playlist
let musicTracks = [];
let currentTrackIndex = 0;
let isMusicPlaying = false;
let musicToggleBtn = null;
let audioElement = null;
let pendingVolume = 0.55;
let musicSelect = null;

async function discoverAudioTracks(){
  const manifestUrl = 'Audio/manifest.json';
  const directoryUrl = 'Audio/';
  const normalize = (filename)=>{
    const base = filename.replace(/^.*\//, '');
    const title = base.replace(/\.[^.]+$/, '').replace(/[-_]+/g, ' ').replace(/\s+/g, ' ').trim();
    return {
      filename: base,
      title: title ? title.replace(/\b\w/g, (c)=>c.toUpperCase()) : base,
      artist: 'Local file'
    };
  };

  // First try manifest.json for a curated list
  try{
    const manifestResponse = await fetch(manifestUrl, { cache:'no-store' });
    if(manifestResponse.ok){
      const data = await manifestResponse.json();
      if(Array.isArray(data.files)){
        const files = data.files.map(String).filter((name)=>/\.mp3$/i.test(name));
        if(files.length){
          return files.map(normalize);
        }
      }
    }
  }catch(err){
    console.warn('Audio manifest.json not available:', err);
  }

  // Fallback: attempt to fetch directory listing and parse anchor tags
  try{
    const directoryResponse = await fetch(directoryUrl, { cache:'no-store' });
    if(!directoryResponse.ok) throw new Error(`HTTP ${directoryResponse.status}`);
    const text = await directoryResponse.text();
    const parser = new DOMParser();
    const doc = parser.parseFromString(text, 'text/html');
    const anchors = Array.from(doc.querySelectorAll('a'));
    const files = anchors
      .map((a)=>a.getAttribute('href') || '')
      .map((href)=>href.split('?')[0])
      .filter((href)=>/\.mp3$/i.test(href))
      .map((href)=>decodeURIComponent(href.replace(/^\//, '')))
      .map((href)=>href.replace(/^.*Audio\//i, ''));
    const unique = Array.from(new Set(files.filter(Boolean)));
    unique.sort((a,b)=>a.localeCompare(b, undefined, { sensitivity:'base' }));
    return unique.map(normalize);
  }catch(err){
    console.warn('Unable to auto-discover audio files in /Audio:', err);
  }

  return [];
}

// Initialize HTML5 Audio element
function initAudioElement(){
  if(!audioElement){
    audioElement = new Audio();
    audioElement.loop = true;
    audioElement.volume = pendingVolume;
    audioElement.addEventListener('ended', ()=>{
      isMusicPlaying = false;
      updateMusicMeta(getCurrentTrack(), 'Ended');
      updateMusicButton();
    });
    audioElement.addEventListener('error', (e)=>{
      console.error('Audio playback error:', e);
      isMusicPlaying = false;
      updateMusicMeta(getCurrentTrack(), 'Error loading track');
      updateMusicButton();
    });
    audioElement.addEventListener('canplay', ()=>{
      if(isMusicPlaying){
        updateMusicMeta(getCurrentTrack(), 'Playing');
      }
    });
  }
  return audioElement;
}


function readParams(){
  params.maxFruits = +Q('slFruits').value; Q('lbFruits').textContent=params.maxFruits;
  params.spawnMs = +Q('slSpawn').value; Q('lbSpawn').textContent=params.spawnMs;
  const simSpeedSlider = Q('slSimSpeed');
  if(simSpeedSlider){
    const percent = Number(simSpeedSlider.value);
    const normalized = clamp(percent / 100, SIM_SPEED_MIN, SIM_SPEED_MAX);
    params.simSpeed = normalized;
    const label = Q('lbSimSpeed');
    if(label){
      label.textContent = `${normalized.toFixed(2)}√ó`;
    }
  }
  params.obstacles = +Q('slObst').value; Q('lbObst').textContent=params.obstacles; if(params.obstacles !== lastObstCount){ makeObstacles(params.obstacles); lastObstCount = params.obstacles; }
  params.tailLen = +Q('slTail').value; Q('lbTail').textContent=params.tailLen;
  params.agentScale = (+Q('slAgentScale').value)/100; Q('lbAgentScale').textContent=`${params.agentScale.toFixed(2)}√ó`;
  const collisionToggle = Q('chkAgentCollisions');
  if(collisionToggle){
    params.agentCollisions = collisionToggle.checked;
    const label = Q('lbAgentCollisions');
    if(label){
      label.textContent = collisionToggle.checked ? 'on' : 'off';
    }
  }

  const topHighlightToggle = Q('chkTopHighlight');
  if(topHighlightToggle){
    params.showTopHighlight = topHighlightToggle.checked;
    const label = Q('lbTopHighlight');
    if(label){
      label.textContent = topHighlightToggle.checked ? 'on' : 'off';
    }
  }

  const energyHaloToggle = Q('chkEnergyHalo');
  if(energyHaloToggle){
    params.showEnergyHalo = energyHaloToggle.checked;
    const label = Q('lbEnergyHalo');
    if(label){
      label.textContent = energyHaloToggle.checked ? 'on' : 'off';
    }
  }

  const energyEmptySlider = Q('slEnergyEmptySpeed');
  if(energyEmptySlider){
    const percent = Number(energyEmptySlider.value);
    const normalized = clamp(percent / 100, ENERGY_MULTIPLIER_MIN, ENERGY_MULTIPLIER_MAX);
    params.energyEmptySpeed = normalized;
    const label = Q('lbEnergyEmptySpeed');
    if(label){
      label.textContent = `${Math.round(percent)}%`;
    }
  }

  const energyCapacitySlider = Q('slEnergyCapacity');
  if(energyCapacitySlider){
    const capacity = clamp(Number(energyCapacitySlider.value), COLLECTOR_ENERGY_CAPACITY_MIN, COLLECTOR_ENERGY_CAPACITY_MAX);
    params.energyCapacity = capacity;
    const label = Q('lbEnergyCapacity');
    if(label){
      label.textContent = capacity <= 0 ? 'off' : `${Math.round(capacity)}`;
    }
    applyCollectorEnergyCapacity();
  }

  const awarenessSlider = Q('slAwarenessBoost');
  if(awarenessSlider){
    const percent = Number(awarenessSlider.value);
    const normalized = clamp(percent / 100, AWARENESS_BOOST_MIN, AWARENESS_BOOST_MAX);
    params.awarenessBoost = normalized;
    const label = Q('lbAwarenessBoost');
    if(label){
      label.textContent = `${Math.round(percent)}%`;
    }
  }

  const energyDeathToggle = Q('chkEnergyDeath');
  if(energyDeathToggle){
    params.dieOnEnergyLoss = energyDeathToggle.checked;
    const label = Q('lbEnergyDeath');
    if(label){
      label.textContent = energyDeathToggle.checked ? 'on' : 'off';
    }
  }

  const radarToggle = Q('chkSensorRadar');
  if(radarToggle){
    params.showSensorRadar = radarToggle.checked;
    const label = Q('lbSensorRadar');
    if(label){
      label.textContent = radarToggle.checked ? 'on' : 'off';
    }
  }

  params.learn.genSteps = +Q('slGenSteps').value; Q('lbGenSteps').textContent=params.learn.genSteps;
  const hiddenSlider = Q('slHidden');
  if(hiddenSlider){
    const desired = Math.round(Number(hiddenSlider.value));
    const clampedHidden = clamp(desired, NET_HIDDEN_MIN, NET_HIDDEN_MAX);
    params.learn.hidden = clampedHidden;
    const label = Q('lbHidden');
    if(label){
      label.textContent = `${clampedHidden} neuron${clampedHidden===1?'':'s'}`;
    }
    applyHiddenLayerSize(clampedHidden);
  }
  params.learn.mut = (+Q('slMut').value)/100; Q('lbMut').textContent=`${Math.round(params.learn.mut*100)}%`;
  params.learn.elite = (+Q('slElite').value)/100; Q('lbElite').textContent=`${Math.round(params.learn.elite*100)}%`;
  params.learn.mutStrengthW = (+Q('slMutStrengthW').value)/100; Q('lbMutStrengthW').textContent=params.learn.mutStrengthW.toFixed(2);
  params.learn.mutStrengthB = (+Q('slMutStrengthB').value)/100; Q('lbMutStrengthB').textContent=params.learn.mutStrengthB.toFixed(2);
  params.learn.crossoverBias = (+Q('slCrossover').value)/100; Q('lbCrossover').textContent = `${Math.round(params.learn.crossoverBias*100)}% A`;
  params.learn.tournamentFactor = (+Q('slTournament').value)/10; Q('lbTournament').textContent = `√ó${params.learn.tournamentFactor.toFixed(1)}`;
  params.learn.fresh = (+Q('slFresh').value)/100; Q('lbFresh').textContent = `${Math.round(params.learn.fresh*100)}%`;
  params.learn.auto = Q('chkAuto').checked; Q('lbAuto').textContent = params.learn.auto? 'on':'off';
  if(params.learn.auto && awaitingManualAdvance){
    forceNextGen = true;
  }
}
function getCurrentTrack(){
  if(!musicTracks.length) return null;
  return musicTracks[Math.min(Math.max(currentTrackIndex, 0), musicTracks.length - 1)] || null;
}

function updateMusicMeta(track, stateOverride=null){
  const state = stateOverride || (isMusicPlaying ? 'Playing' : 'Paused');
  Q('lbMusicState').textContent = state;
  if(track){
    Q('lbMusicNow').textContent = `${track.title} ‚Äî ${track.artist}`;
    Q('lbMusicSource').textContent = `File: Audio/${track.filename}`;
  } else {
    Q('lbMusicNow').textContent = 'No local audio files detected.';
    Q('lbMusicSource').textContent = 'Add MP3 files to the Audio folder to enable playback.';
  }
}

function updateMusicButton(){
  if(!musicToggleBtn) return;
  musicToggleBtn.textContent = isMusicPlaying ? 'Pause' : 'Play';
  musicToggleBtn.setAttribute('aria-pressed', isMusicPlaying ? 'true' : 'false');
}

function stopCurrentTrack(silent=false){
  if(audioElement){
    audioElement.pause();
  }
  isMusicPlaying = false;
  if(!silent){
    updateMusicMeta(getCurrentTrack(), 'Paused');
    updateMusicButton();
  }
}

async function playCurrentTrack(){
  const track = getCurrentTrack();
  if(!track){
    updateMusicMeta(null, 'No tracks');
    return;
  }
  try{    const audio = initAudioElement();
    stopCurrentTrack(true);

    // Set the audio source to the MP3 file in the audio folder
    audio.src = `Audio/${track.filename}`;
    audio.load();
    
    // Play the audio
    await audio.play();
    isMusicPlaying = true;
    
    updateMusicMeta(track, 'Playing');
    updateMusicButton();
  }catch(err){
    console.error('Playback error:', err);
    isMusicPlaying = false;
    updateMusicMeta(track, 'Error: ' + err.message);
    updateMusicButton();
    throw err;
  }
}

async function setMusicTrack(index, autoplay=false){
  if(!musicTracks.length) return;
  if(index<0 || index>=musicTracks.length) return;
  const track = musicTracks[index];
  const shouldAutoplay = autoplay || isMusicPlaying;
  currentTrackIndex = index;

  stopCurrentTrack(true);
  updateMusicButton();
  updateMusicMeta(track, 'Loading‚Ä¶');

  try{
    const audio = initAudioElement();
    audio.src = `Audio/${track.filename}`;
    
    if(shouldAutoplay){
      await playCurrentTrack();
    } else {
      isMusicPlaying = false;
      updateMusicMeta(track, 'Ready');
      updateMusicButton();
    }
  }catch(err){
    console.error('Track loading error:', err);
    updateMusicMeta(track, 'Error loading track');
  }
}

function initMusicPanel(){
  musicSelect = Q('selMusic');
  musicToggleBtn = Q('btnMusicToggle');
  const vol = Q('slMusicVolume');
  const volLabel = Q('lbMusicVolume');

  if(musicSelect){
    const loadingOption = document.createElement('option');
    loadingOption.value = '';
    loadingOption.textContent = 'Loading tracks‚Ä¶';
    musicSelect.appendChild(loadingOption);
    musicSelect.disabled = true;
  }
  if(musicToggleBtn){
    musicToggleBtn.disabled = true;
  }
  updateMusicMeta(null, 'Loading‚Ä¶');

  const populateSelect = (tracks)=>{
    if(!musicSelect) return;
    musicSelect.innerHTML = '';
    if(!tracks.length){
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'No MP3 files found';
      musicSelect.appendChild(placeholder);
      musicSelect.disabled = true;
      if(musicToggleBtn){
        musicToggleBtn.disabled = true;
      }
      updateMusicMeta(null, 'Unavailable');
      return;
    }

    tracks.forEach((track, idx)=>{
      const opt = document.createElement('option');
      opt.value = idx;
      opt.textContent = `${track.title} ‚Äî ${track.artist}`;
      musicSelect.appendChild(opt);
    });
    musicSelect.disabled = false;
    if(musicToggleBtn){
      musicToggleBtn.disabled = false;
    }
    musicSelect.value = String(Math.min(Math.max(currentTrackIndex, 0), tracks.length - 1));
  };

  const applyVolume = ()=>{
    const value = Math.round(vol.value);
    pendingVolume = value/100;
    if(audioElement){
      audioElement.volume = pendingVolume;
    }
    volLabel.textContent = `${value}%`;
  };
  applyVolume();
  vol.addEventListener('input', applyVolume);

  musicToggleBtn.addEventListener('click', async ()=>{
    if(isMusicPlaying){
      stopCurrentTrack();
    } else {
      musicToggleBtn.disabled = true;
      try{
        await playCurrentTrack();
      }catch(err){
        // handled in playCurrentTrack
      }finally{
        musicToggleBtn.disabled = false;
      }
    }
  });

  musicSelect.addEventListener('change', ()=>{
    if(!musicTracks.length) return;
    const idx = parseInt(musicSelect.value, 10);
    if(Number.isFinite(idx)){
      setMusicTrack(idx, isMusicPlaying);
    }
  });

  updateMusicButton();

  discoverAudioTracks().then((tracks)=>{
    musicTracks = tracks;
    currentTrackIndex = 0;
    populateSelect(tracks);
    if(tracks.length){
      updateMusicMeta(tracks[currentTrackIndex], 'Ready');
      setMusicTrack(currentTrackIndex, false);
    }
  }).catch((err)=>{
    console.error('Failed to load audio tracks:', err);
    populateSelect([]);
  });
}

// Procedural audio generation functions removed - now using MP3 files from audio folder

// ===== Data structures =====
const fruits=[], obstacles=[];
let activeTeamStates=[];
const goalStates = {};
const bestFitnessByTeam = {};
const teamScoreBook = new Map();
const teamScoreDisplays = new Map();
const teamBadgeDisplays = new Map();

function updateFruitPlacementUI(mode){
  const options = document.querySelectorAll('.fruit-placement-options input[name="fruitPlacement"]');
  options.forEach((input)=>{
    const isActive = input.value === mode;
    if(input.checked !== isActive){
      input.checked = isActive;
    }
    const optionLabel = input.closest('.fruit-placement-option');
    if(optionLabel){
      optionLabel.classList.toggle('active', isActive);
      optionLabel.setAttribute('data-selected', isActive ? 'true' : 'false');
      const readable = FRUIT_PLACEMENT_LABELS[input.value] || input.value;
      optionLabel.setAttribute('title', readable);
    }
  });
  const placementLabel = Q('fruitPlacementLabel');
  if(placementLabel){
    placementLabel.setAttribute('data-selected', FRUIT_PLACEMENT_LABELS[mode] || mode);
  }
}

function regenerateFruitField(){
  const target = Math.max(0, Math.floor(params.maxFruits || 0));
  fruits.length = 0;
  for(let i=0;i<target;i++){
    spawnFruit();
  }
  refreshStats();
}

function setFruitPlacement(mode, fromUser=false){
  const normalized = FRUIT_PLACEMENT_MODES.includes(mode) ? mode : 'random';
  if(params.fruitPlacement === normalized && !fromUser){
    updateFruitPlacementUI(normalized);
    return;
  }
  params.fruitPlacement = normalized;
  updateFruitPlacementUI(normalized);
  if(fromUser){
    regenerateFruitField();
  }
}

function initFruitPlacementControls(){
  const options = Array.from(document.querySelectorAll('.fruit-placement-options input[name="fruitPlacement"]'));
  if(!options.length) return;
  options.forEach((input)=>{
    input.addEventListener('change', ()=>{
      if(input.checked){
        setFruitPlacement(input.value, true);
      }else if(params.fruitPlacement === input.value){
        setFruitPlacement(params.fruitPlacement, false);
      }
    });
  });
  setFruitPlacement(params.fruitPlacement || 'random', false);
}

const PICKUP_REWARD = 8;
const DELIVERY_REWARD = 120;
const BLOCKER_BLOCK_REWARD = 60;
const BLOCKER_BLOCK_PENALTY = 40;
const BLOCKER_EVENT_COOLDOWN = 55;
const BLOCKER_TRIGGER_RADIUS_BASE = 18;
const BLOCKER_HOLD_FRAMES = 28;
const PATH_COST_OBSTACLE_PADDING = 10;
const PATH_SEGMENT_SAMPLE_STEP = 12;
const LINE_OF_SIGHT_PADDING = 8;
const PATH_PROGRESS_REWARD = 0.92;
const PATH_PROGRESS_CONSOLIDATION_BONUS = 0.45;
const PATH_CONSOLIDATION_TRAIL_THRESHOLD = 0.75;
const PATH_CONSOLIDATION_TRAIL_SCALE = 2.2;
const PATH_PROGRESS_STALL_PENALTY = 0.12;
const PATH_PROGRESS_REGRESSION_PENALTY = 0.18;
const PATH_PROGRESS_REGRESSION_DELTA = 0.08;
const PATH_PROGRESS_STALL_STEPS = 70;
const PATH_PROGRESS_MIN_DELTA = 0.05;
const PATH_STUCK_THRESHOLD = 90;
const PATH_STUCK_PENALTY = 0.25;
const PATH_EXPLORATION_REWARD = 0.5;
const PATH_EXPLORATION_LIMIT = 600;
const PATH_LOOP_WINDOW = 90;
const PATH_LOOP_PENALTY = 0.08;
const PATH_PROGRESS_PRESSURE_WINDOW = 220;
const FRUIT_APPROACH_REWARD = 0.22;
const FRUIT_APPROACH_BASELINE_SCALE = 220;
const FRUIT_APPROACH_MAX_MULTIPLIER = 2.8;
const FRUIT_APPROACH_MIN_DELTA = 0.4;
const PHEROMONE_DEPOSIT_BASE = 0.28;
const PHEROMONE_DEPOSIT_CARRY_BONUS = 1.5;
const PHEROMONE_DEPOSIT_HOME_SUPPORT = 0.18;
const PHEROMONE_FRESH_BURST = 1.8;
const PHEROMONE_FRESH_SPREAD = 0.65;
const PHEROMONE_SENSOR_SCALE = 2.4;
const PHEROMONE_FRESH_SENSOR_SCALE = 3.2;
const PHEROMONE_BASE_KEEP = 0.978;
const PHEROMONE_MAX_KEEP = 0.992;
const PHEROMONE_FRESH_KEEP = 0.952;
const PHEROMONE_FRESH_MAX_KEEP = 0.972;
const PHEROMONE_SPARSE_KEEP_BONUS = 0.012;
const PHEROMONE_DIFFUSE_CENTER = 0.52;
const PHEROMONE_DIFFUSE_NEIGHBOR = 0.08;
const PHEROMONE_FRESH_DIFFUSE_CENTER = 0.56;
const PHEROMONE_FRESH_DIFFUSE_NEIGHBOR = 0.05;
const RAYCAST_MAX_DISTANCE = 160;
const RAYCAST_STEP = 10;

function getTeamScoreData(teamId){
  if(!teamId) return { score:0, pickups:0, deliveries:0, blocks:0, fumbles:0 };
  let entry = teamScoreBook.get(teamId);
  if(!entry){
    entry = { score:0, pickups:0, deliveries:0, blocks:0, fumbles:0 };
    teamScoreBook.set(teamId, entry);
  }
  return entry;
}

function updateTeamScoreDisplay(teamId){
  const data = getTeamScoreData(teamId);
  const points = Math.round(data.score || 0);
  const team = params.teams.find((t)=> t.id === teamId);
  const badge = teamBadgeDisplays.get(teamId);
  if(badge){
    if(team?.role === 'blocker'){
      badge.textContent = `${data.blocks || 0}`;
    }else{
      badge.textContent = team?.icon || '‚óè';
    }
  }
  const el = teamScoreDisplays.get(teamId);
  if(!el) return;
  const metrics = [];
  metrics.push(`${data.pickups} caught`);
  metrics.push(`${data.deliveries} delivered`);
  metrics.push(`${data.blocks} blocked`);
  metrics.push(`${data.fumbles} fumbles`);
  el.textContent = `Points: ${points} (${metrics.join(' ¬∑ ')})`;
}

function awardTeamPoints(teamState, type, amount){
  if(!teamState || !teamState.config) return;
  const scoreboard = teamState.scoreboard || getTeamScoreData(teamState.config.id);
  if(!scoreboard) return;
  if(type === 'pickup') scoreboard.pickups++;
  if(type === 'delivery') scoreboard.deliveries++;
  if(type === 'block') scoreboard.blocks++;
  const numeric = Number(amount);
  if(Number.isFinite(numeric)) scoreboard.score += numeric;
  teamState.scoreboard = scoreboard;
  updateTeamScoreDisplay(teamState.config.id);
}

function registerTeamFumble(teamState, penalty=0){
  if(!teamState || !teamState.config) return;
  const scoreboard = teamState.scoreboard || getTeamScoreData(teamState.config.id);
  scoreboard.fumbles = (scoreboard.fumbles || 0) + 1;
  if(Number.isFinite(penalty) && penalty !== 0){
    scoreboard.score += penalty;
  }
  teamState.scoreboard = scoreboard;
  updateTeamScoreDisplay(teamState.config.id);
}

// Pheromone grid ‚Äì per-team fields
let grid, GW, GH, CS = 22; // cell size
let pathCostFields = {};
let pathCostDirty = true;
function makeGrid(){
  GW=Math.floor(W/CS);
  GH=Math.floor(H/CS);
  grid={};
  params.teams.forEach((team)=>{
    grid[team.id] = {
      food:new Float32Array(GW*GH),
      home:new Float32Array(GW*GH),
      fresh:new Float32Array(GW*GH)
    };
  });
  pathCostFields = {};
  markPathCostDirty();
}
const gi=(x,y)=> y*GW + x;
const clampi=(v,a,b)=> v<a?a:(v>b?b:v);
function deposit(teamId,type,x,y,amt,opts={}){
  const fields = grid?.[teamId];
  if(!fields) return;
  const field = fields[type];
  if(!field) return;
  const amount = Number(amt);
  if(!Number.isFinite(amount) || amount === 0) return;
  const cx=clampi((x/CS)|0,0,GW-1), cy=clampi((y/CS)|0,0,GH-1);
  const idx = gi(cx,cy);
  const cap = Number.isFinite(opts.cap) ? opts.cap : null;
  const apply = (index, delta)=>{
    if(!Number.isFinite(index) || index<0 || index>=field.length) return;
    let next = field[index] + delta;
    if(cap != null){
      next = Math.min(next, cap);
    }
    field[index] = next;
  };
  apply(idx, amount);
  const spread = Math.max(0, Number(opts.spread)||0);
  const radius = Math.max(0, Math.round(Number.isFinite(opts.radius)?opts.radius:1));
  if(spread>0 && radius>0){
    const neighbors=[];
    for(let dy=-radius; dy<=radius; dy++){
      for(let dx=-radius; dx<=radius; dx++){
        if(dx===0 && dy===0) continue;
        const nx = clampi(cx+dx,0,GW-1);
        const ny = clampi(cy+dy,0,GH-1);
        const dist = Math.hypot(dx,dy);
        if(dist>radius) continue;
        const weight = dist>0 ? 1/dist : 0;
        neighbors.push({ index:gi(nx,ny), weight });
      }
    }
    const weightSum = neighbors.reduce((sum,n)=>sum + (Number.isFinite(n.weight)?n.weight:0),0);
    if(weightSum>0){
      const spreadTotal = amount * spread;
      for(const neighbor of neighbors){
        if(!Number.isFinite(neighbor.weight) || neighbor.weight<=0) continue;
        const share = spreadTotal * (neighbor.weight/weightSum);
        apply(neighbor.index, share);
      }
    }
  }
}
function senseGrad(teamId,type,x,y){
  const fields = grid?.[teamId];
  if(!fields) return { gx:0, gy:0, val:0 };
  const field = fields[type];
  if(!field) return { gx:0, gy:0, val:0 };
  const cx=clampi((x/CS)|0,0,GW-1), cy=clampi((y/CS)|0,0,GH-1);
  let best=-1e9,bx=cx,by=cy;
  for(let dy=-1;dy<=1;dy++){
    for(let dx=-1;dx<=1;dx++){
      const nx=clampi(cx+dx,0,GW-1), ny=clampi(cy+dy,0,GH-1);
      const v=field[gi(nx,ny)];
      if(v>best){best=v; bx=nx; by=ny;}
    }
  }
  return {gx:(bx-cx), gy:(by-cy), val:field[gi(bx,by)]};
}
function normalizePheromoneStrength(val, scale=PHEROMONE_SENSOR_SCALE){
  if(!Number.isFinite(val) || val<=0) return 0;
  const denom = Math.max(scale, 1e-6);
  return clamp(val / denom, 0, 1);
}
function leaveCollectorTrail(agent){
  if(!agent || !grid) return;
  const teamId = agent.team;
  if(!teamId) return;
  const energyRatio = agent.getEnergyRatio ? agent.getEnergyRatio() : 1;
  const energyScale = agent.energyMax > 0 ? clamp(0.7 + 0.6 * energyRatio, 0.35, 1.35) : 1;
  const base = PHEROMONE_DEPOSIT_BASE * energyScale;
  const carrying = !!agent.carry;
  const primaryType = carrying ? 'food' : 'home';
  const primaryAmount = base * (carrying ? PHEROMONE_DEPOSIT_CARRY_BONUS : 1);
  const primarySpread = carrying ? 0.45 : 0.32;
  deposit(teamId, primaryType, agent.x, agent.y, primaryAmount, {
    spread:primarySpread,
    radius:1,
    cap:carrying ? 14 : 10
  });
  const supportAmount = base * PHEROMONE_DEPOSIT_HOME_SUPPORT;
  if(supportAmount>0){
    const supportType = carrying ? 'home' : 'food';
    deposit(teamId, supportType, agent.x, agent.y, supportAmount, {
      spread:0.22,
      radius:1,
      cap:8
    });
  }
}
function markFreshFruitTrail(teamId,x,y){
  if(!grid || !teamId) return;
  deposit(teamId, 'fresh', x, y, PHEROMONE_FRESH_BURST, {
    spread:PHEROMONE_FRESH_SPREAD,
    radius:1,
    cap:12
  });
  deposit(teamId, 'food', x, y, PHEROMONE_FRESH_BURST * 0.35, {
    spread:0.5,
    radius:1,
    cap:14
  });
}
function computeCarrierStats(){
  const stats = {};
  if(!Array.isArray(activeTeamStates)) return stats;
  for(const teamState of activeTeamStates){
    if(!teamState || !teamState.config) continue;
    let carriers = 0;
    let total = 0;
    for(const agent of teamState.agents){
      if(!agent || agent.dead) continue;
      total++;
      if(agent.carry) carriers++;
    }
    const ratio = total>0 ? carriers/total : 0;
    stats[teamState.config.id] = { carriers, total, ratio };
  }
  return stats;
}
function evaporate(){
  if(!grid) return;
  const carrierStats = computeCarrierStats();
  const next={};
  for(const [teamId, fields] of Object.entries(grid)){
    const dest={ food:new Float32Array(GW*GH), home:new Float32Array(GW*GH), fresh:new Float32Array(GW*GH) };
    const teamStats = carrierStats[teamId] || { ratio:0 };
    for(const key of ['food','home','fresh']){
      const src=fields[key];
      const dst=dest[key];
      for(let y=0;y<GH;y++){
        for(let x=0;x<GW;x++){
          const idx = gi(x,y);
          const base = src[idx];
          let keep;
          if(key==='fresh'){
            keep = clamp(PHEROMONE_FRESH_KEEP + (1 - clamp(teamStats.ratio,0,1)) * PHEROMONE_SPARSE_KEEP_BONUS, PHEROMONE_FRESH_KEEP, PHEROMONE_FRESH_MAX_KEEP);
          } else {
            keep = clamp(PHEROMONE_BASE_KEEP + (1 - clamp(teamStats.ratio,0,1)) * PHEROMONE_SPARSE_KEEP_BONUS, PHEROMONE_BASE_KEEP, PHEROMONE_MAX_KEEP);
          }
          let v=base*keep;
          const centerWeight = key==='fresh' ? PHEROMONE_FRESH_DIFFUSE_CENTER : PHEROMONE_DIFFUSE_CENTER;
          const neighborWeight = key==='fresh' ? PHEROMONE_FRESH_DIFFUSE_NEIGHBOR : PHEROMONE_DIFFUSE_NEIGHBOR;
          let sum=v*centerWeight;
          let cnt=0;
          for(let dy=-1;dy<=1;dy++){
            for(let dx=-1;dx<=1;dx++){
              if(dx||dy){
                const nx=clampi(x+dx,0,GW-1), ny=clampi(y+dy,0,GH-1);
                sum += src[gi(nx,ny)]*neighborWeight;
                cnt+=1;
              }
            }
          }
          const divisor = centerWeight + neighborWeight*cnt;
          dst[idx]= divisor>0 ? (sum/divisor) : v;
        }
      }
    }
    next[teamId]=dest;
  }
  grid=next;
}

function markPathCostDirty(){
  pathCostDirty = true;
}

function pointInsideObstacleWithPadding(x, y, padding=0){
  for(const o of obstacles){
    if(isPointInsideObstacle(o, x, y, padding)) return true;
  }
  return false;
}

function segmentIntersectsObstacle(ax, ay, bx, by, padding=LINE_OF_SIGHT_PADDING){
  const dx = bx - ax;
  const dy = by - ay;
  const dist = Math.hypot(dx, dy);
  if(dist === 0) return pointInsideObstacleWithPadding(ax, ay, padding);
  const steps = Math.max(2, Math.ceil(dist / Math.max(4, PATH_SEGMENT_SAMPLE_STEP)));
  for(let i=1;i<steps;i++){
    const t = i/steps;
    const px = ax + dx * t;
    const py = ay + dy * t;
    if(pointInsideObstacleWithPadding(px, py, padding)) return true;
  }
  return false;
}

function hasLineOfSight(ax, ay, bx, by, padding=LINE_OF_SIGHT_PADDING){
  return !segmentIntersectsObstacle(ax, ay, bx, by, padding);
}

function isCellNavigable(cx, cy){
  if(cx<0 || cy<0 || cx>=GW || cy>=GH) return false;
  const px = (cx + 0.5) * CS;
  const py = (cy + 0.5) * CS;
  if(pointInsideObstacleWithPadding(px, py, PATH_COST_OBSTACLE_PADDING)) return false;
  return true;
}

function gatherGoalSeedCells(goal){
  const seeds=[];
  if(!goal) return seeds;
  const radius = goal.r + CS;
  const minX = clampi(Math.floor((goal.x - radius)/CS), 0, GW-1);
  const maxX = clampi(Math.ceil((goal.x + radius)/CS), 0, GW-1);
  const minY = clampi(Math.floor((goal.y - radius)/CS), 0, GH-1);
  const maxY = clampi(Math.ceil((goal.y + radius)/CS), 0, GH-1);
  for(let cy=minY; cy<=maxY; cy++){
    for(let cx=minX; cx<=maxX; cx++){
      const dx = (cx + 0.5)*CS - goal.x;
      const dy = (cy + 0.5)*CS - goal.y;
      if(Math.hypot(dx, dy) <= radius && isCellNavigable(cx, cy)){
        seeds.push({ cx, cy });
      }
    }
  }
  if(seeds.length > 0) return seeds;
  const centerCx = clampi((goal.x/CS)|0, 0, GW-1);
  const centerCy = clampi((goal.y/CS)|0, 0, GH-1);
  const maxRadius = Math.max(GW, GH);
  for(let ring=1; ring<=maxRadius; ring++){
    for(let dy=-ring; dy<=ring; dy++){
      const edgeY = centerCy + dy;
      const edgeX1 = centerCx + ring;
      const edgeX2 = centerCx - ring;
      if(isCellNavigable(edgeX1, edgeY)) seeds.push({ cx:edgeX1, cy:edgeY });
      if(isCellNavigable(edgeX2, edgeY)) seeds.push({ cx:edgeX2, cy:edgeY });
    }
    for(let dx=-ring+1; dx<=ring-1; dx++){
      const edgeX = centerCx + dx;
      const edgeY1 = centerCy + ring;
      const edgeY2 = centerCy - ring;
      if(isCellNavigable(edgeX, edgeY1)) seeds.push({ cx:edgeX, cy:edgeY1 });
      if(isCellNavigable(edgeX, edgeY2)) seeds.push({ cx:edgeX, cy:edgeY2 });
    }
    if(seeds.length > 0) break;
  }
  return seeds;
}

function recomputePathCostFields(){
  if(!Number.isFinite(GW) || !Number.isFinite(GH) || GW<=0 || GH<=0) return;
  const neighborOffsets = [
    { dx:1, dy:0 },
    { dx:-1, dy:0 },
    { dx:0, dy:1 },
    { dx:0, dy:-1 }
  ];
  const queueSize = GW*GH;
  const queueX = new Int16Array(queueSize);
  const queueY = new Int16Array(queueSize);
  const nextFields = {};
  for(const team of params.teams){
    if(!team || !team.id) continue;
    const goal = ensureGoalState(team.id);
    const costs = new Float32Array(GW*GH);
    costs.fill(Infinity);
    const seeds = gatherGoalSeedCells(goal);
    let head=0, tail=0;
    for(const seed of seeds){
      const idx = gi(seed.cx, seed.cy);
      costs[idx] = 0;
      queueX[tail] = seed.cx;
      queueY[tail] = seed.cy;
      tail++;
    }
    while(head < tail){
      const cx = queueX[head];
      const cy = queueY[head];
      head++;
      const baseIdx = gi(cx, cy);
      const baseCost = costs[baseIdx];
      for(const offset of neighborOffsets){
        const nx = cx + offset.dx;
        const ny = cy + offset.dy;
        if(!isCellNavigable(nx, ny)) continue;
        const fromX = (cx + 0.5) * CS;
        const fromY = (cy + 0.5) * CS;
        const toX = (nx + 0.5) * CS;
        const toY = (ny + 0.5) * CS;
        if(segmentIntersectsObstacle(fromX, fromY, toX, toY, PATH_COST_OBSTACLE_PADDING)) continue;
        const nIdx = gi(nx, ny);
        const newCost = baseCost + 1;
        if(newCost < costs[nIdx]){
          costs[nIdx] = newCost;
          queueX[tail] = nx;
          queueY[tail] = ny;
          tail++;
        }
      }
    }
    nextFields[team.id] = costs;
  }
  pathCostFields = nextFields;
}

function updatePathCostsIfNeeded(){
  if(!pathCostDirty) return;
  pathCostDirty = false;
  recomputePathCostFields();
}

function getPathCostAt(teamId, x, y){
  if(!pathCostFields || !grid) return Infinity;
  const field = pathCostFields[teamId];
  if(!field) return Infinity;
  if(!Number.isFinite(GW) || !Number.isFinite(GH) || GW<=0 || GH<=0) return Infinity;
  const cx = clampi((x/CS)|0, 0, GW-1);
  const cy = clampi((y/CS)|0, 0, GH-1);
  const cost = field[gi(cx, cy)];
  return Number.isFinite(cost) ? cost : Infinity;
}

// Goals ‚Äì draggable, one per potential team
const GOAL_RADIUS = 34;
const GOAL_EDGE_MARGIN = 12;
function ensureGoalState(teamId){
  let goal = goalStates[teamId];
  if(!goal){
    const preset = TEAM_PRESET_MAP.get(teamId);
    const anchor = preset?.goalAnchor || { x:0.5, y:0.5 };
    goal = { id:teamId, x: anchor.x * W, y: anchor.y * H, r:GOAL_RADIUS, delivered:0 };
    goalStates[teamId] = goal;
  }
  clampGoalPosition(goal);
  return goal;
}
function resetGoalDelivery(teamId){
  const goal = ensureGoalState(teamId);
  goal.delivered = 0;
  return goal;
}
function getAllGoalStates(){
  return params.teams.map((team)=> ensureGoalState(team.id));
}
let dragTarget=null, dragDX=0, dragDY=0, dragKind=null, dragIndex=-1;

function renderTeamRoster(){
  const roster = Q('teamRoster');
  if(!roster) return;
  roster.innerHTML='';
  teamScoreDisplays.clear();
  teamBadgeDisplays.clear();
  params.teams.forEach((team)=>{
    const card=document.createElement('div');
    card.className='team-card';
    if(team.active) card.classList.add('active');
    card.dataset.teamId=team.id;

    const checkbox=document.createElement('input');
    checkbox.type='checkbox';
    checkbox.checked=!!team.active;
    checkbox.setAttribute('aria-label', `${team.label} team active`);

    const header=document.createElement('div');
    header.className='team-header';
    const badge=document.createElement('span');
    badge.className='team-badge';
    badge.textContent=team.icon || '‚óè';
    if(team.role === 'blocker'){
      badge.style.background='transparent';
      badge.style.color=team.color || '#a855f7';
      badge.style.boxShadow='none';
    }else if(team.badge){
      badge.style.background=team.badge;
      badge.style.color='#020617';
    }else{
      badge.style.background=team.color;
      badge.style.color='#fff';
    }
    teamBadgeDisplays.set(team.id, badge);
    const name=document.createElement('span');
    name.className='team-name';
    name.textContent=team.label;
    header.append(badge,name);

    const meta=document.createElement('div');
    meta.className='team-meta';
    const roleLabel = team.role === 'blocker' ? 'Blocker' : 'Collector';
    meta.textContent = `${team.active? 'Active':'Inactive'} ¬∑ ${roleLabel}`;

    const score=document.createElement('div');
    score.className='team-score';
    score.textContent='Points: 0';
    teamScoreDisplays.set(team.id, score);
    updateTeamScoreDisplay(team.id);

    checkbox.addEventListener('change', ()=>{
      team.active = checkbox.checked;
      meta.textContent = `${team.active ? 'Active' : 'Inactive'} ¬∑ ${roleLabel}`;
      card.classList.toggle('active', team.active);
      refreshBrainTeamOptions();
      renderTeamControls();
      setup();
    });

    card.append(checkbox, header, meta, score);
    roster.append(card);
  });
  refreshBrainTeamOptions();
  renderTeamControls();
}

function renderTeamControls(){
  const container = Q('teamConfigs');
  if(!container) return;
  container.innerHTML='';
  teamControlRefs.clear();
  params.teams.forEach((team)=>{
    const card = document.createElement('div');
    card.className='team-config-card';
    if(!team.active) card.classList.add('inactive');

    const header = document.createElement('div');
    header.className='team-config-header';

    const title = document.createElement('div');
    title.className='team-config-title';
    const badge = document.createElement('span');
    badge.className='team-config-badge';
    badge.textContent = team.icon || '‚óè';
    if(team.role === 'blocker'){
      badge.style.background = 'transparent';
      badge.style.color = team.color || '#a855f7';
      badge.style.boxShadow = 'none';
    }else if(team.badge){
      badge.style.background = team.badge;
      badge.style.color = '#020617';
    }else{
      badge.style.background = team.color;
      badge.style.color = '#fff';
    }
    const name = document.createElement('span');
    name.textContent = team.label;
    title.append(badge, name);

    const status = document.createElement('div');
    status.className='team-config-status';
    status.textContent = team.active ? 'Active' : 'Inactive';

    header.append(title, status);
    card.append(header);

    const grid = document.createElement('div');
    grid.className='team-config-grid';
    const sliderRefs = {};

    const makeSlider = (labelText, key, options)=>{
      const label = document.createElement('div');
      label.className='label';
      label.textContent = labelText;

      const input = document.createElement('input');
      input.type='range';
      input.min = options.min;
      input.max = options.max;
      if(options.step != null) input.step = options.step;
      const sliderValue = options.toSlider ? options.toSlider(team[key]) : team[key];
      const clampedValue = Math.min(options.max, Math.max(options.min, sliderValue));
      input.value = String(clampedValue);
      if(clampedValue !== sliderValue){
        const coerced = options.fromSlider ? options.fromSlider(clampedValue) : clampedValue;
        team[key] = coerced;
      }

      const valueEl = document.createElement('div');
      valueEl.className='val';
      valueEl.textContent = options.format(team[key]);

      if(options.tooltip){
        label.title = options.tooltip;
        input.title = options.tooltip;
        valueEl.title = options.tooltip;
      }

      input.addEventListener('input', ()=>{
        const numeric = options.fromSlider ? options.fromSlider(+input.value) : +input.value;
        team[key] = numeric;
        valueEl.textContent = options.format(numeric);
        if(typeof options.onChange === 'function') options.onChange(numeric);
      });

      grid.append(label, input, valueEl);
      sliderRefs[key] = {
        input,
        valueEl,
        toSlider: options.toSlider,
        fromSlider: options.fromSlider,
        format: options.format
      };
    };

    makeSlider('Count', 'count', {
      min:2,
      max:200,
      format:(v)=> Math.round(v),
      onChange:()=> resizePop(),
      tooltip:'How many agents this team spawns onto the field.'
    });
    makeSlider('Speed', 'speed', {
      min:10,
      max:600,
      step:5,
      toSlider:(v)=> Math.round(v*100),
      fromSlider:(v)=> (v/100),
      format:(v)=> v.toFixed(2),
      tooltip:'Base movement speed multiplier applied to the team.'
    });
    makeSlider('Awareness', 'smart', {
      min:0,
      max:300,
      toSlider:(v)=> Math.round(v*100),
      fromSlider:(v)=> (v/100),
      format:(v)=> v.toFixed(2),
      tooltip:'How far agents sense fruit, teammates, and obstacles.'
    });
    makeSlider('Strategy', 'strat', {
      min:0,
      max:300,
      toSlider:(v)=> Math.round(v*100),
      fromSlider:(v)=> (v/100),
      format:(v)=> v.toFixed(2),
      tooltip:'Balance between chasing goals and wandering for this team.'
    });
    makeSlider('Separation', 'sep', {
      min:0,
      max:300,
      toSlider:(v)=> Math.round(v*100),
      fromSlider:(v)=> (v/100),
      format:(v)=> v.toFixed(2),
      tooltip:'How strongly agents steer away from crowding teammates.'
    });

    card.append(grid);
    container.append(card);
    teamControlRefs.set(team.id, sliderRefs);
  });
}

function applyPreset(name){
  const presetKey = NAV_PRESETS[name] ? name : 'lab';
  const preset = NAV_PRESETS[presetKey];
  if(!preset) return;

  if(navPresetSelect && navPresetSelect.value !== presetKey){
    navPresetSelect.value = presetKey;
  }
  if(navPresetLabel){
    navPresetLabel.textContent = preset.name || presetKey;
  }

  const navConfig = preset.nav || {};
  if(Number.isFinite(navConfig.obstacleThreshold)) NAV.obstacleThreshold = navConfig.obstacleThreshold;
  if(Number.isFinite(navConfig.boundaryPadding)) NAV.boundaryPadding = navConfig.boundaryPadding;
  if(Number.isFinite(navConfig.avoidPushGain)) NAV.avoidPushGain = navConfig.avoidPushGain;
  if(Number.isFinite(navConfig.safeNavReward)) NAV.safeNavReward = navConfig.safeNavReward;

  const ui = preset.ui || {};
  if(ui.awarenessBoostPct != null) setRangeValue('slAwarenessBoost', ui.awarenessBoostPct);
  if(ui.agentScalePct != null) setRangeValue('slAgentScale', ui.agentScalePct);
  if(ui.energyEmptyPct != null) setRangeValue('slEnergyEmptySpeed', ui.energyEmptyPct);
  if(ui.energyCapacity != null) setRangeValue('slEnergyCapacity', ui.energyCapacity);
  if(ui.agentCollisions !== undefined) setToggleValue('chkAgentCollisions', ui.agentCollisions);

  const teamSettings = ui.team || {};
  if(teamSettings && typeof teamSettings === 'object'){
    const activeTeams = params.teams.filter((team)=> team.active);
    activeTeams.forEach((team)=>{
      ['speed','smart','strat','sep'].forEach((key)=>{
        if(teamSettings[key] == null) return;
        const value = teamSettings[key];
        team[key] = value;
        const refs = teamControlRefs.get(team.id);
        if(refs && refs[key] && refs[key].input){
          const ref = refs[key];
          const sliderValue = typeof ref.toSlider === 'function' ? ref.toSlider(value) : value;
          if(String(ref.input.value) !== String(sliderValue)){
            ref.input.value = String(sliderValue);
          }
          ref.input.dispatchEvent(new Event('input', { bubbles:true }));
        }
      });
    });
  }

  if(preset.obstacleGenerator === 'labyrinth'){
    generateLabyrinthObstacles();
    setRangeValue('slObst', 0);
  }

  const learn = ui.learn || {};
  if(learn.steps != null) setRangeValue('slGenSteps', learn.steps);
  if(learn.hidden != null) setRangeValue('slHidden', learn.hidden);
  if(learn.mutPct != null) setRangeValue('slMut', learn.mutPct);
  if(learn.elitePct != null) setRangeValue('slElite', learn.elitePct);

  try{
    if(typeof localStorage !== 'undefined' && localStorage){
      localStorage.setItem('navPreset', presetKey);
    }
  }catch(err){
    console.warn('Unable to save nav preset preference', err);
  }

  readParams();
}

function refreshStats(){
  if(performanceModeActive) return;
  let deliveries = 0;
  let topFitness = 0;
  for(const team of activeTeamStates){
    deliveries += team.goal?.delivered || 0;
    topFitness = Math.max(topFitness, team.peakFitness||0, team.bestFitnessCurrent||0);
  }
  const nextValues = {
    gen: String(evo.gen),
    teams: String(activeTeamStates.length),
    fruits: String(fruits.length),
    deliveries: String(deliveries),
    steps: `${simSteps} / ${params.learn.genSteps}`,
    top: String(Math.round(topFitness))
  };
  for(const key of Object.keys(statElements)){
    const el = statElements[key];
    if(!el || !(key in nextValues)) continue;
    const value = nextValues[key];
    if(statCache[key] === value) continue;
    statCache[key] = value;
    el.textContent = value;
  }
}

function getCanvasCoords(evt){
  if(!canvas) return { x:0, y:0 };
  const now = getNow();
  if(!canvasBounds || (now - canvasBoundsTimestamp) > CANVAS_BOUNDS_MAX_AGE){
    updateCanvasBounds();
  }
  const rect = canvasBounds || canvas.getBoundingClientRect();
  let clientX = evt?.clientX;
  let clientY = evt?.clientY;
  if((clientX === undefined || clientY === undefined) && evt?.touches?.length){
    clientX = evt.touches[0].clientX;
    clientY = evt.touches[0].clientY;
  } else if((clientX === undefined || clientY === undefined) && evt?.changedTouches?.length){
    clientX = evt.changedTouches[0].clientX;
    clientY = evt.changedTouches[0].clientY;
  }
  if(clientX === undefined || clientY === undefined){
    clientX = rect.left;
    clientY = rect.top;
  }
  return {
    x: clientX - rect.left,
    y: clientY - rect.top
  };
}

function obstacleHitTest(o, px, py, tolerance=8){
  switch(o.type){
    case 'rect':{
      const halfW = o.width/2 + tolerance;
      const halfH = o.height/2 + tolerance;
      return Math.abs(px - o.x) <= halfW && Math.abs(py - o.y) <= halfH;
    }
    case 'line':{
      const t = distanceToSegment(px, py, o.x1, o.y1, o.x2, o.y2);
      const radius = (o.thickness||12)/2 + tolerance;
      return t.distance <= radius;
    }
    case 'half':{
      const dx = px - o.x;
      const dy = py - o.y;
      const radius = o.r + tolerance;
      const dist = Math.hypot(dx, dy);
      if(dist > radius) return false;
      const facingX = Math.cos(o.angle);
      const facingY = Math.sin(o.angle);
      const proj = dx*facingX + dy*facingY;
      if(proj >= -tolerance) return true;
      const perpX = -facingY;
      const perpY = facingX;
      const ax = o.x - perpX * o.r;
      const ay = o.y - perpY * o.r;
      const bx = o.x + perpX * o.r;
      const by = o.y + perpY * o.r;
      const seg = distanceToSegment(px, py, ax, ay, bx, by);
      return seg.distance <= tolerance;
    }
    default:{
      const r = typeof o.r === 'number' ? o.r : Math.max(16, (o.hitRadius||20));
      return Math.hypot(px - o.x, py - o.y) <= r + tolerance;
    }
  }
}

function getObstacleRadius(o){
  switch(o.type){
    case 'rect':
      return Math.hypot(o.width, o.height) * 0.5;
    case 'line':{
      const halfLen = Math.hypot(o.x2 - o.x1, o.y2 - o.y1) * 0.5;
      return halfLen + (o.thickness||12)/2;
    }
    case 'half':
      return o.r;
    default:
      return o.r || 24;
  }
}

function getObstacleExtents(o){
  switch(o.type){
    case 'rect':
      return { hx:o.width/2, hy:o.height/2 };
    case 'line':{
      const halfWidth = (o.thickness||12)/2;
      const halfDx = Math.abs(o.x2 - o.x1)/2;
      const halfDy = Math.abs(o.y2 - o.y1)/2;
      return { hx:halfDx + halfWidth, hy:halfDy + halfWidth };
    }
    case 'half':
      return { hx:o.r, hy:o.r };
    default:
      const r = o.r || 20;
      return { hx:r, hy:r };
  }
}

function moveObstacleTo(o, nx, ny){
  const dx = nx - o.x;
  const dy = ny - o.y;
  o.x = nx;
  o.y = ny;
  if(o.type === 'line'){
    o.x1 += dx; o.y1 += dy;
    o.x2 += dx; o.y2 += dy;
  }
  markPathCostDirty();
}

function computeObstacleDragOffset(o, pointerX, pointerY){
  if(!o) return { dx:0, dy:0 };
  switch(o.type){
    case 'circle':
    case 'half':
      return { dx:0, dy:0 };
    default:
      return { dx:o.x - pointerX, dy:o.y - pointerY };
  }
}

function distanceToSegment(px, py, x1, y1, x2, y2){
  const vx = x2 - x1;
  const vy = y2 - y1;
  const lenSq = vx*vx + vy*vy;
  let t = 0;
  if(lenSq > 0){
    t = ((px - x1)*vx + (py - y1)*vy) / lenSq;
    t = Math.max(0, Math.min(1, t));
  }
  const cx = x1 + vx*t;
  const cy = y1 + vy*t;
  const dx = px - cx;
  const dy = py - cy;
  const dist = Math.hypot(dx, dy);
  const inv = dist>0 ? 1/dist : 0;
  return { distance:dist, cx, cy, nx:dx*inv, ny:dy*inv };
}

function clampObstacleCenter(o, cx, cy){
  const ext = getObstacleExtents(o);
  const hx = ext.hx || 0;
  const hy = ext.hy || 0;
  const minX = hx + 4;
  const maxX = W - hx - 4;
  const minY = hy + 4;
  const maxY = H - hy - 4;
  return {
    x: Math.max(minX, Math.min(maxX, cx)),
    y: Math.max(minY, Math.min(maxY, cy))
  };
}

function clampGoalPosition(goal){
  if(!goal) return goal;
  const margin = Math.max(goal.r + GOAL_EDGE_MARGIN, goal.r + 8);
  goal.x = clamp(goal.x, margin, W - margin);
  goal.y = clamp(goal.y, margin, H - margin);
  return goal;
}

function keepObstacleInside(o){
  const clamped = clampObstacleCenter(o, o.x, o.y);
  moveObstacleTo(o, clamped.x, clamped.y);
}

function buildObstacleFromState(state, preview=false){
  if(!state) return null;
  const { tool, startX, startY, currentX, currentY } = state;
  const dx = currentX - startX;
  const dy = currentY - startY;
  switch(tool){
    case TOOL_CIRCLE:{
      const radius = Math.hypot(dx, dy);
      if(!preview && radius < 12) return null;
      if(preview && radius < 2) return null;
      return { type:'circle', x:startX, y:startY, r: Math.max(radius, preview?radius:12) };
    }
    case TOOL_RECT:{
      const width = Math.abs(dx);
      const height = Math.abs(dy);
      if(!preview && (width < 16 || height < 16)) return null;
      if(preview && (width < 2 && height < 2)) return null;
      const cx = (startX + currentX) / 2;
      const cy = (startY + currentY) / 2;
      return { type:'rect', x:cx, y:cy, width: Math.max(width, preview?width:16), height: Math.max(height, preview?height:16) };
    }
    case TOOL_LINE:{
      const length = Math.hypot(dx, dy);
      if(!preview && length < 24) return null;
      if(preview && length < 4) return null;
      const cx = (startX + currentX) / 2;
      const cy = (startY + currentY) / 2;
      return {
        type:'line',
        x:cx,
        y:cy,
        x1:startX,
        y1:startY,
        x2:currentX,
        y2:currentY,
        thickness:14
      };
    }
    case TOOL_HALF:{
      const radius = Math.hypot(dx, dy);
      if(!preview && radius < 18) return null;
      if(preview && radius < 4) return null;
      const angle = Math.atan2(dy, dx);
      return { type:'half', x:startX, y:startY, r: Math.max(radius, preview?radius:18), angle };
    }
    default:
      return null;
  }
}

function createCircleObstacle(x, y, r, paletteIndex=0, manual=false){
  return { type:'circle', x, y, r, paletteIndex, phase:Math.random()*Math.PI*2, manual };
}

function createLineObstacle(x1, y1, x2, y2, thickness=14, paletteIndex=0, manual=false, options={}){
  const persistent = !!options.persistent;
  const cx = (x1 + x2) / 2;
  const cy = (y1 + y2) / 2;
  return {
    type:'line',
    x:cx,
    y:cy,
    x1,
    y1,
    x2,
    y2,
    thickness,
    paletteIndex,
    phase:Math.random()*Math.PI*2,
    manual,
    persistent
  };
}

function getManualObstacleCount(){
  let count = 0;
  for(const obstacle of obstacles){
    if(obstacle.manual) count++;
  }
  return count;
}

function syncManualObstacleState(){
  const manualCount = getManualObstacleCount();
  manualPaletteCursor = manualCount % OBSTACLE_COLORS.length;
  if(btnUndoManual){
    btnUndoManual.disabled = manualCount === 0;
  }
}

canvas.addEventListener('pointerdown', (e)=>{
  if(!e.isPrimary) return;
  if(e.pointerType !== 'touch' && e.button !== 0) return;
  activePointerId = e.pointerId;
  if(typeof canvas.setPointerCapture === 'function'){
    canvas.setPointerCapture(e.pointerId);
  }
  const {x, y} = getCanvasCoords(e);
  if(currentTool !== TOOL_SELECT){
    drawingState = { tool:currentTool, startX:x, startY:y, currentX:x, currentY:y };
    e.preventDefault();
    return;
  }
  dragTarget=null; dragKind=null; dragIndex=-1; dragRadius=0;
  for(let i=obstacles.length-1; i>=0; i--){
    const o=obstacles[i];
    if(obstacleHitTest(o, x, y)){
      const offset = computeObstacleDragOffset(o, x, y);
      dragTarget = o;
      dragKind = 'obst';
      dragIndex = i;
      dragDX = offset.dx;
      dragDY = offset.dy;
      dragRadius = getObstacleRadius(o);
      e.preventDefault();
      return;
    }
  }
  for(const goal of getAllGoalStates()){
    if(Math.hypot(x-goal.x,y-goal.y) <= goal.r+12){
      dragTarget=goal;
      dragKind=`goal:${goal.id}`;
      dragDX=goal.x-x;
      dragDY=goal.y-y;
      e.preventDefault();
      return;
    }
  }
});

window.addEventListener('pointermove', (e)=>{
  if(activePointerId !== null && e.pointerId !== activePointerId) return;
  const {x, y} = getCanvasCoords(e);
  if(drawingState){
    drawingState.currentX = x;
    drawingState.currentY = y;
  }
  if(!dragTarget) return;
  if(dragKind==='obst'){
    const desiredX = x + dragDX;
    const desiredY = y + dragDY;
    const clamped = clampObstacleCenter(dragTarget, desiredX, desiredY);
    if(!obstacleOverlaps(clamped.x, clamped.y, dragRadius, dragIndex)){
      moveObstacleTo(dragTarget, clamped.x, clamped.y);
    }
  } else {
    const nx = Math.max(dragTarget.r+8, Math.min(W - dragTarget.r - 8, x + dragDX));
    const ny = Math.max(dragTarget.r+8, Math.min(H - dragTarget.r - 8, y + dragDY));
    dragTarget.x = nx;
    dragTarget.y = ny;
    markPathCostDirty();
  }
});

function endPointerInteraction(e){
  if(activePointerId !== null && e?.pointerId !== undefined && e.pointerId !== activePointerId){
    return;
  }
  if(drawingState){
    const created = buildObstacleFromState(drawingState);
    if(created){
      const paletteIndex = manualPaletteCursor % OBSTACLE_COLORS.length;
      created.manual = true;
      created.paletteIndex = paletteIndex;
      created.phase = Math.random()*Math.PI*2;
      manualPaletteCursor = (manualPaletteCursor + 1) % OBSTACLE_COLORS.length;
      keepObstacleInside(created);
      obstacles.push(created);
      syncManualObstacleState();
      markPathCostDirty();
    }
    drawingState = null;
  }
  dragTarget=null; dragKind=null; dragIndex=-1; dragRadius=0;
  if(e && typeof canvas.hasPointerCapture === 'function' && canvas.hasPointerCapture(e.pointerId) && typeof canvas.releasePointerCapture === 'function'){
    canvas.releasePointerCapture(e.pointerId);
  }
  activePointerId = null;
}

window.addEventListener('pointerup', (e)=>{
  endPointerInteraction(e);
});

window.addEventListener('pointercancel', (e)=>{
  endPointerInteraction(e);
});

// Utils
function rand(a,b){ return a + Math.random()*(b-a); }
function nearest(arr,x,y){ if(!arr.length) return null; let best=arr[0],bd=1e9; for(const o of arr){ const d=Math.hypot(o.x-x,o.y-y); if(d<bd){bd=d; best=o;} } return best; }
const OBSTACLE_PADDING = 12;
function obstacleOverlaps(x,y,r, ignoreIndex=-1){
  for(let i=0;i<obstacles.length;i++){
    if(i===ignoreIndex) continue;
    const o=obstacles[i];
    const otherR = getObstacleRadius(o);
    if(Math.hypot(x-o.x,y-o.y) < r + otherR + OBSTACLE_PADDING) return true;
  }
  return false;
}

function isPointInsideObstacle(o, x, y, padding=0){
  switch(o.type){
    case 'rect':{
      const halfW = o.width/2 + padding;
      const halfH = o.height/2 + padding;
      return Math.abs(x - o.x) <= halfW && Math.abs(y - o.y) <= halfH;
    }
    case 'line':{
      const seg = distanceToSegment(x, y, o.x1, o.y1, o.x2, o.y2);
      const radius = (o.thickness||14)/2 + padding;
      return seg.distance <= radius;
    }
    case 'half':{
      const dx = x - o.x;
      const dy = y - o.y;
      const radius = o.r + padding;
      const dist = Math.hypot(dx, dy);
      if(dist <= radius){
        const facingX = Math.cos(o.angle);
        const facingY = Math.sin(o.angle);
        const proj = dx*facingX + dy*facingY;
        if(proj >= -padding) return true;
      }
      const perpX = -Math.sin(o.angle);
      const perpY = Math.cos(o.angle);
      const ax = o.x - perpX * o.r;
      const ay = o.y - perpY * o.r;
      const bx = o.x + perpX * o.r;
      const by = o.y + perpY * o.r;
      const seg = distanceToSegment(x, y, ax, ay, bx, by);
      return seg.distance <= padding;
    }
    default:
      return Math.hypot(x-o.x,y-o.y) <= (o.r || getObstacleRadius(o)) + padding;
  }
}

function pointInsideObstacle(x,y){
  for(const o of obstacles){
    if(isPointInsideObstacle(o, x, y, 7)) return true;
  }
  return false;
}

function obstacleClearance(o, px, py){
  const margin = 8;
  switch(o.type){
    case 'rect':{
      const halfW = o.width/2 + margin;
      const halfH = o.height/2 + margin;
      const dx = px - o.x;
      const dy = py - o.y;
      const ax = Math.abs(dx) - halfW;
      const ay = Math.abs(dy) - halfH;
      if(ax <= 0 && ay <= 0){
        if(ax > ay){
          const nx = Math.sign(dx) || 1;
          return { distance: ax, nx, ny:0 };
        } else {
          const ny = Math.sign(dy) || 1;
          return { distance: ay, nx:0, ny };
        }
      }
      const outsideX = Math.max(ax, 0);
      const outsideY = Math.max(ay, 0);
      const dist = Math.hypot(outsideX, outsideY);
      let nx = 0, ny = 0;
      if(dist > 0){
        nx = outsideX ? (outsideX/dist) * Math.sign(dx || 1) : 0;
        ny = outsideY ? (outsideY/dist) * Math.sign(dy || 1) : 0;
      } else {
        if(ax > 0) nx = Math.sign(dx) || 1;
        if(ay > 0) ny = Math.sign(dy) || 1;
      }
      return { distance: dist, nx, ny };
    }
    case 'line':{
      const seg = distanceToSegment(px, py, o.x1, o.y1, o.x2, o.y2);
      const radius = (o.thickness||14)/2 + margin;
      let nx = seg.nx;
      let ny = seg.ny;
      if(seg.distance === 0){
        const vx = o.x2 - o.x1;
        const vy = o.y2 - o.y1;
        const len = Math.hypot(vx, vy) || 1;
        nx = -vy / len;
        ny = vx / len;
        const midX = (o.x1 + o.x2) / 2;
        const midY = (o.y1 + o.y2) / 2;
        if((px - midX)*nx + (py - midY)*ny < 0){
          nx = -nx;
          ny = -ny;
        }
      }
      return { distance: seg.distance - radius, nx, ny };
    }
    case 'half':{
      const dx = px - o.x;
      const dy = py - o.y;
      const facingX = Math.cos(o.angle);
      const facingY = Math.sin(o.angle);
      const proj = dx*facingX + dy*facingY;
      if(proj >= 0){
        const dist = Math.hypot(dx, dy);
        const radius = o.r + margin;
        const inv = dist>0 ? 1/dist : 0;
        const nx = inv>0 ? dx*inv : facingX;
        const ny = inv>0 ? dy*inv : facingY;
        return { distance: dist - radius, nx, ny };
      }
      const perpX = -Math.sin(o.angle);
      const perpY = Math.cos(o.angle);
      const ax = o.x - perpX * o.r;
      const ay = o.y - perpY * o.r;
      const bx = o.x + perpX * o.r;
      const by = o.y + perpY * o.r;
      const seg = distanceToSegment(px, py, ax, ay, bx, by);
      let nx = seg.nx;
      let ny = seg.ny;
      if(seg.distance === 0){
        nx = facingX;
        ny = facingY;
      }
      return { distance: seg.distance - margin, nx, ny };
    }
    default:{
      const dx = px - o.x;
      const dy = py - o.y;
      const dist = Math.hypot(dx, dy);
      const radius = (o.r || getObstacleRadius(o)) + margin;
      const inv = dist>0 ? 1/dist : 0;
      const nx = inv>0 ? dx*inv : 1;
      const ny = inv>0 ? dy*inv : 0;
      return { distance: dist - radius, nx, ny };
    }
  }
}
function getFruitSpawnArea(){
  const mode = params.fruitPlacement;
  if(!mode || mode === 'random') return null;
  const margin = 48;
  const spanX = Math.max(170, Math.min(280, W - margin*2));
  const spanY = Math.max(150, Math.min(240, H - margin*2));
  let minX = margin;
  let minY = margin;
  switch(mode){
    case 'center':{
      const radius = Math.min(spanX, spanY) * 0.5;
      return {
        shape: 'circle',
        cx: W * 0.5,
        cy: H * 0.5,
        r: radius
      };
    }
    case 'ne':
      minX = Math.max(margin, W - margin - spanX);
      break;
    case 'se':
      minX = Math.max(margin, W - margin - spanX);
      minY = Math.max(margin, H - margin - spanY);
      break;
    case 'sw':
      minY = Math.max(margin, H - margin - spanY);
      break;
    case 'nw':
      // already top-left
      break;
    default:
      return null;
  }
  const maxX = Math.min(W - margin, minX + spanX);
  const maxY = Math.min(H - margin, minY + spanY);
  return {
    minX,
    maxX,
    minY,
    maxY
  };
}

function normalizeFruitArea(area){
  if(!area) return null;
  if(area.shape === 'circle'){
    const cx = clamp(Number(area.cx) || W * 0.5, 40, W - 40);
    const cy = clamp(Number(area.cy) || H * 0.5, 40, H - 40);
    const maxRadius = Math.min(cx - 40, cy - 40, W - cx - 40, H - cy - 40);
    const r = clamp(Number(area.r) || 0, 12, Math.max(12, maxRadius));
    if(!Number.isFinite(r) || r <= 0) return null;
    return {
      shape: 'circle',
      cx,
      cy,
      r,
      minX: cx - r,
      maxX: cx + r,
      minY: cy - r,
      maxY: cy + r
    };
  }
  const minX = Math.max(40, Math.min(area.minX, W - 40));
  const maxX = Math.min(area.maxX, W - 40);
  const minY = Math.max(40, Math.min(area.minY, H - 40));
  const maxY = Math.min(area.maxY, H - 40);
  if(!Number.isFinite(minX) || !Number.isFinite(maxX) || maxX - minX < 20) return null;
  if(!Number.isFinite(minY) || !Number.isFinite(maxY) || maxY - minY < 20) return null;
  return { minX, maxX, minY, maxY };
}

function selectFruitClusterCenter(area, clusterRadius, fallbackX, fallbackY){
  const keepouts = getAllGoalStates()
    .map((goal)=> ({ x: goal.x, y: goal.y, r: goal.r + 10 }))
    .filter((keep)=> (
      keep.x >= area.minX - keep.r && keep.x <= area.maxX + keep.r &&
      keep.y >= area.minY - keep.r && keep.y <= area.maxY + keep.r
    ));
  if(keepouts.length === 0){
    return { x: fallbackX, y: fallbackY };
  }

  const padX = Math.min(clusterRadius * 0.75, (area.maxX - area.minX) * 0.5);
  const padY = Math.min(clusterRadius * 0.75, (area.maxY - area.minY) * 0.5);
  let clampMinX = area.minX + padX;
  let clampMaxX = area.maxX - padX;
  let clampMinY = area.minY + padY;
  let clampMaxY = area.maxY - padY;
  if(clampMinX > clampMaxX){
    const mid = (area.minX + area.maxX) / 2;
    clampMinX = clampMaxX = mid;
  }
  if(clampMinY > clampMaxY){
    const mid = (area.minY + area.maxY) / 2;
    clampMinY = clampMaxY = mid;
  }

  const candidates = [];
  const addCandidate = (x, y)=>{
    const cx = clamp(x, clampMinX, clampMaxX);
    const cy = clamp(y, clampMinY, clampMaxY);
    candidates.push({ x: cx, y: cy });
  };

  addCandidate(fallbackX, fallbackY);
  addCandidate(area.minX + padX, area.minY + padY);
  addCandidate(area.maxX - padX, area.minY + padY);
  addCandidate(area.maxX - padX, area.maxY - padY);
  addCandidate(area.minX + padX, area.maxY - padY);
  for(const keep of keepouts){
    const angle = Math.atan2(fallbackY - keep.y, fallbackX - keep.x);
    const targetDist = keep.r + Math.min(clusterRadius * 0.6, 32);
    addCandidate(keep.x - Math.cos(angle || 0) * targetDist, keep.y - Math.sin(angle || 0) * targetDist);
  }

  let best = { x: clamp(fallbackX, clampMinX, clampMaxX), y: clamp(fallbackY, clampMinY, clampMaxY) };
  let bestScore = -Infinity;
  for(const candidate of candidates){
    let minClear = Infinity;
    for(const keep of keepouts){
      const clearance = Math.hypot(candidate.x - keep.x, candidate.y - keep.y) - keep.r;
      if(clearance < minClear) minClear = clearance;
    }
    if(minClear > bestScore){
      bestScore = minClear;
      best = candidate;
    }
  }
  return best;
}

function findFreeFruitSpot(maxTry=80, preferredArea=null){
  const area = normalizeFruitArea(preferredArea);
  const trySampler = (sampler)=>{
    for(let i=0;i<maxTry;i++){
      const { x, y } = sampler();
      if(goalTooClose(x,y,6,16)) continue;
      if(pointInsideObstacle(x,y)) continue;
      return { x, y };
    }
    return null;
  };
  if(area){
    if(area.shape === 'circle'){
      const circleSampler = ()=>{
        const angle = Math.random() * TAU;
        const radius = Math.sqrt(Math.random()) * area.r;
        return {
          x: clamp(area.cx + Math.cos(angle) * radius, area.minX, area.maxX),
          y: clamp(area.cy + Math.sin(angle) * radius, area.minY, area.maxY)
        };
      };
      const circleSpot = trySampler(circleSampler);
      if(circleSpot) return circleSpot;
    }
    const midX = (area.minX + area.maxX) / 2;
    const midY = (area.minY + area.maxY) / 2;
    const spanX = Math.max(20, (area.maxX - area.minX));
    const spanY = Math.max(20, (area.maxY - area.minY));
    const baseRadius = Math.min(spanX, spanY) * 0.45;
    const clusterRadius = clamp(baseRadius, 32, Math.min(spanX, spanY) * 0.5);
    const jitterLimit = Math.min(8, clusterRadius * 0.28);
    const clusterCenter = selectFruitClusterCenter(area, clusterRadius, midX, midY);
    const clusterSampler = ()=>{
      const angle = Math.random() * TAU;
      const radius = Math.sqrt(Math.random()) * clusterRadius;
      const orbitX = clusterCenter.x + Math.cos(angle) * radius;
      const orbitY = clusterCenter.y + Math.sin(angle) * radius;
      const jitterX = clamp(randn() * jitterLimit, -jitterLimit, jitterLimit);
      const jitterY = clamp(randn() * jitterLimit, -jitterLimit, jitterLimit);
      return {
        x: clamp(orbitX + jitterX, area.minX, area.maxX),
        y: clamp(orbitY + jitterY, area.minY, area.maxY)
      };
    };
    const clusterSpot = trySampler(clusterSampler);
    if(clusterSpot) return clusterSpot;
  }
  return trySampler(()=> ({ x: rand(40, W-40), y: rand(40, H-40) }));
}

function spawnFruit(x=null,y=null){
  if(fruits.length>=params.maxFruits) return;
  if(x==null||y==null){
    const pos = findFreeFruitSpot(120, getFruitSpawnArea());
    if(!pos) return;
    x=pos.x;
    y=pos.y;
  }
  if(pointInsideObstacle(x,y)){
    const pos = findFreeFruitSpot(80, getFruitSpawnArea()) || findFreeFruitSpot();
    if(!pos) return;
    x=pos.x;
    y=pos.y;
  }
  fruits.push({x,y,r:6,color:COLORS.fruit});
}
function goalTooClose(x,y,r,padding=40){
  for(const goal of getAllGoalStates()){
    if(Math.hypot(x-goal.x,y-goal.y) < goal.r + r + padding) return true;
  }
  return false;
}
function makeObstacles(n){
  const preserved = obstacles.filter(o=>o.manual || o.persistent);
  obstacles.length = 0;
  for(const kept of preserved){
    obstacles.push(kept);
  }
  const paletteLen=OBSTACLE_COLORS.length;
  for(let i=0;i<n;i++){
    let r=rand(16,40);
    let placed=false;
    for(let tries=0; tries<420 && !placed; tries++){
      if(tries===240) r=Math.max(12,r*0.85);
      if(tries===360) r=Math.max(10,r*0.85);
      const x=rand(80,W-80);
      const y=rand(60,H-60);
      if(goalTooClose(x,y,r,40)) continue;
      if(obstacleOverlaps(x,y,r)) continue;
      obstacles.push(createCircleObstacle(x,y,r,i%paletteLen,false));
      placed=true;
    }
    if(!placed){
      const step=36;
      outer: for(let gy=60; gy<=H-60 && !placed; gy+=step){
        for(let gx=80; gx<=W-80; gx+=step){
          if(goalTooClose(gx,gy,r,40)) continue;
          if(obstacleOverlaps(gx,gy,r)) continue;
          obstacles.push(createCircleObstacle(gx,gy,r,i%paletteLen,false));
          placed=true;
          break outer;
        }
      }
    }
    if(!placed){
      const fallback = obstacles[obstacles.length-1] || {x:W*0.5,y:H*0.5,r:20};
      let angle=Math.random()*TAU;
      let dist=getObstacleRadius(fallback) + r + OBSTACLE_PADDING + 4;
      for(let steps=0; steps<60 && !placed; steps++){
        const x=Math.max(r+4, Math.min(W-r-4, fallback.x + Math.cos(angle)*dist));
        const y=Math.max(r+4, Math.min(H-r-4, fallback.y + Math.sin(angle)*dist));
        if(obstacleOverlaps(x,y,r)){
          dist += r*0.35 + OBSTACLE_PADDING;
          angle += 0.4;
          continue;
        }
        obstacles.push(createCircleObstacle(x,y,r,i%paletteLen,false));
        placed=true;
      }
    }
    if(!placed){
      const smallR = Math.max(10, r*0.8);
      for(let tries=0; tries<240 && !placed; tries++){
        const x=rand(80,W-80);
        const y=rand(60,H-60);
        if(goalTooClose(x,y,smallR,32)) continue;
        if(obstacleOverlaps(x,y,smallR)) continue;
        obstacles.push(createCircleObstacle(x,y,smallR,i%paletteLen,false));
        placed=true;
      }
    }
  }
  markPathCostDirty();
}


function lineTooCloseToGoals(x1, y1, x2, y2, thickness, goals){
  const goalStates = Array.isArray(goals) && goals.length ? goals : getAllGoalStates();
  const buffer = (thickness || 14) * 0.5 + GOAL_RADIUS + 18;
  for(const goal of goalStates){
    if(!goal) continue;
    const seg = distanceToSegment(goal.x, goal.y, x1, y1, x2, y2);
    const goalRadius = Number.isFinite(goal.r) ? goal.r : GOAL_RADIUS;
    if(seg.distance <= goalRadius + buffer){
      return true;
    }
  }
  return false;
}

function generateLabyrinthObstacles(options={}){
  const colsRaw = Number.isFinite(options.cols) ? Math.floor(options.cols) : 12;
  const rowsRaw = Number.isFinite(options.rows) ? Math.floor(options.rows) : 8;
  const cols = clamp(colsRaw, 4, 28);
  const rows = clamp(rowsRaw, 4, 24);
  const marginX = clamp(Number.isFinite(options.marginX) ? options.marginX : 90, 40, W/2);
  const marginY = clamp(Number.isFinite(options.marginY) ? options.marginY : 80, 40, H/2);
  const usableWidth = W - marginX * 2;
  const usableHeight = H - marginY * 2;
  if(usableWidth <= 0 || usableHeight <= 0) return;

  const cellWidth = usableWidth / cols;
  const cellHeight = usableHeight / rows;
  const preserved = obstacles.filter(o=>o.manual);
  obstacles.length = 0;
  preserved.forEach((o)=> obstacles.push(o));

  const cells = [];
  for(let row=0; row<rows; row++){
    const cellRow = [];
    for(let col=0; col<cols; col++){
      cellRow.push({
        row,
        col,
        visited:false,
        walls:{ top:true, right:true, bottom:true, left:true }
      });
    }
    cells.push(cellRow);
  }

  const dirs = [
    { dx:0, dy:-1, wall:'top', opposite:'bottom' },
    { dx:1, dy:0, wall:'right', opposite:'left' },
    { dx:0, dy:1, wall:'bottom', opposite:'top' },
    { dx:-1, dy:0, wall:'left', opposite:'right' }
  ];

  const startRow = Math.floor(Math.random() * rows);
  const startCol = Math.floor(Math.random() * cols);
  const stack = [];
  const startCell = cells[startRow][startCol];
  startCell.visited = true;
  stack.push(startCell);

  while(stack.length){
    const current = stack[stack.length-1];
    const candidates = [];
    for(const dir of dirs){
      const nx = current.col + dir.dx;
      const ny = current.row + dir.dy;
      if(nx < 0 || ny < 0 || nx >= cols || ny >= rows) continue;
      const neighbor = cells[ny][nx];
      if(!neighbor.visited){
        candidates.push({ neighbor, dir });
      }
    }
    if(candidates.length){
      const pick = candidates[Math.floor(Math.random() * candidates.length)];
      current.walls[pick.dir.wall] = false;
      pick.neighbor.walls[pick.dir.opposite] = false;
      pick.neighbor.visited = true;
      stack.push(pick.neighbor);
    } else {
      stack.pop();
    }
  }

  const borderCandidates = [];
  for(let col=0; col<cols; col++){
    borderCandidates.push({ cell:cells[0][col], wall:'top' });
    borderCandidates.push({ cell:cells[rows-1][col], wall:'bottom' });
  }
  for(let row=1; row<rows-1; row++){
    borderCandidates.push({ cell:cells[row][0], wall:'left' });
    borderCandidates.push({ cell:cells[row][cols-1], wall:'right' });
  }
  const requestedOpenings = Number.isFinite(options.openings) ? Math.floor(options.openings) : 2;
  const openings = clamp(requestedOpenings, 2, Math.max(2, Math.round(Math.sqrt(cols * rows) / 3)));
  const selectedEntries = [];
  if(borderCandidates.length){
    const firstIndex = Math.floor(Math.random() * borderCandidates.length);
    selectedEntries.push(borderCandidates.splice(firstIndex, 1)[0]);
    while(selectedEntries.length < openings && borderCandidates.length){
      let bestIdx = 0;
      let bestScore = -Infinity;
      for(let i=0; i<borderCandidates.length; i++){
        const candidate = borderCandidates[i];
        if(!candidate || !candidate.cell) continue;
        let minDistance = Infinity;
        for(const chosen of selectedEntries){
          if(!chosen || !chosen.cell) continue;
          const dx = candidate.cell.col - chosen.cell.col;
          const dy = candidate.cell.row - chosen.cell.row;
          const dist = Math.abs(dx) + Math.abs(dy);
          if(dist < minDistance) minDistance = dist;
        }
        if(minDistance > bestScore){
          bestScore = minDistance;
          bestIdx = i;
        }
      }
      selectedEntries.push(borderCandidates.splice(bestIdx, 1)[0]);
    }
    selectedEntries.forEach((entry)=>{
      if(entry && entry.cell && entry.cell.walls[entry.wall] !== undefined){
        entry.cell.walls[entry.wall] = false;
      }
    });
  }

  const thickness = clamp(Math.min(cellWidth, cellHeight) * 0.32, 10, 28);
  const paletteLen = OBSTACLE_COLORS.length || 1;
  const paletteOffset = obstacles.length % paletteLen;
  const goals = getAllGoalStates();
  let segmentIndex = 0;

  const minX = marginX;
  const maxX = W - marginX;
  const minY = marginY;
  const maxY = H - marginY;

  const addSegment = (x1, y1, x2, y2)=>{
    const dx = x2 - x1;
    const dy = y2 - y1;
    const length = Math.hypot(dx, dy);
    if(length <= 1) return;
    const expand = thickness * 0.5;
    const nx = dx / length;
    const ny = dy / length;
    let ax = x1 - nx * expand;
    let ay = y1 - ny * expand;
    let bx = x2 + nx * expand;
    let by = y2 + ny * expand;
    ax = clamp(ax, minX, maxX);
    bx = clamp(bx, minX, maxX);
    ay = clamp(ay, minY, maxY);
    by = clamp(by, minY, maxY);
    if(lineTooCloseToGoals(ax, ay, bx, by, thickness, goals)) return;
    const paletteIndex = (paletteOffset + segmentIndex) % paletteLen;
    const obstacle = createLineObstacle(ax, ay, bx, by, thickness, paletteIndex, false, { persistent:true });
    obstacles.push(obstacle);
    segmentIndex++;
  };

  for(let row=0; row<rows; row++){
    for(let col=0; col<cols; col++){
      const cell = cells[row][col];
      const x0 = marginX + col * cellWidth;
      const y0 = marginY + row * cellHeight;
      const x1 = x0 + cellWidth;
      const y1 = y0 + cellHeight;
      if(cell.walls.right){
        addSegment(x1, y0, x1, y1);
      }
      if(cell.walls.bottom){
        addSegment(x0, y1, x1, y1);
      }
      if(row === 0 && cell.walls.top){
        addSegment(x0, y0, x1, y0);
      }
      if(col === 0 && cell.walls.left){
        addSegment(x0, y0, x0, y1);
      }
    }
  }

  markPathCostDirty();
  syncManualObstacleState();
}


const NET_INPUTS = 24;
const NET_OUTPUTS = 4;
const OUTPUT_NODE_LABELS = ['Drive X', 'Drive Y', 'Speed +', 'Speed ‚àí'];

// ===== NEAT‚Äëlite (7‚ÜíH‚Üí4) =====
function randn(){ let u=0,v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random(); return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v); }
function matmulVec(W, x, out){ const rows=W.length, cols=W[0].length; for(let i=0;i<rows;i++){ let s=0; const Wi=W[i]; for(let j=0;j<cols;j++) s+=Wi[j]*x[j]; out[i]=s; } return out; }
function tanhVec(v){ for(let i=0;i<v.length;i++) v[i]=Math.tanh(v[i]); return v; }
function addBias(v,b){ for(let i=0;i<v.length;i++) v[i]+=b[i]; return v; }
function ensureArraySize(arr, length){ return (Array.isArray(arr) && arr.length===length) ? arr : new Array(length); }
function ensureNetInputSize(net, desired=NET_INPUTS){
  if(!net || !Array.isArray(net.W1)) return net;
  for(let i=0;i<net.W1.length;i++){
    let row = Array.isArray(net.W1[i]) ? net.W1[i] : [];
    while(row.length < desired){
      row.push((Math.random()*2-1)*0.5);
    }
    if(row.length > desired){
      row.length = desired;
    }
    net.W1[i] = row;
  }
  return net;
}

function ensureNetHiddenSize(net, desired=NET_HIDDEN){
  if(!net) return net;
  const target = Math.max(1, Math.round(Number.isFinite(desired) ? desired : NET_HIDDEN));
  if(!Array.isArray(net.W1)) net.W1 = [];
  if(!Array.isArray(net.b1)) net.b1 = [];
  const inputDim = Array.isArray(net.W1?.[0]) ? net.W1[0].length : (Array.isArray(net.W2?.[0]) ? net.W2[0].length : NET_INPUTS);
  ensureNetInputSize(net, inputDim);
  while(net.W1.length < target){
    net.W1.push(Array.from({length:inputDim}, ()=> (Math.random()*2-1)*0.5));
  }
  while(net.b1.length < target){
    net.b1.push((Math.random()*2-1)*0.2);
  }
  if(net.W1.length > target) net.W1.length = target;
  if(net.b1.length > target) net.b1.length = target;
  return net;
}

function ensureNetOutputSize(net, desired=NET_OUTPUTS){
  if(!net) return net;
  ensureNetHiddenSize(net, NET_HIDDEN);
  ensureNetInputSize(net, NET_INPUTS);
  const hiddenDim = Array.isArray(net.W1) ? net.W1.length : (Array.isArray(net.W2?.[0]) ? net.W2[0].length : NET_HIDDEN);
  if(!Array.isArray(net.W2)) net.W2 = [];
  if(!Array.isArray(net.b2)) net.b2 = [];
  for(let i=0;i<net.W2.length;i++){
    const row = Array.isArray(net.W2[i]) ? net.W2[i].slice() : [];
    if(row.length !== hiddenDim){
      net.W2[i] = Array.from({length:hiddenDim}, (_v, idx)=> (idx<row.length && Number.isFinite(row[idx])) ? row[idx] : (Math.random()*2-1)*0.5);
    } else {
      net.W2[i] = row;
    }
  }
  while(net.W2.length < desired){
    net.W2.push(Array.from({length:hiddenDim}, ()=> (Math.random()*2-1)*0.5));
  }
  while(net.b2.length < desired){
    net.b2.push((Math.random()*2-1)*0.2);
  }
  if(net.W2.length > desired) net.W2.length = desired;
  if(net.b2.length > desired) net.b2.length = desired;
  return net;
}

function makeNet(inDim=NET_INPUTS,h=NET_HIDDEN,out=NET_OUTPUTS){
  const net = {
    W1:Array.from({length:h},()=>Array.from({length:inDim},()=> (Math.random()*2-1)*0.5)),
    b1:Array.from({length:h},()=> (Math.random()*2-1)*0.2),
    W2:Array.from({length:out},()=>Array.from({length:h},()=> (Math.random()*2-1)*0.5)),
    b2:Array.from({length:out},()=> (Math.random()*2-1)*0.2)
  };
  ensureNetHiddenSize(net, h);
  ensureNetInputSize(net, inDim);
  return ensureNetOutputSize(net, out);
}
function cloneNet(n){
  const cloned = {
    W1:n.W1.map(r=>r.slice()),
    b1:n.b1.slice(),
    W2:n.W2.map(r=>r.slice()),
    b2:n.b2.slice()
  };
  ensureNetHiddenSize(cloned, NET_HIDDEN);
  ensureNetInputSize(cloned, NET_INPUTS);
  return ensureNetOutputSize(cloned);
}
function mutateNet(n, rate){
  const sW = params.learn?.mutStrengthW ?? 0.2;
  const sB = params.learn?.mutStrengthB ?? 0.2;
  for(const r of n.W1){
    for(let i=0;i<r.length;i++){
      if(Math.random()<rate) r[i]+=randn()*sW;
    }
  }
  for(let i=0;i<n.b1.length;i++){
    if(Math.random()<rate) n.b1[i]+=randn()*sB;
  }
  for(const r of n.W2){
    for(let i=0;i<r.length;i++){
      if(Math.random()<rate) r[i]+=randn()*sW;
    }
  }
  for(let i=0;i<n.b2.length;i++){
    if(Math.random()<rate) n.b2[i]+=randn()*sB;
  }
}
function crossover(a,b){
  const bias = params.learn?.crossoverBias ?? 0.5;
  const c = cloneNet(a);
  const pick = ()=> (Math.random()<bias);
  for(let i=0;i<c.W1.length;i++){
    for(let j=0;j<c.W1[0].length;j++){
      c.W1[i][j] = pick() ? a.W1[i][j] : b.W1[i][j];
    }
  }
  for(let i=0;i<c.b1.length;i++){
    c.b1[i] = pick() ? a.b1[i] : b.b1[i];
  }
  for(let i=0;i<c.W2.length;i++){
    for(let j=0;j<c.W2[0].length;j++){
      c.W2[i][j] = pick() ? a.W2[i][j] : b.W2[i][j];
    }
  }
  for(let i=0;i<c.b2.length;i++){
    c.b2[i] = pick() ? a.b2[i] : b.b2[i];
  }
  return c;
}
function forward(n, x, capture=null){
  ensureNetInputSize(n, x.length);
  ensureNetHiddenSize(n, NET_HIDDEN);
  ensureNetOutputSize(n);
  const hidden = capture ? ensureArraySize(capture.hidden, n.b1.length) : new Array(n.b1.length);
  const output = capture ? ensureArraySize(capture.output, n.b2.length) : new Array(n.b2.length);
  matmulVec(n.W1,x,hidden);
  addBias(hidden,n.b1);
  tanhVec(hidden);
  matmulVec(n.W2,hidden,output);
  addBias(output,n.b2);
  tanhVec(output);
  if(capture){
    capture.hidden = hidden;
    capture.output = output;
    const inputStore = ensureArraySize(capture.input, x.length);
    for(let i=0;i<x.length;i++) inputStore[i] = x[i];
    capture.input = inputStore;
  }
  return output;
}
function makePopulation(size){ return Array.from({length:size}, ()=> ({ net:makeNet(), fitness:0 })); }
const evo = { gen:1, populations:{} };

function createEmptyBrainState(gen){
  return {
    fitness:-Infinity,
    teamId:null,
    teamLabel:'',
    teamIcon:'',
    teamColor:'#38bdf8',
    gen:Number.isFinite(gen) ? gen : (evo?.gen || 1),
    net:null,
    agentRef:null,
    activations:{ input:[], hidden:[], output:[], timestamp:0 }
  };
}
const bestBrainState = createEmptyBrainState(evo.gen);
const globalBrainChampion = createEmptyBrainState(evo.gen);
const teamBrainCache = new Map();
let brainViewMode = 'auto';
let brainViewTeamId = null;
let bestBrainDirty = true;

function applyHiddenLayerSize(desired){
  const numeric = Math.round(Number(desired));
  const clamped = clamp(Number.isFinite(numeric) ? numeric : NET_HIDDEN, NET_HIDDEN_MIN, NET_HIDDEN_MAX);
  if(clamped === NET_HIDDEN){
    return;
  }
  NET_HIDDEN = clamped;
  if(params?.learn){
    params.learn.hidden = clamped;
  }
  const adjustNet = (net)=>{
    if(!net) return;
    ensureNetHiddenSize(net, clamped);
    ensureNetInputSize(net, NET_INPUTS);
    ensureNetOutputSize(net, NET_OUTPUTS);
  };
  const populations = evo?.populations ? Object.values(evo.populations) : [];
  populations.forEach((pop)=>{
    if(!Array.isArray(pop)) return;
    pop.forEach((member)=>{
      if(member?.net) adjustNet(member.net);
    });
  });
  const adjustState = (state)=>{
    if(!state) return;
    if(state.net) adjustNet(state.net);
    if(state.activations){
      state.activations.input = ensureArraySize(state.activations.input, NET_INPUTS);
      state.activations.hidden = ensureArraySize(state.activations.hidden, clamped);
      state.activations.output = ensureArraySize(state.activations.output, NET_OUTPUTS);
    }
  };
  adjustState(bestBrainState);
  adjustState(globalBrainChampion);
  if(teamBrainCache && typeof teamBrainCache.forEach === 'function'){
    teamBrainCache.forEach((state)=> adjustState(state));
  }
  if(Array.isArray(activeTeamStates)){
    for(const team of activeTeamStates){
      if(!team?.agents) continue;
      for(const agent of team.agents){
        if(!agent?.activationScratch) continue;
        agent.activationScratch.input = ensureArraySize(agent.activationScratch.input, NET_INPUTS);
        agent.activationScratch.hidden = ensureArraySize(agent.activationScratch.hidden, clamped);
        agent.activationScratch.output = ensureArraySize(agent.activationScratch.output, NET_OUTPUTS);
      }
    }
  }
  markBestBrainDirty();
}

function markBestBrainDirty(){
  bestBrainDirty = true;
}
function clearActivationStore(store){
  if(!store) return;
  store.input.length = 0;
  store.hidden.length = 0;
  store.output.length = 0;
  store.timestamp = 0;
}

function resetBrainState(state, gen){
  if(!state) return;
  state.fitness = -Infinity;
  state.teamId = null;
  state.teamLabel = '';
  state.teamIcon = '';
  state.teamColor = '#38bdf8';
  state.gen = Number.isFinite(gen) ? gen : (evo?.gen || 1);
  state.net = null;
  state.agentRef = null;
  if(!state.activations){
    state.activations = { input:[], hidden:[], output:[], timestamp:0 };
  } else {
    clearActivationStore(state.activations);
  }
}

function ensureTeamBrainCache(teamId){
  if(!teamId) return null;
  let cache = teamBrainCache.get(teamId);
  if(!cache){
    cache = createEmptyBrainState(evo.gen);
    cache.teamId = teamId;
    const team = params?.teams?.find?.((t)=>t.id===teamId);
    if(team){
      cache.teamLabel = team.label || team.id || '';
      cache.teamIcon = team.icon || '‚óè';
      cache.teamColor = team.color || '#38bdf8';
    }
    teamBrainCache.set(teamId, cache);
  }
  return cache;
}

function applyBrainSelection(value){
  const mode = value && value !== 'auto' ? 'team' : 'auto';
  if(mode === 'auto'){
    brainViewMode = 'auto';
    brainViewTeamId = null;
    if(globalBrainChampion.net){
      const teamConfig = {
        id: globalBrainChampion.teamId,
        label: globalBrainChampion.teamLabel,
        icon: globalBrainChampion.teamIcon,
        color: globalBrainChampion.teamColor
      };
      setBestBrainFromNet(globalBrainChampion.net, teamConfig, globalBrainChampion.fitness, globalBrainChampion.gen, globalBrainChampion.agentRef, bestBrainState, globalBrainChampion.activations);
    } else {
      resetBrainState(bestBrainState, evo.gen);
      markBestBrainDirty();
    }
    updateBrainMeta();
    return;
  }

  const team = params.teams.find((t)=>t.id===value);
  if(!team || !team.active){
    brainViewMode = 'auto';
    brainViewTeamId = null;
    if(brainTeamSelect){
      brainTeamSelect.value = 'auto';
    }
    applyBrainSelection('auto');
    return;
  }

  brainViewMode = 'team';
  brainViewTeamId = team.id;
  const cache = ensureTeamBrainCache(team.id);
  if(cache && cache.net){
    setBestBrainFromNet(cache.net, team, cache.fitness, cache.gen, cache.agentRef, bestBrainState, cache.activations);
  } else {
    resetBrainState(bestBrainState, evo.gen);
    bestBrainState.teamId = team.id;
    bestBrainState.teamLabel = team.label || team.id || '';
    bestBrainState.teamIcon = team.icon || '‚óè';
    bestBrainState.teamColor = team.color || '#38bdf8';
    markBestBrainDirty();
  }
  updateBrainMeta();
}

function refreshBrainTeamOptions(){
  if(!brainTeamSelect) return;
  const previous = brainTeamSelect.value;
  brainTeamSelect.innerHTML = '';
  const autoOption = document.createElement('option');
  autoOption.value = 'auto';
  autoOption.textContent = 'Auto ‚Äî top performer';
  brainTeamSelect.append(autoOption);
  params.teams.forEach((team)=>{
    const option = document.createElement('option');
    option.value = team.id;
    option.textContent = `${team.icon || '‚óè'} ${team.label}`.trim();
    if(!team.active) option.disabled = true;
    brainTeamSelect.append(option);
  });
  let next = previous;
  const candidate = next ? brainTeamSelect.querySelector(`option[value="${next}"]`) : null;
  if(!candidate || candidate.disabled){
    next = 'auto';
  }
  brainTeamSelect.value = next;
  applyBrainSelection(next);
}
function applyBrainVizState(){
  const enabled = !!brainVizEnabled;
  if(brainCanvas){
    if(enabled){
      brainCanvas.removeAttribute('hidden');
    } else {
      brainCanvas.setAttribute('hidden','');
    }
  }
  if(brainPausedEl){
    brainPausedEl.hidden = enabled;
  }
  if(brainVizSection){
    brainVizSection.classList.toggle('brain-viz--hidden', !enabled);
  }
  if(brainToggleBtn){
    brainToggleBtn.textContent = enabled ? 'Hide visualization' : 'Show visualization';
    brainToggleBtn.setAttribute('aria-pressed', enabled ? 'true' : 'false');
    brainToggleBtn.setAttribute('title', enabled
      ? 'Hide the neural network visualization to save performance'
      : 'Show the neural network visualization');
  }
  markBestBrainDirty();
  updateBrainMeta();
  if(enabled){
    renderBestBrain();
  } else if(brainCtx && brainCanvas){
    brainCtx.clearRect(0, 0, brainCanvas.width || 0, brainCanvas.height || 0);
  }
}
if(brainToggleBtn){
  brainToggleBtn.addEventListener('click', ()=>{
    brainVizEnabled = !brainVizEnabled;
    applyBrainVizState();
  });
}
if(brainTeamSelect){
  brainTeamSelect.addEventListener('change', ()=>{
    applyBrainSelection(brainTeamSelect.value);
  });
}
applyBrainVizState();

function syncPerformanceButton(){
  if(!performanceBtn) return;
  performanceBtn.classList.toggle('pill-button--active', performanceModeActive);
  performanceBtn.textContent = performanceModeActive ? 'Exit Performance' : 'Performance';
  performanceBtn.setAttribute('aria-pressed', performanceModeActive ? 'true' : 'false');
  performanceBtn.setAttribute('title', performanceModeActive
    ? 'Return to the full control surface'
    : 'Focus on the playfield and boost frame rates');
}

function setPerformanceMode(enabled){
  if(enabled === performanceModeActive) return;
  performanceModeActive = enabled;
  document.body.classList.toggle('performance-mode', enabled);

  let shouldApplyBrainVizState = false;

  if(enabled){
    performanceModePrefs.topHighlight = params.showTopHighlight;
    performanceModePrefs.energyHalo = params.showEnergyHalo;
    performanceModePrefs.brainViz = brainVizEnabled;
    performanceModePrefs.sensorRadar = params.showSensorRadar;

    params.showTopHighlight = false;
    params.showEnergyHalo = false;
    params.showSensorRadar = false;

    const topToggle = Q('chkTopHighlight');
    if(topToggle){
      topToggle.checked = false;
      const label = Q('lbTopHighlight');
      if(label) label.textContent = 'off';
    }

    const haloToggle = Q('chkEnergyHalo');
    if(haloToggle){
      haloToggle.checked = false;
      const label = Q('lbEnergyHalo');
      if(label) label.textContent = 'off';
    }

    const radarToggle = Q('chkSensorRadar');
    if(radarToggle){
      radarToggle.checked = false;
      const label = Q('lbSensorRadar');
      if(label) label.textContent = 'off';
    }

    if(brainVizEnabled){
      brainVizEnabled = false;
      shouldApplyBrainVizState = true;
    }
  } else {
    if(performanceModePrefs.topHighlight != null){
      params.showTopHighlight = !!performanceModePrefs.topHighlight;
      const topToggle = Q('chkTopHighlight');
      if(topToggle){
        topToggle.checked = !!performanceModePrefs.topHighlight;
        const label = Q('lbTopHighlight');
        if(label) label.textContent = topToggle.checked ? 'on' : 'off';
      }
    }
    if(performanceModePrefs.energyHalo != null){
      params.showEnergyHalo = !!performanceModePrefs.energyHalo;
      const haloToggle = Q('chkEnergyHalo');
      if(haloToggle){
        haloToggle.checked = !!performanceModePrefs.energyHalo;
        const label = Q('lbEnergyHalo');
        if(label) label.textContent = haloToggle.checked ? 'on' : 'off';
      }
    }
    if(performanceModePrefs.sensorRadar != null){
      params.showSensorRadar = !!performanceModePrefs.sensorRadar;
      const radarToggle = Q('chkSensorRadar');
      if(radarToggle){
        radarToggle.checked = !!performanceModePrefs.sensorRadar;
        const label = Q('lbSensorRadar');
        if(label) label.textContent = radarToggle.checked ? 'on' : 'off';
      }
    }
    if(performanceModePrefs.brainViz != null){
      brainVizEnabled = !!performanceModePrefs.brainViz;
      shouldApplyBrainVizState = true;
    }
    refreshStats();
  }

  if(shouldApplyBrainVizState){
    applyBrainVizState();
  }

  syncPerformanceButton();
}

if(performanceBtn){
  performanceBtn.addEventListener('click', ()=> setPerformanceMode(!performanceModeActive));
}

document.addEventListener('keydown', (evt)=>{
  if(evt.key === 'Escape' && performanceModeActive){
    setPerformanceMode(false);
  }
});

syncPerformanceButton();

function resetBestBrainState(gen){
  resetBrainState(bestBrainState, gen);
  resetBrainState(globalBrainChampion, gen);
  teamBrainCache.clear();
  brainViewMode = 'auto';
  brainViewTeamId = null;
  if(brainTeamSelect){
    brainTeamSelect.value = 'auto';
  }
  markBestBrainDirty();
  updateBrainMeta();
}
function ensureBrainCanvasSizing(){
  if(!brainCanvas || !brainCtx) return;
  const rect = brainCanvas.getBoundingClientRect();
  if(rect.width && rect.height){
    brainCanvasWidth = rect.width;
    brainCanvasHeight = rect.height;
    const dpr = window.devicePixelRatio || 1;
    const deviceWidth = Math.max(1, Math.round(rect.width * dpr));
    const deviceHeight = Math.max(1, Math.round(rect.height * dpr));
    if(brainCanvas.width !== deviceWidth || brainCanvas.height !== deviceHeight){
      brainCanvas.width = deviceWidth;
      brainCanvas.height = deviceHeight;
    }
    brainCtx.setTransform(1,0,0,1,0,0);
    brainCtx.scale(dpr, dpr);
  } else {
    brainCanvasWidth = brainCanvasWidth || brainCanvas.width || 560;
    brainCanvasHeight = brainCanvasHeight || brainCanvas.height || 240;
  }
}
function updateBrainMeta(){
  if(brainSubtitleEl){
    const watchingTeam = brainViewMode === 'team';
    if(!brainVizEnabled){
      if(bestBrainState.net){
        brainSubtitleEl.textContent = watchingTeam
          ? 'View paused ‚Äî team numbers still refresh in the background.'
          : 'View paused ‚Äî leader numbers still update in real time.';
      } else {
        brainSubtitleEl.textContent = watchingTeam
          ? 'View hidden until this team finds its first leader.'
          : 'View hidden until a leader shows up.';
      }
    } else if(bestBrainState.net){
      if(bestBrainState.agentRef){
        const throttlePercent = typeof bestBrainState.agentRef.getThrottlePercent === 'function'
          ? bestBrainState.agentRef.getThrottlePercent()
          : (Number.isFinite(bestBrainState.agentRef?.speedFactor)
            ? Math.round(bestBrainState.agentRef.speedFactor * 100)
            : 100);
        const prefix = watchingTeam ? 'Team focus' : 'Top contender';
        brainSubtitleEl.textContent = `${prefix} ‚Äî cyan links boost the signal, pink links reverse it ‚Äî throttle at ${throttlePercent}% of max`;
      } else {
        brainSubtitleEl.textContent = watchingTeam
          ? 'Saved brain for this team ‚Äî Speed ¬± outputs adjust the throttle.'
          : 'Saved best network ‚Äî Speed ¬± outputs adjust the throttle.';
      }
    } else {
      brainSubtitleEl.textContent = watchingTeam
        ? 'This team has not produced a leader yet.'
        : 'The first winning brain will appear here soon.';
    }
  }
  if(brainTeamEl){
    if(bestBrainState.net){
      brainTeamEl.textContent = `${bestBrainState.teamIcon || '‚óè'} ${bestBrainState.teamLabel || 'Team'}`.trim();
      brainTeamEl.style.color = bestBrainState.agentRef ? 'var(--ink)' : 'var(--muted)';
    } else {
      if(brainViewMode === 'team' && bestBrainState.teamLabel){
        brainTeamEl.textContent = `${bestBrainState.teamIcon || '‚óè'} ${bestBrainState.teamLabel}`.trim();
      } else {
        brainTeamEl.textContent = 'No leader yet';
      }
      brainTeamEl.style.color = 'var(--muted)';
    }
  }
  if(brainBadgeEl){
    if(bestBrainState.net){
      brainBadgeEl.textContent = bestBrainState.teamIcon || '‚óè';
      const badgeAlpha = bestBrainState.agentRef ? 0.82 : 0.5;
      const glowAlpha = bestBrainState.agentRef ? 0.45 : 0.22;
      brainBadgeEl.style.background = hexToRgba(bestBrainState.teamColor || '#38bdf8', badgeAlpha);
      brainBadgeEl.style.boxShadow = `0 0 18px ${hexToRgba(bestBrainState.teamColor || '#38bdf8', glowAlpha)}`;
      brainBadgeEl.style.color = '#020617';
    } else {
      const fallbackIcon = bestBrainState.teamIcon || '‚óè';
      brainBadgeEl.textContent = fallbackIcon;
      const fallbackColor = bestBrainState.teamColor || '#38bdf8';
      brainBadgeEl.style.background = hexToRgba(fallbackColor, 0.35);
      brainBadgeEl.style.boxShadow = 'none';
      brainBadgeEl.style.color = '#94a3b8';
    }
  }
  if(brainFitnessEl){ brainFitnessEl.textContent = bestBrainState.net ? Math.round(bestBrainState.fitness).toString() : '‚Äî'; }
  if(brainGenEl){ brainGenEl.textContent = bestBrainState.net ? `Gen ${bestBrainState.gen}` : 'Gen ‚Äî'; }
}
function drawBrainPlaceholder(width,height){
  if(!brainCtx) return;
  brainCtx.save();
  const inset = 22;
  const gridWidth = Math.max(0, width - inset*2);
  const gridHeight = Math.max(0, height - inset*2);
  brainCtx.translate(inset, inset);
  brainCtx.strokeStyle = 'rgba(148,163,209,0.22)';
  brainCtx.lineWidth = 1.1;
  const rows = 4, cols = 5;
  for(let i=0;i<=rows;i++){
    const y = (gridHeight/rows)*i;
    brainCtx.beginPath();
    brainCtx.moveTo(0, y);
    brainCtx.lineTo(gridWidth, y);
    brainCtx.stroke();
  }
  for(let j=0;j<=cols;j++){
    const x = (gridWidth/cols)*j;
    brainCtx.beginPath();
    brainCtx.moveTo(x, 0);
    brainCtx.lineTo(x, gridHeight);
    brainCtx.stroke();
  }
  brainCtx.fillStyle = 'rgba(148,163,209,0.68)';
  brainCtx.font = '600 16px "Inter", system-ui, -apple-system, sans-serif';
  brainCtx.textAlign = 'center';
  brainCtx.textBaseline = 'middle';
  brainCtx.fillText('Simulation warming up‚Ä¶', gridWidth/2, gridHeight/2);
  brainCtx.restore();
}
function buildLayerPositions(count, x, top, bottom){
  if(count<=0) return [];
  const positions=[];
  const span = Math.max(0, bottom - top);
  if(count===1){
    positions.push({ x, y: top + span/2 });
    return positions;
  }
  const step = span/(count-1);
  for(let i=0;i<count;i++) positions.push({ x, y: top + step*i });
  return positions;
}
function maxAbsWeight(weights){
  let max=0;
  if(!Array.isArray(weights)) return max;
  for(const row of weights){
    if(!Array.isArray(row)) continue;
    for(const val of row){
      const mag = Math.abs(val);
      if(mag>max) max=mag;
    }
  }
  return max;
}
function drawBrainConnections(fromLayer, toLayer, weights, fromActivations=null, toActivations=null, activityScale=1){
  if(!brainCtx || !fromLayer || !toLayer || !weights) return;
  const maxW = maxAbsWeight(weights) || 1;
  const positiveColor = bestBrainState.teamColor || '#2dd4bf';
  for(let j=0;j<Math.min(toLayer.length, weights.length);j++){
    const row = weights[j];
    const target = toLayer[j];
    const targetAct = Array.isArray(toActivations) ? toActivations[j] : null;
    if(!target || !Array.isArray(row)) continue;
    for(let i=0;i<Math.min(fromLayer.length, row.length);i++){
      const source = fromLayer[i];
      if(!source) continue;
      const weight = row[i];
      if(!Number.isFinite(weight)) continue;
      const sourceAct = Array.isArray(fromActivations) ? fromActivations[i] : null;
      const activity = Math.max(0, Math.min(1, (typeof sourceAct === 'number' ? Math.abs(sourceAct) : 0)));
      const targetActivity = Math.max(0, Math.min(1, (typeof targetAct === 'number' ? Math.abs(targetAct) : 0)));
      const combinedActivity = Math.min(1, (activity*0.7 + targetActivity*0.5) * activityScale);
      const strength = Math.min(1, Math.abs(weight)/maxW);
      const alpha = 0.10 + strength*0.35 + combinedActivity*0.45;
      const width = 0.55 + strength*2.0 + combinedActivity*1.4;
      const colorHex = weight>=0 ? positiveColor : '#f472b6';
      brainCtx.beginPath();
      brainCtx.moveTo(source.x, source.y);
      brainCtx.lineTo(target.x, target.y);
      brainCtx.strokeStyle = hexToRgba(colorHex, alpha);
      brainCtx.lineWidth = width;
      if(combinedActivity>0.02){
        brainCtx.shadowColor = hexToRgba(colorHex, 0.35*combinedActivity + 0.15*strength);
        brainCtx.shadowBlur = 6 + combinedActivity*14;
      }else{
        brainCtx.shadowColor = 'transparent';
        brainCtx.shadowBlur = 0;
      }
      brainCtx.stroke();
    }
  }
  brainCtx.shadowBlur = 0;
  brainCtx.shadowColor = 'transparent';
}
function drawBrainNodes(positions, type, activations=null, activityScale=1){
  if(!brainCtx || !positions) return;
  brainCtx.save();
  const teamColor = bestBrainState.teamColor || '#2dd4bf';
  for(let i=0;i<positions.length;i++){
    const pos = positions[i];
    const value = Array.isArray(activations) ? activations[i] : null;
    const magnitude = Math.max(0, Math.min(1, (typeof value === 'number' ? Math.abs(value) : 0) * activityScale));
    const sign = (typeof value === 'number' && value < 0) ? -1 : 1;
    let radius = 8.5;
    let baseColor = '#38bdf8';
    let accentColor = '#38bdf8';
    let negativeColor = '#f472b6';
    if(type==='hidden'){
      radius = 7;
      baseColor = teamColor;
      accentColor = teamColor;
    }
    if(type==='output'){
      radius = 9.5;
      baseColor = '#f472b6';
      accentColor = '#f472b6';
      negativeColor = '#38bdf8';
    }
    const color = sign >= 0 ? baseColor : negativeColor;
    const strokeColor = sign >= 0 ? accentColor : negativeColor;
    const fillAlpha = 0.18 + magnitude*0.55;
    const strokeAlpha = 0.50 + magnitude*0.45;
    brainCtx.beginPath();
    brainCtx.fillStyle = hexToRgba(color, fillAlpha);
    brainCtx.strokeStyle = hexToRgba(strokeColor, strokeAlpha);
    brainCtx.lineWidth = 1.8;
    if(magnitude>0.02){
      brainCtx.shadowColor = hexToRgba(strokeColor, 0.45*magnitude + 0.18);
      brainCtx.shadowBlur = 8 + magnitude*18;
    } else {
      brainCtx.shadowColor = 'transparent';
      brainCtx.shadowBlur = 0;
    }
    brainCtx.arc(pos.x, pos.y, radius, 0, Math.PI*2);
    brainCtx.fill();
    brainCtx.stroke();
    brainCtx.beginPath();
    brainCtx.shadowBlur = 0;
    brainCtx.shadowColor = 'transparent';
    brainCtx.strokeStyle = 'rgba(255,255,255,0.12)';
    brainCtx.lineWidth = 1;
    brainCtx.arc(pos.x, pos.y, Math.max(1, radius-2.6), 0, Math.PI*2);
    brainCtx.stroke();
  }
  brainCtx.restore();
}
function renderBestBrain(){
  updateBrainMeta();
  if(!brainVizEnabled || !brainCanvas || !brainCtx){
    bestBrainDirty = false;
    return;
  }
  ensureBrainCanvasSizing();
  const width = brainCanvasWidth || brainCanvas.width || 560;
  const height = brainCanvasHeight || brainCanvas.height || 240;
  brainCtx.clearRect(0,0,width,height);
  const net = bestBrainState.net;
  if(!net || !Array.isArray(net.W1) || !Array.isArray(net.W2)){
    drawBrainPlaceholder(width,height);
    bestBrainDirty = false;
    return;
  }
  const inputCount = Array.isArray(net.W1?.[0]) ? net.W1[0].length : 0;
  const hiddenCount = net.W1.length;
  const outputCount = net.W2.length;
  if(!inputCount || !hiddenCount || !outputCount){
    drawBrainPlaceholder(width,height);
    bestBrainDirty = false;
    return;
  }
  const paddingX = Math.min(80, width*0.18);
  const paddingY = Math.min(40, height*0.22);
  const columnSpacing = (width - paddingX*2) / 2;
  const inputLayer = buildLayerPositions(inputCount, paddingX, paddingY, height - paddingY);
  const hiddenLayer = buildLayerPositions(hiddenCount, paddingX + columnSpacing, paddingY, height - paddingY);
  const outputLayer = buildLayerPositions(outputCount, paddingX + columnSpacing*2, paddingY, height - paddingY);
  const activations = bestBrainState.activations || null;
  const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
  let activityScale = 0.25;
  if(bestBrainState.agentRef && activations && Number.isFinite(activations.timestamp)){
    const ageMs = Math.max(0, now - activations.timestamp);
    const freshness = Math.max(0, 1 - Math.min(1, ageMs / 1600));
    activityScale = 0.25 + freshness*0.75;
  } else if(activations && Number.isFinite(activations.timestamp)){
    activityScale = 0.18;
  }
  brainCtx.save();
  brainCtx.lineCap='round';
  brainCtx.lineJoin='round';
  drawBrainConnections(inputLayer, hiddenLayer, net.W1, activations?.input, activations?.hidden, activityScale);
  drawBrainConnections(hiddenLayer, outputLayer, net.W2, activations?.hidden, activations?.output, activityScale);
  brainCtx.restore();
  drawBrainNodes(inputLayer, 'input', activations?.input, activityScale);
  drawBrainNodes(hiddenLayer, 'hidden', activations?.hidden, activityScale);
  drawBrainNodes(outputLayer, 'output', activations?.output, activityScale);
  if(outputLayer.length){
    brainCtx.save();
    brainCtx.font = '600 10px "Inter", system-ui, -apple-system, sans-serif';
    brainCtx.textAlign = 'center';
    brainCtx.textBaseline = 'bottom';
    for(let i=0;i<outputLayer.length;i++){
      const node = outputLayer[i];
      const label = OUTPUT_NODE_LABELS[i] || `Out ${i+1}`;
      brainCtx.fillStyle = 'rgba(148,163,209,0.72)';
      brainCtx.fillText(label, node.x, node.y - 16);
    }
    brainCtx.restore();
  }
  if(activations?.output && outputLayer.length === activations.output.length){
    brainCtx.save();
    brainCtx.font = '600 11px "Inter", system-ui, -apple-system, sans-serif';
    brainCtx.textAlign = 'center';
    brainCtx.textBaseline = 'top';
    for(let i=0;i<outputLayer.length;i++){
      const node = outputLayer[i];
      const value = activations.output[i];
      if(!Number.isFinite(value)) continue;
      const label = value.toFixed(2);
      brainCtx.fillStyle = value >= 0 ? 'rgba(248,250,255,0.78)' : 'rgba(148,163,209,0.78)';
      brainCtx.fillText(label, node.x, node.y + 12);
    }
    brainCtx.restore();
  }
  bestBrainDirty = false;
}
function setBestBrainFromNet(net, teamConfig, fitness, generation, agentRef=null, targetState=bestBrainState, activationsOverride=null){
  if(!targetState) return;
  if(!net || !teamConfig){
    resetBrainState(targetState, generation);
    return;
  }
  targetState.fitness = fitness;
  targetState.teamId = teamConfig.id;
  targetState.teamLabel = teamConfig.label || teamConfig.id || '';
  targetState.teamIcon = teamConfig.icon || '‚óè';
  targetState.teamColor = teamConfig.color || '#38bdf8';
  targetState.gen = Number.isFinite(generation) ? generation : evo.gen;
  targetState.net = cloneNet(net);
  targetState.agentRef = agentRef || null;
  const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
  if(activationsOverride){
    targetState.activations = activationsOverride;
    if(typeof targetState.activations.timestamp !== 'number'){
      targetState.activations.timestamp = now;
    }
  } else if(agentRef && agentRef.activationScratch){
    targetState.activations = agentRef.activationScratch;
    targetState.activations.timestamp = now;
  } else {
    targetState.activations = targetState.activations || { input:[], hidden:[], output:[], timestamp: now };
    if(!Array.isArray(targetState.activations.input)) targetState.activations.input = [];
    if(!Array.isArray(targetState.activations.hidden)) targetState.activations.hidden = [];
    if(!Array.isArray(targetState.activations.output)) targetState.activations.output = [];
    targetState.activations.timestamp = now;
  }
  if(targetState === bestBrainState){
    markBestBrainDirty();
  }
}
function trackBestBrain(agent, teamState){
  if(!agent || !teamState) return;
  const fitness = Number(agent.fitness);
  if(!Number.isFinite(fitness)) return;
  const net = agent.netRef?.net;
  if(!net) return;
  if(fitness > currentTopFitness){
    currentTopFitness = fitness;
    currentTopAgent = agent;
  }
  const teamId = teamState.config.id;
  const cache = ensureTeamBrainCache(teamId);
  if(cache){
    if(fitness > cache.fitness){
      setBestBrainFromNet(net, teamState.config, fitness, evo.gen, agent, cache);
      if(brainViewMode === 'team' && brainViewTeamId === teamId){
        setBestBrainFromNet(net, teamState.config, fitness, evo.gen, agent, bestBrainState, cache.activations);
      }
    } else if(cache.agentRef === agent && agent.activationScratch){
      cache.activations = agent.activationScratch;
    }
  }
  if(fitness > globalBrainChampion.fitness){
    setBestBrainFromNet(net, teamState.config, fitness, evo.gen, agent, globalBrainChampion);
    if(brainViewMode === 'auto'){
      setBestBrainFromNet(net, teamState.config, fitness, evo.gen, agent, bestBrainState, globalBrainChampion.activations);
    }
  } else if(globalBrainChampion.teamId === teamId && globalBrainChampion.agentRef === agent && agent.activationScratch){
    globalBrainChampion.activations = agent.activationScratch;
  }
}
params.teams.forEach((team)=>{
  evo.populations[team.id] = makePopulation(team.count);
});
resetBestBrainState(evo.gen);
function getPopulation(teamId){
  if(!evo.populations[teamId]){
    const team = params.teams.find((t)=>t.id===teamId);
    const size = team ? Math.max(0, team.count) : 0;
    evo.populations[teamId] = makePopulation(size);
  }
  return evo.populations[teamId];
}
function resizePop(){
  params.teams.forEach((team)=>{
    const pop = getPopulation(team.id);
    if(pop.length < team.count){
      while(pop.length < team.count) pop.push({ net:makeNet(), fitness:0 });
    } else if(pop.length > team.count){
      pop.length = team.count;
    }
  });
}
function evolveTeam(teamState){
  const pop = getPopulation(teamState.config.id);
  if(!pop.length) return;
  pop.sort((a,b)=> b.fitness - a.fitness);
  const eliteN=Math.max(1, Math.floor(pop.length*params.learn.elite));
  const elites=pop.slice(0,eliteN).map((e)=> cloneNet(e.net));
  const best=pop[0]?.fitness||0;
  teamState.bestFitnessCurrent = best;
  teamState.peakFitness = Math.max(teamState.peakFitness||0, best);
  bestFitnessByTeam[teamState.config.id] = teamState.peakFitness;
  const tournamentFactor = Math.max(1, params.learn.tournamentFactor || 1);
  const freshRatio = clamp(params.learn.fresh || 0, 0, 1);
  const newPop=[];
  for(let i=0;i<eliteN;i++) newPop.push({ net:cloneNet(elites[i]), fitness:0 });
  function pick(){
    const k=Math.min(pop.length, Math.max(2, Math.round(eliteN * tournamentFactor)));
    const a=pop[Math.floor(Math.random()*k)];
    const b=pop[Math.floor(Math.random()*k)];
    return (a.fitness>b.fitness?a:b).net;
  }
  while(newPop.length<pop.length){
    const pa=pick(), pb=pick();
    let child=crossover(pa,pb);
    mutateNet(child, params.learn.mut);
    newPop.push({ net:child, fitness:0 });
  }
  const freshCount = Math.min(pop.length - eliteN, Math.max(0, Math.round(pop.length * freshRatio)));
  for(let i=0;i<freshCount;i++){
    newPop[newPop.length-1-i] = { net:makeNet(), fitness:0 };
  }
  for(let i=0;i<pop.length;i++){
    pop[i].net=newPop[i].net;
    pop[i].fitness=0;
  }
}

// ===== Agent core =====
class Agent{
  constructor(x,y,color,maxSpeed,team){ this.x=x; this.y=y; this.vx=rand(-1,1); this.vy=rand(-1,1); this.color=color; this.baseSpeed=maxSpeed; this.speedFactor=1; this.minSpeedFactor=SPEED_FACTOR_MIN; this.maxSpeedFactor=SPEED_FACTOR_MAX; this.energyMultiplier=1; this.minEnergyMultiplier=ENERGY_MULTIPLIER_MIN; this.maxEnergyMultiplier=ENERGY_MULTIPLIER_MAX; this.energyMax=0; this.energy=0; this.updateMaxSpeed(); this.trail=[]; this.carry=false; this.team=team; this.side=Math.random()<0.5?-1:1; this.stuckT=0; this.wander={x:rand(-1,1), y:rand(-1,1)}; this.activationScratch={ input:[], hidden:[], output:[], timestamp:0 }; this.blockCooldown=0; this.blockHold=0; this.blockHoldBy=null; this.sensorVectors={}; this.dead=false; }
  updateMaxSpeed(){ this.maxSpeed=this.baseSpeed*this.speedFactor*this.energyMultiplier; }
  stepSpeed(v){ this.baseSpeed=v; this.updateMaxSpeed(); }
  setSpeedFactor(factor){ this.speedFactor=clamp(factor, this.minSpeedFactor, this.maxSpeedFactor); this.updateMaxSpeed(); }
  setEnergyMultiplier(mult){ const min=this.minEnergyMultiplier ?? ENERGY_MULTIPLIER_MIN; const max=this.maxEnergyMultiplier ?? ENERGY_MULTIPLIER_MAX; this.energyMultiplier=clamp(mult, min, max); this.updateMaxSpeed(); }
  enableEnergy(maxEnergy, initialEnergy=null){ this.energyMax=Math.max(0, Number(maxEnergy)||0); const start=Number.isFinite(initialEnergy)?initialEnergy:this.energyMax; this.energy=clamp(start, 0, this.energyMax); }
  adjustEnergy(amount){ if(!Number.isFinite(amount) || amount===0 || this.energyMax<=0) return this.energy; this.energy=clamp(this.energy+amount, 0, this.energyMax); return this.energy; }
  getEnergyRatio(){ if(this.energyMax<=0) return 1; return this.energy/this.energyMax; }
  adjustSpeedFactor(delta){ if(!Number.isFinite(delta) || delta===0) return; this.setSpeedFactor(this.speedFactor + delta); }
  getThrottlePercent(){ return Math.round(this.speedFactor * 100); }
  updateSensorVectors(map){
    if(!map || typeof map !== 'object'){ this.sensorVectors={}; return; }
    const next={};
    for(const [key, value] of Object.entries(map)){
      if(!value) continue;
      const vx = Number(value.x)||0;
      const vy = Number(value.y)||0;
      const magnitude = Math.hypot(vx, vy);
      const entry = { x:vx, y:vy, magnitude };
      if(value && typeof value === 'object'){
        if(value.mode) entry.mode = value.mode;
        if(value.label) entry.label = value.label;
      }
      next[key] = entry;
    }
    this.sensorVectors = next;
  }
  steerSeparation(peers, radius=18, gain=0.12){
    let sx=0,sy=0;
    const limit = radius * params.agentScale;
    for(const p of peers){
      if(p===this) continue;
      const dx=this.x-p.x, dy=this.y-p.y;
      const d=Math.hypot(dx,dy);
      if(d>0 && d<limit){ sx+=dx/(d*d); sy+=dy/(d*d); }
    }
    this.vx+=sx*gain;
    this.vy+=sy*gain;
  }
  applyWander(str=0.055, damp=0.92){ this.wander.x=this.wander.x*damp+(Math.random()*2-1)*(1-damp); this.wander.y=this.wander.y*damp+(Math.random()*2-1)*(1-damp); const wn=Math.hypot(this.wander.x,this.wander.y)||1; this.vx+=(this.wander.x/wn)*str; this.vy+=(this.wander.y/wn)*str; }
  avoidObstacles(){
    for(const o of obstacles){
      const clearance = obstacleClearance(o, this.x, this.y);
      if(!clearance) continue;
      const threshold = NAV.obstacleThreshold * params.agentScale;
      if(clearance.distance < threshold){
        const push = (threshold - clearance.distance) * NAV.avoidPushGain;
        const nx = Number.isFinite(clearance.nx) ? clearance.nx : 0;
        const ny = Number.isFinite(clearance.ny) ? clearance.ny : 0;
        this.vx += nx * push;
        this.vy += ny * push;
      }
    }
  }
  resolveObstaclePenetration(maxIter=4){
    let touched=false;
    for(let iter=0; iter<maxIter; iter++){
      let adjusted=false;
      for(const o of obstacles){
        const clearance = obstacleClearance(o, this.x, this.y);
        if(!clearance) continue;
        if(clearance.distance < 0){
          let nx = Number.isFinite(clearance.nx) ? clearance.nx : 0;
          let ny = Number.isFinite(clearance.ny) ? clearance.ny : 0;
          const mag = Math.hypot(nx, ny) || 1;
          nx /= mag;
          ny /= mag;
          const push = (-clearance.distance) + 0.5;
          this.x += nx * push;
          this.y += ny * push;
          const vn = this.vx*nx + this.vy*ny;
          if(vn < 0){
            this.vx -= vn * nx;
            this.vy -= vn * ny;
          }
          adjusted = true;
          touched = true;
        }
      }
      if(!adjusted) break;
    }
    return touched;
  }
  keepInBounds(){
    let touched=false;
    const pad = NAV.boundaryPadding * params.agentScale;
    if(this.x<pad){ this.x=pad; this.vx=Math.abs(this.vx); touched=true; }
    if(this.x>W-pad){ this.x=W-pad; this.vx=-Math.abs(this.vx); touched=true; }
    if(this.y<pad){ this.y=pad; this.vy=Math.abs(this.vy); touched=true; }
    if(this.y>H-pad){ this.y=H-pad; this.vy=-Math.abs(this.vy); touched=true; }
    return touched;
  }
  tickCooldowns(){ if(this.blockCooldown>0) this.blockCooldown--; }
  integrate(){ const sp=Math.hypot(this.vx,this.vy); if(sp>this.maxSpeed){ this.vx*=this.maxSpeed/sp; this.vy*=this.maxSpeed/sp; } this.trail.push({ x:this.x, y:this.y }); if(this.trail.length>params.tailLen) this.trail.shift(); this.x+=this.vx; this.y+=this.vy; const obstacleBefore = this.resolveObstaclePenetration(); const hitWall = this.keepInBounds(); const obstacleAfter = this.resolveObstaclePenetration(1); const touchedObstacle = obstacleBefore || obstacleAfter; const touched = touchedObstacle || hitWall; this.stuckT=(sp<0.10)?(this.stuckT+1):0; this.tickCooldowns(); return { touched, touchedObstacle, touchedWall:hitWall }; }
}

class Collector extends Agent{
  constructor(x,y,teamState,netRef){
    const cfg=teamState.config;
    super(x,y,teamState.config.color,cfg.speed,teamState.config.id);
    this.teamState=teamState;
    this.netRef=netRef;
    if(this.netRef && this.netRef.net){
      ensureNetOutputSize(this.netRef.net);
    }
    this.fitness=0;
    this.role='collector';
    this.lastPathCost = Infinity;
    this.pathProgressTicks = 0;
    this.visitedCells = new Set();
    this.cellVisitTimestamps = new Map();
    this.stuckPenaltyCooldown = 0;
    this.currentFruitTarget = null;
    this.bestFruitDistance = Infinity;
    this.fruitApproachBaseline = 0;
    this.previousDrive = { x:0, y:0 };
    this.heading = { x:1, y:0 };
    this.lastProgressStep = 0;
    this.enableEnergy(getCollectorEnergyCapacity());
    this.energyDecay = COLLECTOR_ENERGY_DECAY;
    this.maxEnergyMultiplier = ENERGY_MULTIPLIER_MAX;
    this.minEnergyMultiplier = getEnergyEmptySpeedSetting();
  }
  handleEnergyExhaustion(){
    if(this.dead) return;
    this.dead = true;
    this.vx = 0;
    this.vy = 0;
    this.energy = 0;
    if(this.visitedCells){
      this.visitedCells.clear();
    }
    if(this.cellVisitTimestamps){
      this.cellVisitTimestamps.clear();
    }
    this.currentFruitTarget = null;
    if(this.carry){
      spawnFruit(this.x, this.y);
      this.carry = false;
    }
    this.fitness -= ENERGY_DEATH_PENALTY;
    registerTeamFumble(this.teamState, -ENERGY_DEATH_PENALTY);
  }
  updateEnergyThrottle(){
    if(this.energyMax<=0) return;
    const ratio = clamp(this.getEnergyRatio(), 0, 1);
    const minMultiplier = getEnergyEmptySpeedSetting();
    const maxMultiplier = Math.max(minMultiplier, this.maxEnergyMultiplier ?? ENERGY_MULTIPLIER_MAX);
    this.minEnergyMultiplier = minMultiplier;
    const multiplier = minMultiplier + (maxMultiplier - minMultiplier) * ratio;
    this.setEnergyMultiplier(multiplier);
  }
  update(){
    if(this.dead) return;
    const cfg=this.teamState.config;
    const teamId=cfg.id;
    const wasCarrying = this.carry;
    if(this.energyMax>0){
      this.adjustEnergy(-this.energyDecay);
      if(params.dieOnEnergyLoss && this.energy <= 0){
        this.handleEnergyExhaustion();
      }
    }
    if(this.dead) return;
    this.stepSpeed(cfg.speed);
    this.updateEnergyThrottle();
    const prevDriveX = clamp(this.previousDrive?.x ?? 0, -1, 1);
    const prevDriveY = clamp(this.previousDrive?.y ?? 0, -1, 1);
    const myGoal=this.teamState.goal;
    const tgt = this.carry? myGoal : nearest(fruits, this.x, this.y);
    let tx=0,ty=0, dn=1;
    if(this.carry){
      this.currentFruitTarget = null;
      this.bestFruitDistance = Infinity;
      this.fruitApproachBaseline = 0;
    } else if(tgt){
      if(this.currentFruitTarget !== tgt){
        this.currentFruitTarget = tgt;
        this.bestFruitDistance = Infinity;
        const base = Math.hypot(myGoal.x - tgt.x, myGoal.y - tgt.y);
        this.fruitApproachBaseline = Number.isFinite(base) ? Math.max(base, 1) : 0;
      }
      const distToFruit = Math.hypot(tgt.x - this.x, tgt.y - this.y);
      if(Number.isFinite(distToFruit)){
        if(!Number.isFinite(this.bestFruitDistance)){
          this.bestFruitDistance = distToFruit;
        } else {
          const improvement = this.bestFruitDistance - distToFruit;
          if(improvement > FRUIT_APPROACH_MIN_DELTA){
            const baseline = this.fruitApproachBaseline > 0 ? this.fruitApproachBaseline : distToFruit;
            const bonusBase = Math.max(baseline, 1);
            const bonusFactor = clamp((bonusBase / FRUIT_APPROACH_BASELINE_SCALE), 0, FRUIT_APPROACH_MAX_MULTIPLIER - 1);
            const multiplier = clamp(1 + bonusFactor, 1, FRUIT_APPROACH_MAX_MULTIPLIER);
            const reward = improvement * FRUIT_APPROACH_REWARD * multiplier;
            if(Number.isFinite(reward) && reward > 0){
              this.fitness += reward;
            }
            this.bestFruitDistance = distToFruit;
          } else if(distToFruit < this.bestFruitDistance){
            this.bestFruitDistance = distToFruit;
          }
        }
      }
    } else {
      this.currentFruitTarget = null;
      this.bestFruitDistance = Infinity;
      this.fruitApproachBaseline = 0;
    }
    if(tgt){ tx=tgt.x-this.x; ty=tgt.y-this.y; dn=Math.hypot(tx,ty)||1; tx/=dn; ty/=dn; }
    let hx = this.heading?.x ?? 1;
    let hy = this.heading?.y ?? 0;
    const currentSpeed = Math.hypot(this.vx, this.vy);
    if(currentSpeed > 0.08){
      hx = this.vx / currentSpeed;
      hy = this.vy / currentSpeed;
      this.heading.x = hx;
      this.heading.y = hy;
    } else {
      const norm = Math.hypot(hx, hy) || 1;
      hx /= norm;
      hy /= norm;
      this.heading.x = hx;
      this.heading.y = hy;
    }
    const foodGrad = senseGrad(teamId, 'food', this.x, this.y);
    const homeGrad = senseGrad(teamId, 'home', this.x, this.y);
    const freshGrad = senseGrad(teamId, 'fresh', this.x, this.y);
    const activeGrad = this.carry ? homeGrad : foodGrad;
    const homeStrength = normalizePheromoneStrength(homeGrad.val, PHEROMONE_SENSOR_SCALE);
    const foodStrength = normalizePheromoneStrength(foodGrad.val, PHEROMONE_SENSOR_SCALE);
    const freshStrength = normalizePheromoneStrength(freshGrad.val, PHEROMONE_FRESH_SENSOR_SCALE);
    const gradientDelta = clamp(homeStrength - foodStrength, -1, 1);
    const mates = this.teamState.agents;
    let sx=0, sy=0;
    const separationRadius = AGENT_BASE_SEPARATION_RADIUS * params.agentScale;
    for(const p of mates){
      if(p===this) continue;
      const dx=this.x-p.x, dy=this.y-p.y;
      const d=Math.hypot(dx,dy);
      if(d>0 && d<separationRadius){ sx+=dx/(d*d); sy+=dy/(d*d); }
    }
    const obstacleVec = senseObstacleVector(this.x, this.y);
    const boundaryVec = senseBoundaryVector(this.x, this.y);
    const frontClear = raycastClearance(this.x, this.y, hx, hy);
    const leftDirX = -hy;
    const leftDirY = hx;
    const rightDirX = hy;
    const rightDirY = -hx;
    const leftClear = raycastClearance(this.x, this.y, leftDirX, leftDirY);
    const rightClear = raycastClearance(this.x, this.y, rightDirX, rightDirY);
    this.updateSensorVectors({
      target:{ x:tx, y:ty, mode:this.carry ? 'goal' : 'fruit' },
      gradient:{ x:activeGrad.gx, y:activeGrad.gy, mode:this.carry ? 'home' : 'food' },
      gradientHome:{ x:homeGrad.gx, y:homeGrad.gy, label:'Home trail' },
      gradientFood:{ x:foodGrad.gx, y:foodGrad.gy, label:'Food trail' },
      freshTrail:{ x:freshGrad.gx, y:freshGrad.gy, label:'Fresh' },
      separation:{ x:sx, y:sy },
      obstacle:{ x:obstacleVec.x, y:obstacleVec.y, label:'Obstacle' },
      boundary:{ x:boundaryVec.x, y:boundaryVec.y, label:'Bounds' },
      frontProbe:{ x:hx*frontClear, y:hy*frontClear, label:'Forward ray' },
      leftProbe:{ x:leftDirX*leftClear, y:leftDirY*leftClear, label:'Left ray' },
      rightProbe:{ x:rightDirX*rightClear, y:rightDirY*rightClear, label:'Right ray' }
    });
    const progressPressure = clamp(this.pathProgressTicks / Math.max(PATH_PROGRESS_STALL_STEPS, 1), 0, 1);
    const progressMemory = clamp((simSteps - (this.lastProgressStep || 0)) / Math.max(PATH_PROGRESS_PRESSURE_WINDOW, 1), 0, 1);
    const stuckRatio = clamp(this.stuckT / Math.max(PATH_STUCK_THRESHOLD, 1), 0, 1);
    const carryFlag = this.carry ? 1 : -1;
    const input = [
      tx,ty,
      activeGrad.gx, activeGrad.gy,
      homeStrength,
      foodStrength,
      gradientDelta,
      freshStrength,
      sx, sy,
      obstacleVec.x, obstacleVec.y,
      boundaryVec.x, boundaryVec.y,
      frontClear,
      leftClear,
      rightClear,
      progressPressure,
      progressMemory,
      stuckRatio,
      prevDriveX,
      prevDriveY,
      carryFlag,
      1.0
    ];
    const capture = this.activationScratch;
    const out = forward(this.netRef.net, input, capture);
    const nowTime = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
    capture.timestamp = nowTime;
    if(bestBrainState.agentRef === this){
      bestBrainState.activations = capture;
      if(brainVizEnabled){
        markBestBrainDirty();
      }
    }
    const driveX = Number.isFinite(out[0]) ? out[0] : 0;
    const driveY = Number.isFinite(out[1]) ? out[1] : 0;
    const accelerate = Number.isFinite(out[2]) ? out[2] : 0;
    const brake = Number.isFinite(out[3]) ? out[3] : 0;
    const throttleSignal = accelerate - brake;
    if(throttleSignal !== 0){
      this.adjustSpeedFactor(throttleSignal * SPEED_FACTOR_ADJUST);
    }
    this.previousDrive.x = clamp(driveX, -1, 1);
    this.previousDrive.y = clamp(driveY, -1, 1);
    const smartFactor = getEffectiveSmartValue(cfg);
    this.vx += driveX*(0.45 + 0.15*smartFactor) + (tx*0.15*cfg.strat);
    this.vy += driveY*(0.45 + 0.15*smartFactor) + (ty*0.15*cfg.strat);
    const pickupRadius = Math.max(AGENT_BASE_PICKUP_RADIUS * params.agentScale, 6);
    if(!this.carry && tgt && Math.hypot(tgt.x-this.x,tgt.y-this.y)<pickupRadius){
      const i=fruits.indexOf(tgt);
      if(i>-1) fruits.splice(i,1);
      this.carry=true;
      this.lastProgressStep = simSteps;
      if(this.cellVisitTimestamps){
        this.cellVisitTimestamps.clear();
      }
      markFreshFruitTrail(teamId, this.x, this.y);
      this.fitness += PICKUP_REWARD;
      awardTeamPoints(this.teamState, 'pickup', PICKUP_REWARD);
      if(this.energyMax>0){
        this.adjustEnergy(COLLECTOR_ENERGY_PICKUP_BOOST);
        this.updateEnergyThrottle();
      }
    }
    leaveCollectorTrail(this);
    if(this.stuckPenaltyCooldown > 0){
      this.stuckPenaltyCooldown--;
    }
    if(this.stuckT>35){
      this.vx += tx*(0.9+0.2*cfg.strat);
      this.vy += ty*(0.9+0.2*cfg.strat);
      this.stuckT=0;
    }
    this.avoidObstacles();
    const navStatus = this.integrate();
    if(!navStatus.touched){
      this.fitness += NAV.safeNavReward;
      if(this.energyMax>0 && Number.isFinite(this.energyDecay) && this.energyDecay>0){
        this.adjustEnergy(this.energyDecay);
      }
    }
    if(this.carry){
      rewardCollectorPathProgress(this, myGoal);
    }
    if(this.carry && Math.hypot(myGoal.x-this.x,myGoal.y-this.y)<myGoal.r){
      this.carry=false;
      myGoal.delivered++;
      this.fitness += DELIVERY_REWARD;
      awardTeamPoints(this.teamState, 'delivery', DELIVERY_REWARD);
    }
    if(this.carry && this.stuckPenaltyCooldown<=0 && this.stuckT>PATH_STUCK_THRESHOLD){
      this.fitness -= PATH_STUCK_PENALTY;
      this.stuckPenaltyCooldown = 45;
    }
    if(!this.carry){
      this.lastPathCost = Infinity;
      this.pathProgressTicks = 0;
      if(wasCarrying && this.visitedCells){
        this.visitedCells.clear();
      }
      if(wasCarrying && this.cellVisitTimestamps){
        this.cellVisitTimestamps.clear();
      }
      if(wasCarrying){
        this.lastProgressStep = simSteps;
      }
    } else if(!wasCarrying){
      this.lastPathCost = Infinity;
      this.pathProgressTicks = 0;
      if(this.visitedCells) this.visitedCells.clear();
      if(this.cellVisitTimestamps) this.cellVisitTimestamps.clear();
    }
  }
}

function rewardCollectorPathProgress(agent, goal){
  if(!agent || !goal) return;
  if(!grid || !pathCostFields) return;
  const teamId = agent.team;
  if(!teamId) return;
  const field = pathCostFields[teamId];
  if(!field || !field.length) return;
  if(!Number.isFinite(GW) || !Number.isFinite(GH) || GW<=0 || GH<=0) return;
  const cx = clampi((agent.x/CS)|0, 0, GW-1);
  const cy = clampi((agent.y/CS)|0, 0, GH-1);
  const idx = gi(cx, cy);
  if(agent.cellVisitTimestamps){
    const lastVisit = agent.cellVisitTimestamps.get(idx);
    if(Number.isFinite(lastVisit) && (simSteps - lastVisit) < PATH_LOOP_WINDOW){
      agent.fitness -= PATH_LOOP_PENALTY;
    }
    agent.cellVisitTimestamps.set(idx, simSteps);
  }
  if(agent.visitedCells){
    if(!agent.visitedCells.has(idx)){
      if(agent.visitedCells.size >= PATH_EXPLORATION_LIMIT){
        agent.visitedCells.clear();
        if(agent.cellVisitTimestamps){
          agent.cellVisitTimestamps.clear();
        }
      }
      agent.visitedCells.add(idx);
      agent.fitness += PATH_EXPLORATION_REWARD;
    }
  }
  const cost = field[idx];
  if(!Number.isFinite(cost)){
    agent.pathProgressTicks = Math.min(agent.pathProgressTicks + 1, PATH_PROGRESS_STALL_STEPS + 20);
    if(agent.pathProgressTicks > PATH_PROGRESS_STALL_STEPS){
      agent.fitness -= PATH_PROGRESS_STALL_PENALTY;
      agent.pathProgressTicks = Math.floor(PATH_PROGRESS_STALL_STEPS * 0.7);
    }
    agent.lastPathCost = Infinity;
    return;
  }
  if(!Number.isFinite(agent.lastPathCost)){
    agent.lastPathCost = cost;
    agent.pathProgressTicks = 0;
    return;
  }
  const delta = agent.lastPathCost - cost;
  if(delta > PATH_PROGRESS_MIN_DELTA){
    const losFactor = hasLineOfSight(agent.x, agent.y, goal.x, goal.y, LINE_OF_SIGHT_PADDING) ? 1 : 0.25;
    const reward = delta * PATH_PROGRESS_REWARD * losFactor;
    if(Number.isFinite(reward) && reward > 0){
      agent.fitness += reward;
    }
    if(agent.carry){
      const teamFields = grid?.[teamId];
      const homeTrailRaw = teamFields?.home ? teamFields.home[idx] : 0;
      const normalized = clamp(homeTrailRaw / Math.max(PATH_CONSOLIDATION_TRAIL_SCALE, 1e-6), 0, 1.2);
      if(normalized > PATH_CONSOLIDATION_TRAIL_THRESHOLD){
        const bonus = PATH_PROGRESS_CONSOLIDATION_BONUS * clamp(normalized, 0, 1.2);
        agent.fitness += bonus;
      }
    }
    agent.pathProgressTicks = 0;
    agent.lastProgressStep = simSteps;
  } else {
    agent.pathProgressTicks = Math.min(agent.pathProgressTicks + 1, PATH_PROGRESS_STALL_STEPS + 20);
    if(agent.pathProgressTicks > PATH_PROGRESS_STALL_STEPS){
      agent.fitness -= PATH_PROGRESS_STALL_PENALTY;
      agent.pathProgressTicks = Math.floor(PATH_PROGRESS_STALL_STEPS * 0.7);
    }
  }
  if(delta < -PATH_PROGRESS_REGRESSION_DELTA){
    agent.fitness -= PATH_PROGRESS_REGRESSION_PENALTY;
  }
  agent.lastPathCost = cost;
}

function senseObstacleVector(x, y){
  if(!obstacles.length) return { x:0, y:0 };
  const threshold = Math.max(NAV.obstacleThreshold * params.agentScale, 8);
  let bestStrength = 0;
  let bestX = 0;
  let bestY = 0;
  for(const obstacle of obstacles){
    const clearance = obstacleClearance(obstacle, x, y);
    if(!clearance) continue;
    const dist = Number.isFinite(clearance.distance) ? clearance.distance : Infinity;
    if(!Number.isFinite(dist)) continue;
    let strength = 0;
    if(dist <= 0){
      strength = 1;
    } else if(dist < threshold){
      strength = 1 - (dist / threshold);
    }
    strength = clamp(strength, 0, 1);
    if(strength > bestStrength){
      const nx = Number.isFinite(clearance.nx) ? clearance.nx : 0;
      const ny = Number.isFinite(clearance.ny) ? clearance.ny : 0;
      bestStrength = strength;
      bestX = nx * strength;
      bestY = ny * strength;
    }
  }
  return { x: bestX, y: bestY };
}

function senseBoundaryVector(x, y){
  const pad = NAV.boundaryPadding * params.agentScale;
  const innerWidth = Math.max(1, W - pad * 2);
  const innerHeight = Math.max(1, H - pad * 2);
  const leftClear = clamp((x - pad) / innerWidth, 0, 1);
  const rightClear = clamp(((W - pad) - x) / innerWidth, 0, 1);
  const topClear = clamp((y - pad) / innerHeight, 0, 1);
  const bottomClear = clamp(((H - pad) - y) / innerHeight, 0, 1);
  return {
    x: clamp(rightClear - leftClear, -1, 1),
    y: clamp(bottomClear - topClear, -1, 1)
  };
}
function raycastClearance(x, y, dirX, dirY, maxDist=RAYCAST_MAX_DISTANCE){
  if(!Number.isFinite(dirX) || !Number.isFinite(dirY)) return 0;
  const mag = Math.hypot(dirX, dirY);
  if(mag <= 1e-6) return 0;
  const nx = dirX / mag;
  const ny = dirY / mag;
  const step = Math.max(2, RAYCAST_STEP * params.agentScale);
  const padding = Math.max(AGENT_BASE_RADIUS * params.agentScale, 4);
  let dist = step;
  let lastSafe = 0;
  while(dist <= maxDist){
    const px = x + nx * dist;
    const py = y + ny * dist;
    if(px<0 || py<0 || px>W || py>H || pointInsideObstacleWithPadding(px, py, padding)){
      break;
    }
    lastSafe = dist;
    dist += step;
  }
  return clamp(lastSafe / Math.max(maxDist, 1), 0, 1);
}

class Blocker extends Agent{
  constructor(x,y,teamState,netRef){
    const cfg=teamState.config;
    super(x,y,teamState.config.color,cfg.speed,teamState.config.id);
    this.teamState = teamState;
    this.netRef = netRef;
    if(this.netRef && this.netRef.net){
      ensureNetOutputSize(this.netRef.net);
    }
    this.fitness = 0;
    this.role = 'blocker';
  }
  update(){
    if(this.dead) return;
    const cfg = this.teamState.config;
    this.stepSpeed(cfg.speed);
    const mates = this.teamState.agents;
    let closestCarrier=null, carrierDist=Infinity;
    let closestAny=null, anyDist=Infinity;
    for(const team of activeTeamStates){
      if(team===this.teamState) continue;
      for(const agent of team.agents){
        const dx = agent.x - this.x;
        const dy = agent.y - this.y;
        const dist = Math.hypot(dx,dy);
        if(dist < anyDist){ anyDist = dist; closestAny = agent; }
        if(agent.carry && dist < carrierDist){ carrierDist = dist; closestCarrier = agent; }
      }
    }
    const target = closestCarrier || closestAny;
    const dist = target ? (closestCarrier ? carrierDist : anyDist) : Infinity;
    let tx=0, ty=0;
    if(target && dist>0){ tx=(target.x-this.x)/dist; ty=(target.y-this.y)/dist; }
    let tvx=0, tvy=0;
    if(target){
      const speed = Math.hypot(target.vx, target.vy);
      if(speed>0){
        tvx = target.vx / speed;
        tvy = target.vy / speed;
      } else {
        tvx = tx;
        tvy = ty;
      }
    }
    let sx=0, sy=0;
    const separationRadius = AGENT_BASE_SEPARATION_RADIUS * params.agentScale;
    for(const p of mates){
      if(p===this) continue;
      const dx=this.x-p.x, dy=this.y-p.y;
      const d=Math.hypot(dx,dy);
      if(d>0 && d<separationRadius){ sx+=dx/(d*d); sy+=dy/(d*d); }
    }
    const obstacleVec = senseObstacleVector(this.x, this.y);
    const boundaryVec = senseBoundaryVector(this.x, this.y);
    this.updateSensorVectors({
      target:{ x:tx, y:ty, mode:closestCarrier ? 'carrier' : 'rival' },
      targetVelocity:{ x:tvx, y:tvy },
      separation:{ x:sx, y:sy },
      obstacle:{ x:obstacleVec.x, y:obstacleVec.y, label:'Obstacle' },
      boundary:{ x:boundaryVec.x, y:boundaryVec.y, label:'Bounds' }
    });
    const input = [tx, ty, tvx, tvy, sx, sy, obstacleVec.x, obstacleVec.y, boundaryVec.x, boundaryVec.y, 1.0];
    const capture = this.activationScratch;
    const out = forward(this.netRef.net, input, capture);
    const nowTime = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
    capture.timestamp = nowTime;
    if(bestBrainState.agentRef === this){
      bestBrainState.activations = capture;
      if(brainVizEnabled){
        markBestBrainDirty();
      }
    }
    const driveX = Number.isFinite(out[0]) ? out[0] : 0;
    const driveY = Number.isFinite(out[1]) ? out[1] : 0;
    const accelerate = Number.isFinite(out[2]) ? out[2] : 0;
    const brake = Number.isFinite(out[3]) ? out[3] : 0;
    const throttleSignal = accelerate - brake;
    if(throttleSignal !== 0){
      this.adjustSpeedFactor(throttleSignal * SPEED_FACTOR_ADJUST);
    }
    const smartFactor = getEffectiveSmartValue(cfg);
    this.vx += driveX*(0.50 + 0.18*smartFactor) + (tx*0.22*cfg.strat) + (tvx*0.12*smartFactor);
    this.vy += driveY*(0.50 + 0.18*smartFactor) + (ty*0.22*cfg.strat) + (tvy*0.12*smartFactor);
    if(!target){
      this.applyWander(0.035 + 0.015*cfg.strat);
    }
    if(target){
      const closeness = Math.max(0, 1 - Math.min(dist, 180)/180);
      this.fitness += closeness * 0.6;
    } else {
      this.fitness -= 0.02;
    }
    this.avoidObstacles();
    const navStatus = this.integrate();
    if(!navStatus.touched){
      this.fitness += NAV.safeNavReward;
    }
  }
}

function enforceAgentCollisions(){
  if(!params.agentCollisions || activeTeamStates.length < 1) return;
  const allAgents = [];
  for(const team of activeTeamStates){
    for(const agent of team.agents){
      if(agent.dead) continue;
      allAgents.push(agent);
    }
  }
  if(allAgents.length < 2) return;
  const agentRadius = Math.max(2.5, AGENT_BASE_RADIUS * params.agentScale);
  const minDist = Math.max(3.5, agentRadius * 2);
  for(let i=0;i<allAgents.length;i++){
    const a = allAgents[i];
    for(let j=i+1;j<allAgents.length;j++){
      const b = allAgents[j];
      let dx = b.x - a.x;
      let dy = b.y - a.y;
      let dist = Math.hypot(dx, dy);
      if(dist === 0){
        const angle = Math.random() * Math.PI * 2;
        dx = Math.cos(angle) * 0.001;
        dy = Math.sin(angle) * 0.001;
        dist = Math.hypot(dx, dy);
      }
      if(dist < minDist){
        const nx = dx / dist;
        const ny = dy / dist;
        const overlap = (minDist - dist) * 0.5;
        if(Number.isFinite(overlap)){
          a.x -= nx * overlap;
          a.y -= ny * overlap;
          b.x += nx * overlap;
          b.y += ny * overlap;

          const relVx = b.vx - a.vx;
          const relVy = b.vy - a.vy;
          const vn = relVx * nx + relVy * ny;
          if(vn < 0){
            const impulse = vn * 0.5;
            a.vx += nx * impulse;
            a.vy += ny * impulse;
            b.vx -= nx * impulse;
            b.vy -= ny * impulse;
          }
          a.keepInBounds();
          b.keepInBounds();
          a.resolveObstaclePenetration(1);
          b.resolveObstaclePenetration(1);
        }
      }
    }
  }
}

function applyBlockerInteractions(){
  if(activeTeamStates.length < 2) return;
  const blockers=[];
  const rivals=[];
  for(const team of activeTeamStates){
    for(const agent of team.agents){
      if(agent.dead) continue;
      if(agent.role === 'blocker') blockers.push(agent);
      else rivals.push(agent);
    }
  }
  if(blockers.length===0 || rivals.length===0) return;
  const blockRadius = Math.max(BLOCKER_TRIGGER_RADIUS_BASE * params.agentScale, 10);
  const blockRadiusSq = blockRadius * blockRadius;
  for(const opponent of rivals){
    if(opponent.dead) continue;
    if(!opponent.carry || opponent.blockCooldown > 0){
      opponent.blockHold = 0;
      opponent.blockHoldBy = null;
      continue;
    }
    let closestBlocker = null;
    let closestDistSq = Infinity;
    for(const blocker of blockers){
      if(blocker.dead || blocker.blockCooldown > 0) continue;
      const blockerTeamId = blocker.teamState?.config?.id;
      if(opponent.team === blockerTeamId) continue;
      const dx = opponent.x - blocker.x;
      const dy = opponent.y - blocker.y;
      const distSq = dx*dx + dy*dy;
      if(distSq > blockRadiusSq) continue;
      if(distSq < closestDistSq){
        closestDistSq = distSq;
        closestBlocker = blocker;
      }
    }
    if(!closestBlocker){
      opponent.blockHold = 0;
      opponent.blockHoldBy = null;
      continue;
    }
    if(opponent.blockHoldBy !== closestBlocker){
      opponent.blockHold = 0;
      opponent.blockHoldBy = closestBlocker;
    }
    opponent.blockHold += 1;
    if(opponent.blockHold < BLOCKER_HOLD_FRAMES) continue;
    const dist = Math.sqrt(closestDistSq);
    const proximity = 1 - Math.min(dist / blockRadius, 1);
    const reward = BLOCKER_BLOCK_REWARD * (0.6 + 0.4*proximity);
    const penalty = -BLOCKER_BLOCK_PENALTY * (0.5 + 0.5*proximity);
    spawnFruit(opponent.x, opponent.y);
    opponent.carry = false;
    opponent.blockCooldown = BLOCKER_EVENT_COOLDOWN;
    closestBlocker.blockCooldown = BLOCKER_EVENT_COOLDOWN;
    opponent.blockHold = 0;
    opponent.blockHoldBy = null;
    closestBlocker.fitness += reward;
    awardTeamPoints(closestBlocker.teamState, 'block', reward);
    if(Number.isFinite(penalty)){
      opponent.fitness += penalty;
      registerTeamFumble(opponent.teamState, penalty);
    }
  }
  for(const blocker of blockers){
    if(blocker.dead) continue;
    const blockerTeamId = blocker.teamState?.config?.id;
    for(const opponent of rivals){
      if(opponent.dead) continue;
      if(opponent.team === blockerTeamId) continue;
      if(opponent.carry) continue;
      const dx = opponent.x - blocker.x;
      const dy = opponent.y - blocker.y;
      const distSq = dx*dx + dy*dy;
      if(distSq > blockRadiusSq) continue;
      if(blocker.blockCooldown <= 0 && opponent.blockCooldown <= 0){
        const harassmentReward = BLOCKER_BLOCK_REWARD * 0.12;
        blocker.fitness += harassmentReward;
        blocker.blockCooldown = Math.floor(BLOCKER_EVENT_COOLDOWN * 0.5);
        opponent.blockCooldown = Math.floor(BLOCKER_EVENT_COOLDOWN * 0.35);
      }
    }
  }
}

// ===== Setup & loop =====
const initialTimestamp = getNow();
let simAccumulatorMs = 0;
let simTimeMs = 0;
let lastSpawnSimMs = 0;
let lastFrameTime = initialTimestamp;
function setup(){
  fruits.length=0;
  activeTeamStates=[];
  const activeTeams = params.teams.filter((team)=> team.active);
  if(activeTeams.length===0){
    params.teams[0].active = true;
    activeTeams.push(params.teams[0]);
    renderTeamRoster();
  }
  makeGrid();
  if(obstacles.length===0){ makeObstacles(params.obstacles); }
  resizePop();
  params.teams.forEach((team)=>{
    resetGoalDelivery(team.id);
    const board = getTeamScoreData(team.id);
    board.score = 0;
    board.pickups = 0;
    board.deliveries = 0;
    board.blocks = 0;
    board.fumbles = 0;
    updateTeamScoreDisplay(team.id);
  });
  for(let i=0;i<params.maxFruits;i++) spawnFruit();
  activeTeamStates = activeTeams.map((team)=>{
    const population = getPopulation(team.id);
    const goal = ensureGoalState(team.id);
    goal.delivered = 0;
    const state = {
      config:team,
      population,
      agents:[],
      goal,
      bestFitnessCurrent:0,
      peakFitness:bestFitnessByTeam[team.id]||0,
      scoreboard:getTeamScoreData(team.id)
    };
    return state;
  });
  activeTeamStates.forEach((state)=>{
    const spawnConfig = state.config.spawn || {};
    const spawnAreas = Array.isArray(spawnConfig.areas) && spawnConfig.areas.length
      ? spawnConfig.areas
      : null;
    const spawn = spawnAreas
      ? spawnAreas[Math.floor(Math.random() * spawnAreas.length)]
      : spawnConfig;
    const minX = (spawn.x?.[0] ?? 0.1) * W;
    const maxX = (spawn.x?.[1] ?? 0.9) * W;
    const minY = (spawn.y?.[0] ?? 0.1) * H;
    const maxY = (spawn.y?.[1] ?? 0.9) * H;
    const goal = state.goal;
    const agentPadding = Math.max(AGENT_BASE_RADIUS * params.agentScale, 4);
    let spawnMinX = clamp(minX, agentPadding, W - agentPadding);
    let spawnMaxX = clamp(maxX, agentPadding, W - agentPadding);
    let spawnMinY = clamp(minY, agentPadding, H - agentPadding);
    let spawnMaxY = clamp(maxY, agentPadding, H - agentPadding);
    if(spawnMinX > spawnMaxX){
      const center = clamp(goal?.x ?? W/2, agentPadding, W - agentPadding);
      spawnMinX = Math.max(agentPadding, center - agentPadding * 2);
      spawnMaxX = Math.min(W - agentPadding, center + agentPadding * 2);
    }
    if(spawnMinY > spawnMaxY){
      const center = clamp(goal?.y ?? H/2, agentPadding, H - agentPadding);
      spawnMinY = Math.max(agentPadding, center - agentPadding * 2);
      spawnMaxY = Math.min(H - agentPadding, center + agentPadding * 2);
    }
    for(let i=0;i<state.config.count;i++){
      const netRef = state.population[i] || { net:makeNet(), fitness:0 };
      if(!state.population[i]) state.population[i] = netRef;
      netRef.fitness = 0;
      const AgentClass = state.config.role === 'blocker' ? Blocker : Collector;
      let spawnX = rand(spawnMinX, spawnMaxX);
      let spawnY = rand(spawnMinY, spawnMaxY);
      if(goal){
        const maxRadius = Math.max(0, goal.r - agentPadding);
        if(maxRadius === 0){
          spawnX = clamp(goal.x, agentPadding, W - agentPadding);
          spawnY = clamp(goal.y, agentPadding, H - agentPadding);
        } else {
          const minRadius = Math.max(0, maxRadius * 0.35);
          const radius = minRadius + Math.random() * (maxRadius - minRadius);
          const angle = Math.random() * Math.PI * 2;
          spawnX = clamp(goal.x + Math.cos(angle) * radius, agentPadding, W - agentPadding);
          spawnY = clamp(goal.y + Math.sin(angle) * radius, agentPadding, H - agentPadding);
        }
      }
      const agent = new AgentClass(
        clamp(spawnX, agentPadding, W - agentPadding),
        clamp(spawnY, agentPadding, H - agentPadding),
        state,
        netRef
      );
      state.agents.push(agent);
    }
  });
  markPathCostDirty();
  lastSpawnSimMs = simTimeMs;
  simAccumulatorMs = 0;
  lastFrameTime = getNow();
  refreshStats();
}

function drawTrail(trail,color,lineWidth){
  if(trail.length<2) return;
  ctx.lineWidth = lineWidth;
  const grad=ctx.createLinearGradient(trail[0].x,trail[0].y,trail[trail.length-1].x,trail[trail.length-1].y);
  grad.addColorStop(0,'rgba(255,255,255,0)');
  grad.addColorStop(1,color);
  ctx.strokeStyle=grad;
  ctx.beginPath();
  ctx.moveTo(trail[0].x,trail[0].y);
  for(let i=1;i<trail.length;i++) ctx.lineTo(trail[i].x,trail[i].y);
  ctx.stroke();
}
function drawGoal(teamState){
  const g = teamState.goal;
  const tint = teamState.config.color;
  ctx.beginPath();
  ctx.arc(g.x,g.y,g.r,0,Math.PI*2);
  ctx.fillStyle=COLORS.goalFill;
  ctx.fill();
  ctx.save();
  ctx.strokeStyle=tint;
  ctx.lineWidth = 4; // static
  ctx.shadowColor='transparent';
  ctx.shadowBlur=0;
  ctx.stroke();
  ctx.restore();
  ctx.fillStyle='#fff';
  ctx.textAlign='center';
  ctx.textBaseline='middle';
  const scoreboard = teamState.scoreboard || getTeamScoreData(teamState.config?.id);
  const ringValue = teamState.config.role === 'blocker'
    ? (scoreboard?.blocks ?? 0)
    : g.delivered;
  ctx.font='bold 18px ui-sans-serif';
  ctx.fillText(String(ringValue), g.x, g.y);
}

function drawObstacleShape(o, time, preview=false){
  const paletteIndex = (typeof o.paletteIndex === 'number') ? o.paletteIndex : 0;
  const palette = OBSTACLE_COLORS[paletteIndex % OBSTACLE_COLORS.length];
  const phase = (typeof o.phase === 'number') ? o.phase : 0;
  const pulse = preview ? 0.3 + 0.2*Math.sin(time*0.9 + phase) : 0.45 + 0.35*Math.sin(time*0.9 + phase);
  const fillAlpha = preview ? 0.06 + 0.08*pulse : 0.10 + 0.14*pulse;
  const strokeAlpha = preview ? 0.45 : 0.6 + 0.3*pulse;
  const shadowAlpha = preview ? 0.16 : 0.35*pulse;
  ctx.save();
  ctx.shadowColor = hexToRgba(palette, shadowAlpha);
  ctx.shadowBlur = preview ? 10 : 18*pulse;
  const applyStroke = ()=>{ ctx.strokeStyle = hexToRgba(palette, strokeAlpha); };
  switch(o.type){
    case 'rect':{
      const halfW = o.width/2;
      const halfH = o.height/2;
      ctx.fillStyle = hexToRgba(palette, fillAlpha);
      applyStroke();
      ctx.lineWidth = (preview?1.6:2.2) + 0.8*pulse;
      ctx.setLineDash(preview ? [8,6] : []);
      ctx.beginPath();
      ctx.rect(o.x - halfW, o.y - halfH, o.width, o.height);
      ctx.fill();
      ctx.stroke();
      break;
    }
    case 'line':{
      ctx.shadowColor = preview ? hexToRgba(LINE_OBSTACLE_COLOR, 0.45) : hexToRgba(LINE_OBSTACLE_COLOR, 0.85);
      ctx.shadowBlur = preview ? 8 : 22;
      ctx.strokeStyle = preview ? hexToRgba(LINE_OBSTACLE_COLOR, 0.78) : LINE_OBSTACLE_COLOR;
      ctx.lineWidth = Math.max(4, o.thickness || 14);
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.setLineDash([]);
      ctx.beginPath();
      ctx.moveTo(o.x1, o.y1);
      ctx.lineTo(o.x2, o.y2);
      ctx.stroke();
      break;
    }
    case 'half':{
      const start = o.angle - Math.PI/2;
      const end = o.angle + Math.PI/2;
      const startX = o.x + Math.cos(start)*o.r;
      const startY = o.y + Math.sin(start)*o.r;
      ctx.fillStyle = hexToRgba(palette, fillAlpha);
      applyStroke();
      ctx.lineWidth = (preview?1.6:2.3) + 0.8*pulse;
      ctx.setLineDash(preview ? [8,6] : []);
      ctx.beginPath();
      ctx.moveTo(startX, startY);
      ctx.arc(o.x, o.y, o.r, start, end);
      ctx.lineTo(startX, startY);
      ctx.fill();
      ctx.stroke();
      break;
    }
    default:{
      const radius = o.r || getObstacleRadius(o);
      ctx.fillStyle = hexToRgba(palette, fillAlpha);
      applyStroke();
      ctx.lineWidth = 2.1 + 0.9*pulse;
      ctx.setLineDash(preview ? [8,6] : []);
      ctx.beginPath();
      ctx.arc(o.x, o.y, radius, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
      break;
    }
  }
  ctx.restore();
}

function drawTopAgentHighlight(agent, radius){
  if(!params.showTopHighlight) return;
  if(!agent) return;
  const haloRadius = radius + Math.max(4, radius * 0.6);
  ctx.save();
  ctx.lineWidth = Math.max(2, radius * 0.9);
  ctx.strokeStyle = 'rgba(251,191,36,0.85)';
  ctx.shadowColor = 'rgba(251,191,36,0.65)';
  ctx.shadowBlur = 16;
  ctx.beginPath();
  ctx.arc(agent.x, agent.y, haloRadius, 0, Math.PI*2);
  ctx.stroke();
  ctx.restore();

  ctx.save();
  const crownSize = Math.max(16, radius * 3.4);
  ctx.font = `600 ${crownSize}px "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji", "Twemoji Mozilla", sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'bottom';
  ctx.shadowColor = 'rgba(251,191,36,0.6)';
  ctx.shadowBlur = 10;
  ctx.fillText('üëë', agent.x, agent.y - radius - 6);
  ctx.restore();
}

function getSensorStrokeColor(key, vec, agent){
  if(key==='target'){
    if(vec?.mode === 'goal' || vec?.mode === 'carrier') return 'rgba(251,191,36,0.9)';
    return 'rgba(56,189,248,0.9)';
  }
  if(key==='gradient'){
    return vec?.mode === 'home' ? 'rgba(251,191,36,0.7)' : 'rgba(45,212,191,0.9)';
  }
  if(key==='separation') return 'rgba(244,114,182,0.85)';
  if(key==='targetVelocity') return 'rgba(167,139,250,0.88)';
  if(key==='obstacle') return 'rgba(248,113,113,0.88)';
  if(key==='boundary') return 'rgba(96,165,250,0.82)';
  return agent?.teamState?.config?.color || 'rgba(148,163,209,0.7)';
}

function drawAgentSensors(agent){
  if(!params.showSensorRadar) return;
  const sensorVectors = agent?.sensorVectors;
  if(!sensorVectors) return;
  let initialized = false;
  for(const key in sensorVectors){
    if(!Object.prototype.hasOwnProperty.call(sensorVectors, key)) continue;
    const vec = sensorVectors[key];
    if(!vec) continue;
    const magnitude = Number.isFinite(vec.magnitude) ? vec.magnitude : Math.hypot(vec.x||0, vec.y||0);
    if(!magnitude || magnitude <= 0.0001) continue;
    const nx = vec.x / magnitude;
    const ny = vec.y / magnitude;
    if(!Number.isFinite(nx) || !Number.isFinite(ny)) continue;
    if(!initialized){
      ctx.save();
      ctx.lineCap='round';
      ctx.lineJoin='round';
      initialized = true;
    }
    const scale = params.agentScale || 1;
    const clampedMag = Math.min(1.5, Math.abs(magnitude));
    const length = (28 + clampedMag * 36) * scale;
    const tipX = agent.x + nx * length;
    const tipY = agent.y + ny * length;
    const stroke = getSensorStrokeColor(key, vec, agent);
    ctx.strokeStyle = stroke;
    ctx.lineWidth = Math.max(1.2, 1.4 * scale + clampedMag);
    ctx.beginPath();
    ctx.moveTo(agent.x, agent.y);
    ctx.lineTo(tipX, tipY);
    ctx.stroke();
    ctx.beginPath();
    ctx.fillStyle = stroke;
    ctx.arc(tipX, tipY, 3 + clampedMag * 1.8, 0, TAU);
    ctx.fill();
  }
  if(initialized){
    ctx.restore();
  }
}

function draw(){
  ctx.clearRect(0,0,W,H);

  // Goals (static, no blinking)
  for(const team of activeTeamStates){
    drawGoal(team);
  }

  // Obstacles (ambient pulse)
  const t = performance.now()*0.001;
  for(const o of obstacles){
    drawObstacleShape(o, t, false);
  }
  if(drawingState){
    const preview = buildObstacleFromState(drawingState, true);
    if(preview){
      preview.paletteIndex = manualPaletteCursor % OBSTACLE_COLORS.length;
      drawObstacleShape(preview, t, true);
    }
  }

  // Fruits
  for(const f of fruits){
    ctx.beginPath();
    ctx.arc(f.x,f.y,f.r,0,Math.PI*2);
    ctx.fillStyle=COLORS.fruit;
    ctx.fill();
    ctx.lineWidth=1.5;
    ctx.strokeStyle=COLORS.fruitOutline;
    ctx.stroke();
  }

  // Agents (no shadow flash)
  const agentRadius = Math.max(2.5, AGENT_BASE_RADIUS * params.agentScale);
  const outlineWidth = Math.max(1.2, 2*params.agentScale);
  const carryOutlineWidth = Math.max(1.5, outlineWidth + 0.6*params.agentScale);
  const energyRingOffset = Math.max(2.5, 2.2 * params.agentScale);
  const energyRingRadius = agentRadius + energyRingOffset;
  const energyRingLineWidth = Math.max(1.2, 1.6 * params.agentScale);
  const trailLineWidth = Math.max(1.2, AGENT_TRAIL_WIDTH * params.agentScale);
  const highlightedAgent = (!currentTopAgent || currentTopAgent.dead) ? null : currentTopAgent;
  for(const team of activeTeamStates){
    const outline = team.config.outline || '#0f172a';
    for(const a of team.agents){
      const isDead = !!a.dead;
      if(!isDead){
        drawAgentSensors(a);
      }
      ctx.beginPath();
      ctx.arc(a.x,a.y,agentRadius,0,Math.PI*2);
      ctx.fillStyle = isDead ? 'rgba(148,163,209,0.28)' : team.config.color;
      ctx.fill();
      ctx.lineWidth=outlineWidth;
      ctx.strokeStyle = isDead ? 'rgba(71,85,105,0.85)' : outline;
      ctx.stroke();
      if(!isDead && a.carry){
        ctx.lineWidth=carryOutlineWidth;
        ctx.strokeStyle='#ffff33';
        ctx.stroke();
      }
      if(!isDead && a.energyMax>0 && params.showEnergyHalo){
        const ratio = clamp(a.energy / (a.energyMax||1), 0, 1);
        ctx.beginPath();
        ctx.arc(a.x, a.y, energyRingRadius, -Math.PI/2, -Math.PI/2 + TAU*ratio);
        ctx.lineWidth = energyRingLineWidth;
        ctx.strokeStyle = 'rgba(250,204,21,0.85)';
        ctx.stroke();
      }
      if(!performanceModeActive && !isDead){
        drawTrail(a.trail, team.config.color, trailLineWidth);
      }
      if(!isDead && params.showTopHighlight && highlightedAgent && a === highlightedAgent){
        drawTopAgentHighlight(a, agentRadius);
      }
    }
  }
}

let simSteps=0, forceNextGen=false, awaitingManualAdvance=false;

function resetTraining(preserveObstacles=false){
  const savedObstacles = preserveObstacles ? captureObstacleSnapshot() : null;
  evo.gen = 1;
  simSteps = 0;
  forceNextGen = false;
  awaitingManualAdvance = false;
  for(const key of Object.keys(bestFitnessByTeam)){
    delete bestFitnessByTeam[key];
  }
  evo.populations = {};
  params.teams.forEach((team)=>{
    const count = Math.max(0, Math.round(team.count));
    evo.populations[team.id] = makePopulation(count);
  });
  resetBestBrainState(evo.gen);
  if(savedObstacles){
    try{
      applyObstacleSnapshot(savedObstacles, { updateControls:false });
    }catch(err){
      console.error('Failed to restore preserved obstacles during reset', err);
    }
  } else {
    obstacles.length = 0;
    lastObstCount = params.obstacles;
  }
  setup();
  syncManualObstacleState();
  markPathCostDirty();
  markBestBrainDirty();
  renderBestBrain();
  refreshStats();
}

function advanceGeneration(){
  for(const teamState of activeTeamStates){
    const pop = getPopulation(teamState.config.id);
    for(let i=0;i<teamState.agents.length && i<pop.length;i++){
      pop[i].fitness += teamState.agents[i].fitness;
    }
    evolveTeam(teamState);
  }
  evo.gen++;
  simSteps=0;
  forceNextGen=false;
  awaitingManualAdvance=false;
  setup();
}
function runSimulationStep(){
  currentTopAgent = null;
  currentTopFitness = -Infinity;
  updatePathCostsIfNeeded();
  for(const team of activeTeamStates){
    for(const agent of team.agents){
      agent.update();
      if(agent.dead) continue;
      trackBestBrain(agent, team);
    }
  }
  enforceAgentCollisions();
  applyBlockerInteractions();
  evaporate();
  const spawnInterval = Math.max(1, Number.isFinite(params.spawnMs) ? params.spawnMs : 0);
  while(simTimeMs - lastSpawnSimMs >= spawnInterval){
    spawnFruit();
    lastSpawnSimMs += spawnInterval;
  }
  simSteps++;

  const reachedLimit = simSteps>=params.learn.genSteps;
  if(forceNextGen || (reachedLimit && params.learn.auto)){
    advanceGeneration();
    return;
  }
  if(reachedLimit){
    awaitingManualAdvance=true;
  }
}
function loop(){
  requestAnimationFrame(loop);

  if(awaitingManualAdvance){
    if(forceNextGen){
      advanceGeneration();
    }
    lastFrameTime = getNow();
    return;
  }

  const now = getNow();
  let frameDelta = now - lastFrameTime;
  if(!Number.isFinite(frameDelta) || frameDelta < 0){
    frameDelta = 0;
  }
  if(frameDelta > MAX_FRAME_DELTA_MS){
    frameDelta = MAX_FRAME_DELTA_MS;
  }
  lastFrameTime = now;

  const desiredSpeed = Number(params.simSpeed);
  const speedMultiplier = clamp(Number.isFinite(desiredSpeed) ? desiredSpeed : 1, SIM_SPEED_MIN, SIM_SPEED_MAX);
  simAccumulatorMs += frameDelta * speedMultiplier;

  let steps = 0;
  const stepLimit = MAX_SIM_STEPS_PER_FRAME;
  while(simAccumulatorMs >= SIMULATION_STEP_MS && steps < stepLimit && !awaitingManualAdvance){
    simAccumulatorMs -= SIMULATION_STEP_MS;
    simTimeMs += SIMULATION_STEP_MS;
    runSimulationStep();
    steps++;
    if(forceNextGen || awaitingManualAdvance){
      break;
    }
  }
  if(steps >= stepLimit){
    simAccumulatorMs = 0;
  }

  draw();
  refreshStats();
  if(bestBrainDirty){
    renderBestBrain();
  }
}

function applyBestFitnessSnapshot(bestMap){
  if(!bestMap) return;
  for(const [teamId, value] of Object.entries(bestMap)){
    const numeric = Number(value);
    if(!Number.isFinite(numeric)) continue;
    bestFitnessByTeam[teamId] = numeric;
  }
  for(const team of activeTeamStates){
    const stored = bestFitnessByTeam[team.config.id];
    if(Number.isFinite(stored)){
      team.peakFitness = Math.max(team.peakFitness||0, stored);
    }
  }
  refreshStats();
}

function captureTrainingSnapshot(){
  readParams();
  const paramsClone = JSON.parse(JSON.stringify(params));
  const evoTeams = params.teams.map((team)=>{
    const population = getPopulation(team.id);
    return {
      id:team.id,
      active:!!team.active,
      members:population.map((member)=> ({ net:cloneNet(member.net), fitness:member.fitness||0 }))
    };
  });
  return {
    version:2,
    savedAt:new Date().toISOString(),
    params:paramsClone,
    evo:{
      gen:evo.gen,
      teams:evoTeams
    },
    best:Object.fromEntries(Object.entries(bestFitnessByTeam))
  };
}

// Object URL management for downloads
let currentObjectUrl = null;
let currentObjectUrlToken = 0;

function setCurrentObjectUrl(url){
  clearCurrentObjectUrl();
  currentObjectUrl = url;
  currentObjectUrlToken++;
  return { url, token: currentObjectUrlToken };
}

function clearCurrentObjectUrl(expectedToken=null){
  if(expectedToken != null && expectedToken !== currentObjectUrlToken) return;
  if(currentObjectUrl){
    try{ URL.revokeObjectURL(currentObjectUrl); }catch(_err){ /* ignore */ }
    currentObjectUrl = null;
  }
}

function downloadTrainingData(){
  try{
    const snapshot = captureTrainingSnapshot();
    const json = JSON.stringify(snapshot, null, 2);
    const blob = new Blob([json], { type:'application/json' });
    const { url, token } = setCurrentObjectUrl(URL.createObjectURL(blob));
    const genStr = String(snapshot.evo?.gen ?? 1).padStart(3, '0');
    const link = document.createElement('a');
    link.href = url;
    link.download = `foodsim-training-gen${genStr}.json`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    setTimeout(()=> clearCurrentObjectUrl(token), 1000);
  }catch(err){
    console.error('Failed to export training data', err);
    alert('Could not save training data. Please try again.');
  }
}

function sanitizeNumber(value, fallback=0){
  const numeric = Number(value);
  return Number.isFinite(numeric) ? numeric : fallback;
}

function normalizePaletteIndex(index){
  const numeric = Math.round(sanitizeNumber(index, 0));
  const len = OBSTACLE_COLORS.length || 1;
  return ((numeric % len) + len) % len;
}

function serializeObstacle(obstacle){
  if(!obstacle || typeof obstacle !== 'object') return null;
  const type = typeof obstacle.type === 'string' ? obstacle.type : 'circle';
  const base = {
    type,
    manual: !!obstacle.manual,
    persistent: !!obstacle.persistent,
    paletteIndex: sanitizeNumber(obstacle.paletteIndex, 0),
    phase: sanitizeNumber(obstacle.phase, Math.random()*TAU)
  };
  switch(type){
    case 'rect':{
      base.x = sanitizeNumber(obstacle.x, W/2);
      base.y = sanitizeNumber(obstacle.y, H/2);
      base.width = Math.max(2, sanitizeNumber(obstacle.width, 20));
      base.height = Math.max(2, sanitizeNumber(obstacle.height, 20));
      break;
    }
    case 'line':{
      const x1 = sanitizeNumber(obstacle.x1, obstacle.x || 0);
      const y1 = sanitizeNumber(obstacle.y1, obstacle.y || 0);
      const x2 = sanitizeNumber(obstacle.x2, obstacle.x || 0);
      const y2 = sanitizeNumber(obstacle.y2, obstacle.y || 0);
      base.x = sanitizeNumber(obstacle.x, (x1 + x2) / 2);
      base.y = sanitizeNumber(obstacle.y, (y1 + y2) / 2);
      base.x1 = x1;
      base.y1 = y1;
      base.x2 = x2;
      base.y2 = y2;
      base.thickness = Math.max(2, sanitizeNumber(obstacle.thickness, 14));
      break;
    }
    case 'half':{
      base.x = sanitizeNumber(obstacle.x, W/2);
      base.y = sanitizeNumber(obstacle.y, H/2);
      base.r = Math.max(4, sanitizeNumber(obstacle.r, 24));
      base.angle = sanitizeNumber(obstacle.angle, 0);
      break;
    }
    default:{
      base.x = sanitizeNumber(obstacle.x, W/2);
      base.y = sanitizeNumber(obstacle.y, H/2);
      base.r = Math.max(4, sanitizeNumber(obstacle.r, 18));
      break;
    }
  }
  return base;
}

function deserializeObstacle(entry){
  if(!entry || typeof entry !== 'object') return null;
  const type = typeof entry.type === 'string' ? entry.type : 'circle';
  const manual = !!entry.manual;
  const persistent = !!entry.persistent;
  const paletteIndex = normalizePaletteIndex(entry.paletteIndex);
  const phase = sanitizeNumber(entry.phase, Math.random()*TAU);
  switch(type){
    case 'rect':{
      const width = Math.max(2, sanitizeNumber(entry.width, 20));
      const height = Math.max(2, sanitizeNumber(entry.height, 20));
      const x = sanitizeNumber(entry.x, W/2);
      const y = sanitizeNumber(entry.y, H/2);
      return { type:'rect', x, y, width, height, manual, paletteIndex, phase, persistent };
    }
    case 'line':{
      const x1 = sanitizeNumber(entry.x1, sanitizeNumber(entry.x, 0));
      const y1 = sanitizeNumber(entry.y1, sanitizeNumber(entry.y, 0));
      const x2 = sanitizeNumber(entry.x2, sanitizeNumber(entry.x, 0));
      const y2 = sanitizeNumber(entry.y2, sanitizeNumber(entry.y, 0));
      const x = sanitizeNumber(entry.x, (x1 + x2) / 2);
      const y = sanitizeNumber(entry.y, (y1 + y2) / 2);
      const thickness = Math.max(2, sanitizeNumber(entry.thickness, 14));
      return { type:'line', x, y, x1, y1, x2, y2, thickness, manual, paletteIndex, phase, persistent };
    }
    case 'half':{
      const x = sanitizeNumber(entry.x, W/2);
      const y = sanitizeNumber(entry.y, H/2);
      const r = Math.max(4, sanitizeNumber(entry.r, 24));
      const angle = sanitizeNumber(entry.angle, 0);
      return { type:'half', x, y, r, angle, manual, paletteIndex, phase, persistent };
    }
    default:{
      const x = sanitizeNumber(entry.x, W/2);
      const y = sanitizeNumber(entry.y, H/2);
      const r = Math.max(4, sanitizeNumber(entry.r, 18));
      return { type:'circle', x, y, r, manual, paletteIndex, phase, persistent };
    }
  }
}

function captureObstacleSnapshot(){
  const serialized = obstacles.map(serializeObstacle).filter(Boolean);
  const autoCount = serialized.reduce((total, entry)=> total + (entry.manual ? 0 : 1), 0);
  return {
    version:1,
    savedAt:new Date().toISOString(),
    width:W,
    height:H,
    autoCount,
    obstacles:serialized
  };
}

function applyObstacleSnapshot(snapshot, options={}){
  const { updateControls=true } = options;
  const entries = Array.isArray(snapshot) ? snapshot : (Array.isArray(snapshot?.obstacles) ? snapshot.obstacles : null);
  if(!entries){
    throw new Error('Obstacle file does not contain an obstacles list.');
  }
  const restored = [];
  entries.forEach((entry)=>{
    const obstacle = deserializeObstacle(entry);
    if(obstacle){
      keepObstacleInside(obstacle);
      restored.push(obstacle);
    }
  });
  obstacles.length = 0;
  restored.forEach((ob)=> obstacles.push(ob));

  const inferredAuto = restored.reduce((total, entry)=> total + (entry.manual ? 0 : 1), 0);
  const autoCount = Number.isFinite(snapshot?.autoCount) ? sanitizeNumber(snapshot.autoCount, inferredAuto) : inferredAuto;
  params.obstacles = Math.max(0, Math.round(autoCount));
  lastObstCount = params.obstacles;
  if(updateControls){
    const slider = Q('slObst');
    if(slider){
      const min = sanitizeNumber(slider.min, 0);
      const max = sanitizeNumber(slider.max, params.obstacles);
      const clamped = Math.max(min, Math.min(max, params.obstacles));
      slider.value = String(clamped);
      const label = Q('lbObst');
      if(label) label.textContent = params.obstacles;
    }
  }
  syncManualObstacleState();
  markPathCostDirty();
  return restored;
}

function downloadObstacleData(){
  try{
    const snapshot = captureObstacleSnapshot();
    const json = JSON.stringify(snapshot, null, 2);
    const blob = new Blob([json], { type:'application/json' });
    const { url, token } = setCurrentObjectUrl(URL.createObjectURL(blob));
    const stamp = snapshot.savedAt.replace(/[:.]/g, '-');
    const link = document.createElement('a');
    link.href = url;
    link.download = `foodsim-obstacles-${stamp}.json`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    setTimeout(()=> clearCurrentObjectUrl(token), 1000);
  }catch(err){
    console.error('Failed to export obstacles', err);
    alert('Could not save obstacles. Please try again.');
  }
}

function handleObstacleFileSelection(evt){
  const input = evt.target;
  const file = input?.files?.[0];
  if(input) input.value = '';
  if(!file) return;
  const reader = new FileReader();
  reader.onload = ()=>{
    try{
      const parsed = JSON.parse(reader.result);
      applyObstacleSnapshot(parsed);
    }catch(err){
      console.error('Failed to load obstacles file', err);
      alert('Could not load obstacles. Please ensure the file was exported from this simulator.');
    }
  };
  reader.onerror = ()=>{
    console.error('Unable to read the selected obstacles file', reader.error);
    alert('Could not read the selected file.');
  };
  reader.readAsText(file);
}

function applyParamsSnapshot(snapshot){
  if(!snapshot) return;
  if(snapshot.maxFruits != null) setRangeValue('slFruits', snapshot.maxFruits);
  if(snapshot.spawnMs != null) setRangeValue('slSpawn', snapshot.spawnMs);
  if(snapshot.simSpeed != null){
    const normalized = clamp(snapshot.simSpeed, SIM_SPEED_MIN, SIM_SPEED_MAX);
    setRangeValue('slSimSpeed', Math.round(normalized * 100));
  }
  if(snapshot.obstacles != null) setRangeValue('slObst', snapshot.obstacles);
  if(snapshot.tailLen != null) setRangeValue('slTail', snapshot.tailLen);
  if(snapshot.agentScale != null) setRangeValue('slAgentScale', Math.round(snapshot.agentScale*100));
  if(snapshot.energyEmptySpeed != null){
    const normalized = clamp(snapshot.energyEmptySpeed, ENERGY_MULTIPLIER_MIN, ENERGY_MULTIPLIER_MAX);
    setRangeValue('slEnergyEmptySpeed', Math.round(normalized*100));
  }
  if(snapshot.energyCapacity != null){
    const capacity = clamp(snapshot.energyCapacity, COLLECTOR_ENERGY_CAPACITY_MIN, COLLECTOR_ENERGY_CAPACITY_MAX);
    setRangeValue('slEnergyCapacity', Math.round(capacity));
  }
  if(snapshot.awarenessBoost != null){
    const percent = clamp(snapshot.awarenessBoost, AWARENESS_BOOST_MIN, AWARENESS_BOOST_MAX) * 100;
    setRangeValue('slAwarenessBoost', Math.round(percent));
  }
  if(snapshot.agentCollisions !== undefined){
    const toggle = Q('chkAgentCollisions');
    if(toggle){
      toggle.checked = !!snapshot.agentCollisions;
      toggle.dispatchEvent(new Event('change', { bubbles:true }));
    }
  }

  if(snapshot.showTopHighlight !== undefined){
    const toggle = Q('chkTopHighlight');
    if(toggle){
      toggle.checked = !!snapshot.showTopHighlight;
      toggle.dispatchEvent(new Event('change', { bubbles:true }));
    }
  }

  if(snapshot.showEnergyHalo !== undefined){
    const toggle = Q('chkEnergyHalo');
    if(toggle){
      toggle.checked = !!snapshot.showEnergyHalo;
      toggle.dispatchEvent(new Event('change', { bubbles:true }));
    }
  }

  if(snapshot.dieOnEnergyLoss !== undefined){
    const toggle = Q('chkEnergyDeath');
    if(toggle){
      toggle.checked = !!snapshot.dieOnEnergyLoss;
      toggle.dispatchEvent(new Event('change', { bubbles:true }));
    }
  }

  if(typeof snapshot.fruitPlacement === 'string'){
    setFruitPlacement(snapshot.fruitPlacement, false);
  }

  if(Array.isArray(snapshot.teams) && snapshot.teams.length){
    const toNumber = (value)=>{
      const numeric = Number(value);
      return Number.isFinite(numeric) ? numeric : null;
    };
    snapshot.teams.forEach((teamSnapshot)=>{
      const target = params.teams.find((t)=>t.id===teamSnapshot.id);
      if(!target) return;
      const count = toNumber(teamSnapshot.count);
      if(count != null) target.count = count;
      const speed = toNumber(teamSnapshot.speed);
      if(speed != null) target.speed = speed;
      const smart = toNumber(teamSnapshot.smart);
      if(smart != null) target.smart = smart;
      const strat = toNumber(teamSnapshot.strat);
      if(strat != null) target.strat = strat;
      const sep = toNumber(teamSnapshot.sep);
      if(sep != null) target.sep = sep;
      if(teamSnapshot.active !== undefined) target.active = !!teamSnapshot.active;
    });
    renderTeamRoster();
    resizePop();
  } else {
    const refTeam = snapshot.green || snapshot.red || null;
    if(refTeam){
      const count = Number(refTeam.count);
      const speed = Number(refTeam.speed);
      const smart = Number(refTeam.smart);
      const strat = Number(refTeam.strat);
      const sep = Number(refTeam.sep);
      params.teams.forEach((team)=>{
        if(Number.isFinite(count)) team.count = count;
        if(Number.isFinite(speed)) team.speed = speed;
        if(Number.isFinite(smart)) team.smart = smart;
        if(Number.isFinite(strat)) team.strat = strat;
        if(Number.isFinite(sep)) team.sep = sep;
      });
    }
    params.teams.forEach((team, index)=>{
      team.active = index < 2;
    });
    renderTeamRoster();
    resizePop();
  }

  if(snapshot.learn){
    if(snapshot.learn.genSteps != null) setRangeValue('slGenSteps', snapshot.learn.genSteps);
    if(snapshot.learn.hidden != null) setRangeValue('slHidden', snapshot.learn.hidden);
    if(snapshot.learn.mut != null) setRangeValue('slMut', Math.round(snapshot.learn.mut*100));
    if(snapshot.learn.elite != null) setRangeValue('slElite', Math.round(snapshot.learn.elite*100));
    if(snapshot.learn.mutStrengthW != null) setRangeValue('slMutStrengthW', Math.round(snapshot.learn.mutStrengthW*100));
    if(snapshot.learn.mutStrengthB != null) setRangeValue('slMutStrengthB', Math.round(snapshot.learn.mutStrengthB*100));
    if(snapshot.learn.crossoverBias != null) setRangeValue('slCrossover', Math.round(snapshot.learn.crossoverBias*100));
    if(snapshot.learn.tournamentFactor != null) setRangeValue('slTournament', Math.round(snapshot.learn.tournamentFactor*10));
    if(snapshot.learn.fresh != null) setRangeValue('slFresh', Math.round(snapshot.learn.fresh*100));
    if(snapshot.learn.auto !== undefined){
      const auto = Q('chkAuto');
      if(auto){
        auto.checked = !!snapshot.learn.auto;
        auto.dispatchEvent(new Event('change', { bubbles:true }));
      }
    }
  }
}

function loadTrainingSnapshot(data){
  if(!data || typeof data !== 'object') throw new Error('Invalid training file.');
  const evoData = data.evo || data;
  if(!evoData) throw new Error('Training file is missing the evo section.');

  const toIndividual = (entry)=>{
    const netData = entry && (entry.net || entry);
    if(!netData || !netData.W1 || !netData.b1 || !netData.W2 || !netData.b2){
      throw new Error('Training file contains malformed network data.');
    }
    return { net:cloneNet(netData), fitness:0 };
  };

  let bestFromSnapshot = {};
  resetBestBrainState(Number(evoData.gen) || 1);
  let bestBrainCandidate = null;

  if(data.params) applyParamsSnapshot(data.params);

  if(Array.isArray(evoData.teams)){
    bestFromSnapshot = {};
    evoData.teams.forEach((teamEntry)=>{
      const members = Array.isArray(teamEntry.members) ? teamEntry.members : [];
      evo.populations[teamEntry.id] = members.map(toIndividual);
      const targetTeam = params.teams.find((t)=>t.id===teamEntry.id);
      if(targetTeam && teamEntry.active !== undefined){
        targetTeam.active = !!teamEntry.active;
      }
      let bestFitness = 0;
      for(const item of members){
        const val = Number(item?.fitness);
        if(Number.isFinite(val) && val > bestFitness) bestFitness = val;
        if(Number.isFinite(val)){
          const netData = item && (item.net || item);
          if(netData && netData.W1 && netData.W2){
            if(!bestBrainCandidate || val > bestBrainCandidate.fitness){
              bestBrainCandidate = { teamId:teamEntry.id, fitness:val, net:cloneNet(netData) };
            }
          }
        }
      }
      bestFromSnapshot[teamEntry.id] = bestFitness;
    });
    renderTeamRoster();
  } else {
    const greensData = Array.isArray(evoData.greens) ? evoData.greens : (Array.isArray(evoData.G) ? evoData.G : null);
    const redsData = Array.isArray(evoData.reds) ? evoData.reds : (Array.isArray(evoData.R) ? evoData.R : null);
    if(!greensData || !redsData) throw new Error('Training file does not contain both team genomes.');

    evo.populations.green = greensData.map(toIndividual);
    evo.populations.red = redsData.map(toIndividual);
    params.teams.forEach((team, index)=>{
      team.active = index < 2;
    });
    renderTeamRoster();

    let bestG = 0;
    for(const item of greensData){
      const val = Number(item?.fitness);
      if(Number.isFinite(val) && val > bestG) bestG = val;
      if(Number.isFinite(val)){
        const netData = item && (item.net || item);
        if(netData && netData.W1 && netData.W2 && (!bestBrainCandidate || val > bestBrainCandidate.fitness)){
          bestBrainCandidate = { teamId:'green', fitness:val, net:cloneNet(netData) };
        }
      }
    }
    let bestR = 0;
    for(const item of redsData){
      const val = Number(item?.fitness);
      if(Number.isFinite(val) && val > bestR) bestR = val;
      if(Number.isFinite(val)){
        const netData = item && (item.net || item);
        if(netData && netData.W1 && netData.W2 && (!bestBrainCandidate || val > bestBrainCandidate.fitness)){
          bestBrainCandidate = { teamId:'red', fitness:val, net:cloneNet(netData) };
        }
      }
    }
    bestFromSnapshot = { green:bestG, red:bestR };
  }

  const parsedGen = Number(evoData.gen);
  evo.gen = Number.isFinite(parsedGen) && parsedGen > 0 ? parsedGen : 1;

  simSteps = 0;
  forceNextGen = false;
  awaitingManualAdvance = false;
  setup();

  if(bestBrainCandidate){
    const teamInfo = params.teams.find((t)=>t.id===bestBrainCandidate.teamId) || { id:bestBrainCandidate.teamId, label:bestBrainCandidate.teamId, icon:'‚óè', color:'#38bdf8' };
    setBestBrainFromNet(bestBrainCandidate.net, teamInfo, bestBrainCandidate.fitness, evo.gen, null, globalBrainChampion);
    const cache = ensureTeamBrainCache(teamInfo.id);
    if(cache){
      setBestBrainFromNet(bestBrainCandidate.net, teamInfo, bestBrainCandidate.fitness, evo.gen, null, cache);
    }
  }

  applyBrainSelection(brainTeamSelect ? brainTeamSelect.value : 'auto');

  const bestCombined = Object.assign({}, bestFromSnapshot, data.best || {});
  applyBestFitnessSnapshot(bestCombined);
}

function handleTrainingFileSelection(evt){
  const input = evt.target;
  const file = input?.files?.[0];
  if(input) input.value = '';
  if(!file) return;
  const reader = new FileReader();
  reader.onload = ()=>{
    try{
      const parsed = JSON.parse(reader.result);
      loadTrainingSnapshot(parsed);
    }catch(err){
      console.error('Failed to load training file', err);
      alert('Could not load training data. Please ensure it was exported from this simulator.');
    }
  };
  reader.onerror = ()=>{
    console.error('Unable to read the selected file', reader.error);
    alert('Could not read the selected file.');
  };
  reader.readAsText(file);
}

const btnSaveTraining = Q('btnSaveTraining');
if(btnSaveTraining){
  btnSaveTraining.addEventListener('click', downloadTrainingData);
}
const btnLoadTraining = Q('btnLoadTraining');
const inputLoadTraining = Q('inputLoadTraining');
if(btnLoadTraining && inputLoadTraining){
  btnLoadTraining.addEventListener('click', ()=> inputLoadTraining.click());
  inputLoadTraining.addEventListener('change', handleTrainingFileSelection);
}

const toolButtons = Array.from(document.querySelectorAll('.tool-btn'));
function setTool(tool){
  if(!toolButtons.length){
    currentTool = tool || TOOL_SELECT;
    return;
  }
  const nextTool = toolButtons.some(btn=>btn.dataset.tool===tool) ? tool : TOOL_SELECT;
  currentTool = nextTool;
  toolButtons.forEach(btn=>{
    const isActive = btn.dataset.tool === nextTool;
    btn.classList.toggle('active', isActive);
    btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
  });
  if(currentTool === TOOL_SELECT){
    drawingState = null;
  }
}

if(toolButtons.length){
  toolButtons.forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const tool = btn.dataset.tool || TOOL_SELECT;
      setTool(tool);
    });
  });
  setTool(TOOL_SELECT);
}

const btnUndoManual = Q('btnUndoManual');
if(btnUndoManual){
  btnUndoManual.addEventListener('click', ()=>{
    for(let i=obstacles.length-1; i>=0; i--){
      if(obstacles[i].manual){
        obstacles.splice(i,1);
        break;
      }
    }
    syncManualObstacleState();
    markPathCostDirty();
  });
}

const btnClearManual = Q('btnClearManual');
if(btnClearManual){
  btnClearManual.addEventListener('click', ()=>{
    obstacles.length = 0;
    setRangeValue('slObst', 0);
    syncManualObstacleState();
    markPathCostDirty();
  });
}

const btnGenerateLabyrinth = Q('btnGenerateLabyrinth');
if(btnGenerateLabyrinth){
  btnGenerateLabyrinth.addEventListener('click', ()=>{
    generateLabyrinthObstacles();
    setRangeValue('slObst', 0);
  });
}

const btnSaveObstacles = Q('btnSaveObstacles');
if(btnSaveObstacles){
  btnSaveObstacles.addEventListener('click', downloadObstacleData);
}
const btnLoadObstacles = Q('btnLoadObstacles');
const inputLoadObstacles = Q('inputLoadObstacles');
if(btnLoadObstacles && inputLoadObstacles){
  btnLoadObstacles.addEventListener('click', ()=> inputLoadObstacles.click());
  inputLoadObstacles.addEventListener('change', handleObstacleFileSelection);
}

syncManualObstacleState();

if(brainCanvas){
  window.addEventListener('resize', ()=>{
    brainCanvasWidth = brainCanvas.clientWidth || brainCanvasWidth;
    brainCanvasHeight = brainCanvas.clientHeight || brainCanvasHeight;
    markBestBrainDirty();
    renderBestBrain();
  });
}

// Bind ranges after DOM ready
['Fruits','Spawn','Obst','Tail','GenSteps'].forEach(k=>{
  bindRange('sl'+k, 'lb'+k, (v)=> v);
});
bindRange('slMut','lbMut',(v)=> `${v}%`);
bindRange('slElite','lbElite',(v)=> `${v}%`);
bindRange('slMutStrengthW','lbMutStrengthW',(v)=> (v/100).toFixed(2));
bindRange('slMutStrengthB','lbMutStrengthB',(v)=> (v/100).toFixed(2));
bindRange('slCrossover','lbCrossover',(v)=> `${v}% A`);
bindRange('slTournament','lbTournament',(v)=> `√ó${(v/10).toFixed(1)}`);
bindRange('slFresh','lbFresh',(v)=> `${v}%`);
bindRange('slHidden','lbHidden',(v)=>{
  const count = Math.round(Number(v));
  return `${count} neuron${count===1?'':'s'}`;
});
bindRange('slSimSpeed','lbSimSpeed',(v)=> (v/100).toFixed(2)+'√ó');
bindRange('slAgentScale','lbAgentScale',(v)=> (v/100).toFixed(2)+'√ó');
bindRange('slEnergyEmptySpeed','lbEnergyEmptySpeed',(v)=> `${v}%`);
bindRange('slEnergyCapacity','lbEnergyCapacity',(v)=> {
  const numeric = Math.round(Number(v));
  return numeric <= 0 ? 'off' : `${numeric}`;
});
bindRange('slAwarenessBoost','lbAwarenessBoost',(v)=> `${v}%`);
initFruitPlacementControls();
Q('btnReset').onclick = ()=> { awaitingManualAdvance=false; forceNextGen=false; simSteps=0; setup(); };
const btnResetTraining = Q('btnResetTraining');
if(btnResetTraining){
  btnResetTraining.addEventListener('click', ()=> resetTraining(true));
}
Q('btnNextGen').onclick = ()=> { forceNextGen = true; };
Q('chkAuto').addEventListener('change', ()=> readParams());
const chkAgentCollisions = Q('chkAgentCollisions');
if(chkAgentCollisions){
  chkAgentCollisions.addEventListener('change', ()=> readParams());
}

const chkTopHighlight = Q('chkTopHighlight');
if(chkTopHighlight){
  chkTopHighlight.addEventListener('change', ()=> readParams());
}

const chkEnergyHalo = Q('chkEnergyHalo');
if(chkEnergyHalo){
  chkEnergyHalo.addEventListener('change', ()=> readParams());
}

const chkEnergyDeath = Q('chkEnergyDeath');
if(chkEnergyDeath){
  chkEnergyDeath.addEventListener('change', ()=> readParams());
}

const chkSensorRadar = Q('chkSensorRadar');
if(chkSensorRadar){
  chkSensorRadar.addEventListener('change', ()=> readParams());
}

if(navPresetSelect){
  navPresetSelect.addEventListener('change', (evt)=>{
    applyPreset(evt.target.value);
  });
}

window.addEventListener('beforeunload', clearCurrentObjectUrl);

// Start
initMusicPanel();
renderTeamRoster();
let savedNavPreset = 'open';
let storedNavPreset = null;
try{
  if(typeof localStorage !== 'undefined' && localStorage){
    storedNavPreset = localStorage.getItem('navPreset');
  }
}catch(err){
  console.warn('Unable to read nav preset preference', err);
}
if(typeof storedNavPreset === 'string' && storedNavPreset.trim()){
  const storedPresetValue = storedNavPreset.trim();
  savedNavPreset = storedPresetValue === 'lab' ? 'open' : storedPresetValue;
}
applyPreset(savedNavPreset);
readParams();
setup();
renderBestBrain();
loop();
</script>
</body>
</html>
