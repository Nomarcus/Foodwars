<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Rolling Ball (NEAT)</title>
<style>
    :root {
        --bg-gradient-start: #1f2633;
        --bg-gradient-end: #121722;
        --accent: #ff9f43;
        --accent-soft: rgba(255, 159, 67, 0.2);
        --panel-bg: rgba(24, 31, 44, 0.92);
        --panel-border: rgba(255, 255, 255, 0.08);
        --text-light: #f5f7ff;
        --text-dim: #9aa7c2;
        --shadow: 0 12px 24px rgba(0, 0, 0, 0.3);
        --radius: 14px;
        font-size: 16px;
    }

    * {
        box-sizing: border-box;
    }

    body {
        margin: 0;
        font-family: "Inter", "Segoe UI", sans-serif;
        color: var(--text-light);
        background: linear-gradient(160deg, var(--bg-gradient-start), var(--bg-gradient-end));
        min-height: 100vh;
        display: flex;
        flex-direction: column;
    }

    a {
        color: var(--accent);
        text-decoration: none;
        font-weight: 600;
    }

    .top-bar {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 16px 24px;
        background: rgba(12, 16, 24, 0.7);
        backdrop-filter: blur(8px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        z-index: 10;
    }

    .top-bar h1 {
        font-size: 1.1rem;
        margin: 0;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: var(--text-light);
    }

    .layout {
        flex: 1;
        display: flex;
        position: relative;
        overflow: hidden;
    }

    .game-container {
        flex: 1;
        position: relative;
        display: flex;
        align-items: stretch;
        justify-content: center;
        padding: 16px;
    }

    canvas {
        width: 100%;
        height: 100%;
        max-height: calc(100vh - 120px);
        border-radius: var(--radius);
        background: linear-gradient(180deg, rgba(13, 18, 28, 0.96) 0%, rgba(10, 12, 16, 0.98) 60%, rgba(8, 9, 12, 1) 100%);
        box-shadow: var(--shadow);
    }

    .hud {
        position: absolute;
        top: 24px;
        left: 32px;
        padding: 16px 18px;
        background: rgba(12, 18, 30, 0.72);
        border: 1px solid var(--panel-border);
        border-radius: var(--radius);
        backdrop-filter: blur(6px);
        font-size: 0.85rem;
        line-height: 1.4;
    }

    .hud span {
        display: block;
        color: var(--text-dim);
    }

    .hud strong {
        color: var(--text-light);
    }

    .overlay {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: none;
    }

    .overlay .panel {
        pointer-events: auto;
        padding: 28px 32px;
        border-radius: var(--radius);
        background: rgba(10, 14, 24, 0.92);
        border: 1px solid var(--panel-border);
        box-shadow: var(--shadow);
        text-align: center;
        min-width: 280px;
    }

    .overlay .panel h2 {
        margin: 0 0 12px;
        font-weight: 600;
        letter-spacing: 0.05em;
    }

    .overlay .panel button {
        margin: 8px;
        padding: 10px 18px;
        font-size: 0.9rem;
        border-radius: 10px;
        border: none;
        cursor: pointer;
        font-weight: 600;
        background: var(--accent);
        color: #09101a;
        transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    .overlay .panel button:hover {
        transform: translateY(-1px);
        box-shadow: 0 8px 14px rgba(255, 159, 67, 0.35);
    }

    .side-panel {
        width: 320px;
        background: var(--panel-bg);
        border-left: 1px solid var(--panel-border);
        box-shadow: -12px 0 24px rgba(0, 0, 0, 0.25);
        display: flex;
        flex-direction: column;
        transition: transform 0.3s ease;
    }

    .side-panel.collapsed {
        transform: translateX(260px);
    }

    .side-panel header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 16px 20px;
        border-bottom: 1px solid var(--panel-border);
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.08em;
    }

    .toggle-panel {
        position: absolute;
        top: 24px;
        right: 340px;
        z-index: 5;
        padding: 8px 12px;
        background: rgba(12, 18, 30, 0.8);
        border: 1px solid var(--panel-border);
        border-radius: 999px;
        color: var(--text-dim);
        font-weight: 600;
        cursor: pointer;
        box-shadow: var(--shadow);
    }

    .side-panel.collapsed + .toggle-panel {
        right: 60px;
    }

    .panel-section {
        padding: 16px 20px;
        border-bottom: 1px solid var(--panel-border);
    }

    .panel-section h3 {
        margin: 0 0 12px;
        font-size: 0.8rem;
        letter-spacing: 0.08em;
        color: var(--text-dim);
        text-transform: uppercase;
    }

    .panel-section label {
        display: flex;
        flex-direction: column;
        gap: 6px;
        font-size: 0.8rem;
        margin-bottom: 12px;
        color: var(--text-dim);
    }

    .panel-section input[type="range"] {
        width: 100%;
    }

    .panel-section input[type="number"],
    .panel-section input[type="text"] {
        width: 100%;
        padding: 6px 8px;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        background: rgba(0, 0, 0, 0.3);
        color: var(--text-light);
    }

    .panel-section .checkbox-row {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 10px;
    }

    .panel-section button {
        padding: 8px 12px;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(255, 255, 255, 0.05);
        color: var(--text-light);
        cursor: pointer;
        font-weight: 600;
        transition: background 0.2s ease;
    }

    .panel-section button:hover {
        background: rgba(255, 255, 255, 0.12);
    }

    .save-status {
        font-size: 0.75rem;
        color: var(--text-dim);
        margin-top: 6px;
        min-height: 14px;
    }

    .stuck-warning {
        color: #ff6b6b;
        font-weight: 600;
    }

    @media (max-width: 1200px) {
        .side-panel {
            position: absolute;
            right: 0;
            top: 72px;
            height: calc(100% - 72px);
        }
        .toggle-panel {
            top: 92px;
        }
    }
</style>
</head>
<body>
    <div class="top-bar">
        <h1>Rolling Ball (NEAT)</h1>
        <a href="index.html">Back to Foodwars</a>
    </div>
    <div class="layout">
        <div class="game-container">
            <canvas id="game" width="1280" height="720"></canvas>
            <div class="hud" id="hud"></div>
            <div class="overlay" id="overlay" hidden>
                <div class="panel">
                    <h2 id="overlay-title">Episode Over</h2>
                    <p id="overlay-subtitle"></p>
                    <div>
                        <button data-action="restart">Restart (R)</button>
                        <button data-action="new-seed">New Seed (Enter)</button>
                        <button data-action="toggle-mode">Toggle Mode (Space)</button>
                    </div>
                </div>
            </div>
        </div>
        <aside class="side-panel" id="side-panel">
            <header>
                <span>Telemetry &amp; Controls</span>
                <button id="collapse-btn" style="background:none;border:none;color:var(--text-dim);cursor:pointer;font-weight:600;">â®œ</button>
            </header>
            <div class="panel-section">
                <h3>Physics</h3>
                <label>Gravity Scale <input type="range" min="200" max="1200" value="550" step="10" data-param="gravity" /></label>
                <label>Ground Friction <input type="range" min="0" max="10" value="2" step="0.1" data-param="friction" /></label>
                <label>Acceleration Power <input type="range" min="50" max="400" value="180" step="5" data-param="accel" /></label>
                <label>Brake Strength <input type="range" min="50" max="400" value="220" step="5" data-param="brake" /></label>
                <label>Stuck Timeout (s) <input type="range" min="2" max="8" value="4" step="0.1" data-param="stuckTime" /></label>
                <label>Gap Frequency <input type="range" min="0" max="1" value="0.25" step="0.01" data-param="gapFreq" /></label>
            </div>
            <div class="panel-section">
                <h3>NEAT</h3>
                <label>Population Size <input type="number" value="24" min="4" max="100" step="1" data-param="population" /></label>
                <label>Mutation Rate <input type="range" min="0" max="1" value="0.2" step="0.01" data-param="mutation" /></label>
                <label>Add Node Rate <input type="range" min="0" max="0.5" value="0.03" step="0.005" data-param="addNode" /></label>
                <label>Add Connection Rate <input type="range" min="0" max="0.8" value="0.18" step="0.01" data-param="addConn" /></label>
                <label>Elitism (%) <input type="range" min="0" max="0.5" value="0.1" step="0.01" data-param="elitism" /></label>
                <label>Compat c1 <input type="range" min="0" max="5" value="1" step="0.05" data-param="c1" /></label>
                <label>Compat c2 <input type="range" min="0" max="5" value="1" step="0.05" data-param="c2" /></label>
                <label>Compat c3 <input type="range" min="0" max="5" value="0.4" step="0.05" data-param="c3" /></label>
                <label>Compat Threshold <input type="range" min="0.1" max="6" value="2.6" step="0.05" data-param="compatThreshold" /></label>
                <label>Species Target <input type="range" min="1" max="10" value="5" step="1" data-param="speciesTarget" /></label>
                <div class="checkbox-row"><input type="checkbox" data-param="showNormals" id="showNormals" /> <label for="showNormals" style="margin:0;">Show normals</label></div>
                <div class="checkbox-row"><input type="checkbox" data-param="fastTrain" id="fastTrain" /> <label for="fastTrain" style="margin:0;">Fast training</label></div>
                <div class="checkbox-row"><input type="checkbox" data-param="autoRestart" id="autoRestart" checked /> <label for="autoRestart" style="margin:0;">Auto restart</label></div>
            </div>
            <div class="panel-section">
                <h3>Seed</h3>
                <label>Seed <input type="text" data-param="seedText" /></label>
                <div style="display:flex;gap:8px;flex-wrap:wrap;">
                    <button data-action="new-seed">New Seed</button>
                    <button data-action="use-seed">Use Seed</button>
                </div>
            </div>
            <div class="panel-section">
                <h3>Best Genome</h3>
                <div style="display:flex;gap:8px;flex-wrap:wrap;">
                    <button data-action="save-best">Save Best</button>
                    <button data-action="load-best">Load Best</button>
                    <button data-action="clear-best">Clear Saved</button>
                </div>
                <div class="save-status" id="save-status"></div>
            </div>
        </aside>
        <button class="toggle-panel" id="toggle-panel">Telemetry</button>
    </div>
    <script>
    // -------------------------------------------------------------
    // Utility helpers
    // -------------------------------------------------------------
    const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
    const lerp = (a, b, t) => a + (b - a) * clamp(t, 0, 1);

    class RNG {
        constructor(seed) {
            this.setSeed(seed || Date.now().toString());
        }
        setSeed(seedStr) {
            this.seedStr = seedStr;
            let h = 1779033703 ^ seedStr.length;
            for (let i = 0; i < seedStr.length; i++) {
                h = Math.imul(h ^ seedStr.charCodeAt(i), 3432918353);
                h = (h << 13) | (h >>> 19);
            }
            this.state = h >>> 0;
        }
        next() {
            let x = this.state;
            x ^= x << 13;
            x ^= x >>> 17;
            x ^= x << 5;
            this.state = x >>> 0;
            return (this.state & 0xffffffff) / 0xffffffff;
        }
        range(min, max) {
            return min + (max - min) * this.next();
        }
        choice(arr) {
            return arr[Math.floor(this.next() * arr.length)];
        }
    }

    // -------------------------------------------------------------
    // Procedural track generation
    // -------------------------------------------------------------
    class TrackGenerator {
        constructor(rng, params) {
            this.rng = rng;
            this.params = params;
            this.reset();
        }
        reset() {
            this.segments = [{ startX: -200, endX: 0, startY: 420, endY: 420, gap: false }];
            this.cursorY = 420;
            this.cursorX = 0;
        }
        ensureSegments(targetX) {
            while (this.cursorX < targetX + 1500) {
                this.addSegment();
            }
        }
        addSegment() {
            const gapChance = this.params.gapFrequency;
            const segmentLength = this.rng.range(120, 340);
            const slope = this.rng.range(-0.45, 0.45);
            const isGap = this.rng.next() < gapChance;
            const endX = this.cursorX + segmentLength;
            let endY = this.cursorY + slope * segmentLength;
            endY = clamp(endY, 320, 520);
            if (isGap) {
                this.segments.push({ startX: this.cursorX, endX, startY: this.cursorY, endY, gap: true });
                this.cursorX = endX;
                this.cursorY = endY;
                return;
            }
            this.segments.push({ startX: this.cursorX, endX, startY: this.cursorY, endY, gap: false });
            this.cursorX = endX;
            this.cursorY = endY;
        }
        getSegment(x) {
            this.ensureSegments(x);
            for (let i = this.segments.length - 1; i >= 0; i--) {
                const seg = this.segments[i];
                if (x >= seg.startX && x <= seg.endX) {
                    return seg;
                }
            }
            return this.segments[this.segments.length - 1];
        }
        getHeight(x) {
            const seg = this.getSegment(x);
            if (!seg || seg.gap) return Infinity;
            const t = (x - seg.startX) / (seg.endX - seg.startX || 1);
            return seg.startY + (seg.endY - seg.startY) * t;
        }
        getSlope(x) {
            const seg = this.getSegment(x);
            if (!seg || seg.gap) return 0;
            const dy = seg.endY - seg.startY;
            const dx = seg.endX - seg.startX || 1;
            return dy / dx;
        }
        getDistToNextGap(x) {
            this.ensureSegments(x);
            for (const seg of this.segments) {
                if (seg.endX > x) {
                    if (seg.gap) {
                        return seg.startX - x;
                    }
                }
            }
            return 9999;
        }
        getUpcomingSlope(x) {
            this.ensureSegments(x + 80);
            for (const seg of this.segments) {
                if (!seg.gap && seg.startX > x) {
                    const dy = seg.endY - seg.startY;
                    const dx = seg.endX - seg.startX || 1;
                    return dy / dx;
                }
            }
            return 0;
        }
    }

    // -------------------------------------------------------------
    // Physics and episode state
    // -------------------------------------------------------------
    class Ball {
        constructor(params) {
            this.params = params;
            this.radius = 24;
            this.reset();
        }
        reset() {
            this.x = 0;
            this.y = 360;
            this.vx = 0;
            this.vy = 0;
            this.onGround = false;
            this.groundNormal = { x: 0, y: -1 };
            this.groundSlope = 0;
            this.distToNextGap = 999;
            this.upcomingSlope = 0;
            this.coyoteTimer = 0;
            this.jumpBuffer = 0;
            this.stuckTimer = 0;
            this.stuckCountdown = this.params.stuckTime;
            this.prevX = this.x;
            this.timeAlive = 0;
            this.reward = 0;
            this.peakRewardRate = 0;
        }
    }

    class Episode {
        constructor(params) {
            this.params = params;
            this.rng = new RNG(params.seed);
            this.track = new TrackGenerator(this.rng, params);
            this.ball = new Ball(params);
            this.reset();
        }
        reset(seed) {
            if (seed) {
                this.params.seed = seed;
                this.rng.setSeed(seed);
            }
            this.track.reset();
            this.ball.reset();
            this.elapsed = 0;
            this.done = false;
            this.reason = "";
            this.lastReward = 0;
        }
        update(action, dt) {
            if (this.done) return;
            const p = this.params;
            const ball = this.ball;
            const track = this.track;

            ball.timeAlive += dt;
            this.elapsed += dt;

            // Update timers
            if (ball.onGround) {
                ball.coyoteTimer = p.coyoteTime;
                ball.stuckTimer = 0;
            } else {
                ball.coyoteTimer -= dt;
            }
            if (action.jumpPressed) {
                ball.jumpBuffer = p.jumpBufferTime;
            } else {
                ball.jumpBuffer -= dt;
            }

            // Apply horizontal impulses
            if (action.accel) {
                ball.vx += p.accelPower * dt;
            }
            if (action.brake) {
                ball.vx -= p.brakeStrength * dt;
            }

            // Gravity and jump cut logic
            const cut = (!action.jumpHeld && ball.vy < 0) ? p.jumpCutScale : 1;
            ball.vy += p.gravity * cut * dt;

            // Integrate
            ball.x += ball.vx * dt;
            ball.y += ball.vy * dt;

            // Track sampling
            track.ensureSegments(ball.x + 100);
            const groundY = track.getHeight(ball.x);
            const slope = track.getSlope(ball.x);
            const distGap = track.getDistToNextGap(ball.x);
            const upcomingSlope = track.getUpcomingSlope(ball.x);
            ball.distToNextGap = distGap;
            ball.upcomingSlope = upcomingSlope;

            const isGap = !isFinite(groundY);
            if (!isGap) {
                const floor = groundY - ball.radius;
                if (ball.y > floor) {
                    ball.y = floor;
                    if (ball.vy > 0) ball.vy = 0;
                    ball.onGround = true;
                    const tangent = { x: 1, y: slope };
                    const len = Math.hypot(tangent.x, tangent.y) || 1;
                    ball.groundNormal = { x: -tangent.y / len, y: tangent.x / len };
                    ball.groundSlope = slope;
                    const tangentNorm = { x: tangent.x / len, y: tangent.y / len };
                    const vAlong = ball.vx * tangentNorm.x + ball.vy * tangentNorm.y;
                    ball.vx = vAlong * tangentNorm.x;
                    ball.vy = vAlong * tangentNorm.y;
                    ball.vx += -slope * p.slopeForce * dt;
                    ball.vx *= (1 - p.groundFriction * dt);
                } else {
                    ball.onGround = false;
                    ball.groundSlope = slope;
                }
            } else {
                ball.onGround = false;
                ball.groundSlope = 0;
            }

            if (ball.jumpBuffer > 0 && (ball.onGround || ball.coyoteTimer > 0)) {
                ball.onGround = false;
                ball.vy = -p.jumpImpulse;
                ball.jumpBuffer = 0;
                ball.coyoteTimer = 0;
            }

            const forwardDelta = ball.x - ball.prevX;
            ball.prevX = ball.x;
            if (forwardDelta < p.stuckDeltaThreshold) {
                ball.stuckTimer += dt;
            } else {
                ball.stuckTimer = 0;
            }
            ball.stuckCountdown = clamp(p.stuckTime - ball.stuckTimer, 0, p.stuckTime);

            const reward = p.rewardSurvival * dt + Math.max(0, forwardDelta) * p.rewardForward;
            const brakePenalty = action.brake ? p.penaltyBrake * dt : 0;
            const stuckPenalty = ball.stuckTimer > 0 ? p.penaltyStuck * dt : 0;
            const totalReward = reward - brakePenalty - stuckPenalty;
            ball.reward += totalReward;
            this.lastReward = totalReward;

            if (ball.y - ball.radius > 820) {
                this.end("Fell out");
            } else if (ball.x < -240) {
                this.end("Out of bounds");
            } else if (ball.stuckTimer > p.stuckTime) {
                this.end("Stuck");
            } else if (isGap && ball.y > 700) {
                this.end("Fell in gap");
            }
        }
        end(reason) {
            this.done = true;
            this.reason = reason;
        }
        getState() {
            const b = this.ball;
            const heightRaw = this.getHeightAboveFloorRaw();
            return {
                x: b.x,
                y: b.y,
                vx: b.vx,
                vy: b.vy,
                onGround: b.onGround,
                groundNormal: { x: b.groundNormal.x, y: b.groundNormal.y },
                groundSlope: b.groundSlope,
                distToNextGap: b.distToNextGap,
                upcomingSlope: b.upcomingSlope,
                stuckTimer: b.stuckTimer,
                heightAboveFloor: heightRaw,
                normalized: {
                    vx: clamp(b.vx / 600, -1, 1),
                    vy: clamp(b.vy / 600, -1, 1),
                    onGround: b.onGround ? 1 : 0,
                    groundSlope: clamp(b.groundSlope, -1, 1),
                    distToNextGap: clamp(b.distToNextGap / 400, 0, 1),
                    upcomingSlope: clamp(b.upcomingSlope, -1, 1),
                    stuckTimer: clamp(b.stuckTimer / this.params.stuckTime, 0, 1),
                    heightAboveFloor: clamp(heightRaw / 200, 0, 1),
                    speedNormalized: clamp(Math.abs(b.vx) / this.params.targetSpeed, 0, 1)
                }
            };
        }
        sampleHeightAboveFloor() {
            const h = this.getHeightAboveFloorRaw();
            return clamp(h / 200, 0, 1);
        }
        getHeightAboveFloorRaw() {
            const ground = this.track.getHeight(this.ball.x);
            if (!isFinite(ground)) return 200;
            return ground - this.ball.y - this.ball.radius;
        }
    }

    // -------------------------------------------------------------
    // NEAT implementation
    // -------------------------------------------------------------
    const NODE_TYPES = { INPUT: 'input', HIDDEN: 'hidden', OUTPUT: 'output', BIAS: 'bias' };

    class NodeGene {
        constructor(id, type, layer = 0) {
            this.id = id;
            this.type = type;
            this.layer = layer;
        }
    }

    class ConnectionGene {
        constructor(innovation, inNode, outNode, weight, enabled = true) {
            this.innovation = innovation;
            this.inNode = inNode;
            this.outNode = outNode;
            this.weight = weight;
            this.enabled = enabled;
        }
    }

    class InnovationTracker {
        constructor() {
            this.map = new Map();
            this.nextInnovation = 1;
            this.nextNodeId = 1;
        }
        getInnovation(inNode, outNode) {
            const key = `${inNode}->${outNode}`;
            if (!this.map.has(key)) {
                this.map.set(key, this.nextInnovation++);
            }
            return this.map.get(key);
        }
        newNodeId() {
            return this.nextNodeId++;
        }
    }

    class Genome {
        constructor(tracker) {
            this.tracker = tracker;
            this.nodes = new Map();
            this.connections = new Map();
            this.cachedOrder = null;
            this.fitness = 0;
            this.adjustedFitness = 0;
        }
        clone() {
            const g = new Genome(this.tracker);
            for (const node of this.nodes.values()) {
                g.nodes.set(node.id, new NodeGene(node.id, node.type, node.layer));
            }
            for (const conn of this.connections.values()) {
                g.connections.set(conn.innovation, new ConnectionGene(conn.innovation, conn.inNode, conn.outNode, conn.weight, conn.enabled));
            }
            g.cachedOrder = this.cachedOrder ? [...this.cachedOrder] : null;
            g.fitness = this.fitness;
            g.adjustedFitness = this.adjustedFitness;
            return g;
        }
        addNodeGene(node) {
            this.nodes.set(node.id, node);
            this.cachedOrder = null;
        }
        addConnectionGene(conn) {
            this.connections.set(conn.innovation, conn);
            this.cachedOrder = null;
        }
        getConnectionsTo(nodeId) {
            const list = [];
            for (const conn of this.connections.values()) {
                if (conn.outNode === nodeId && conn.enabled) list.push(conn);
            }
            return list;
        }
        feedForward(inputs) {
            const order = this.getNodeOrder();
            const values = new Map();
            let inputIndex = 0;
            for (const node of order) {
                if (node.type === NODE_TYPES.INPUT) {
                    values.set(node.id, inputs[inputIndex++] ?? 0);
                    continue;
                }
                if (node.type === NODE_TYPES.BIAS) {
                    values.set(node.id, 1);
                    continue;
                }
                const incoming = this.getConnectionsTo(node.id);
                let sum = 0;
                for (const conn of incoming) {
                    const v = values.get(conn.inNode) ?? 0;
                    sum += v * conn.weight;
                }
                values.set(node.id, Math.tanh(sum));
            }
            const outputs = [];
            for (const node of order) {
                if (node.type === NODE_TYPES.OUTPUT) {
                    outputs.push((values.get(node.id) + 1) / 2);
                }
            }
            return outputs;
        }
        getNodeOrder() {
            if (this.cachedOrder) return this.cachedOrder;
            const list = Array.from(this.nodes.values()).sort((a, b) => a.layer - b.layer || a.id - b.id);
            this.cachedOrder = list;
            return list;
        }
        mutateWeights(rate = 0.9, jitter = 0.5, resetRate = 0.1) {
            for (const conn of this.connections.values()) {
                if (Math.random() < rate) {
                    if (Math.random() < resetRate) {
                        conn.weight = Math.random() * 2 - 1;
                    } else {
                        conn.weight += (Math.random() * 2 - 1) * jitter;
                    }
                }
            }
        }
        mutateToggle() {
            const conns = Array.from(this.connections.values());
            if (!conns.length) return;
            const conn = conns[Math.floor(Math.random() * conns.length)];
            conn.enabled = !conn.enabled;
        }
        mutateAddConnection(maxAttempts = 24) {
            const nodes = Array.from(this.nodes.values());
            for (let attempt = 0; attempt < maxAttempts; attempt++) {
                const a = nodes[Math.floor(Math.random() * nodes.length)];
                const b = nodes[Math.floor(Math.random() * nodes.length)];
                if (!a || !b || a.id === b.id) continue;
                if (a.layer >= b.layer) continue;
                if (b.type === NODE_TYPES.INPUT) continue;
                if (a.type === NODE_TYPES.OUTPUT) continue;
                const innovation = this.tracker.getInnovation(a.id, b.id);
                if (this.connections.has(innovation)) continue;
                this.addConnectionGene(new ConnectionGene(innovation, a.id, b.id, Math.random() * 2 - 1, true));
                return;
            }
        }
        mutateAddNode() {
            const enabled = Array.from(this.connections.values()).filter(c => c.enabled);
            if (!enabled.length) return;
            const conn = enabled[Math.floor(Math.random() * enabled.length)];
            conn.enabled = false;
            const newNodeId = this.tracker.newNodeId();
            const inNode = this.nodes.get(conn.inNode);
            const outNode = this.nodes.get(conn.outNode);
            const node = new NodeGene(newNodeId, NODE_TYPES.HIDDEN, (inNode.layer + outNode.layer) / 2 + 0.0001);
            this.addNodeGene(node);
            const inInnovation = this.tracker.getInnovation(conn.inNode, newNodeId);
            const outInnovation = this.tracker.getInnovation(newNodeId, conn.outNode);
            this.addConnectionGene(new ConnectionGene(inInnovation, conn.inNode, newNodeId, 1, true));
            this.addConnectionGene(new ConnectionGene(outInnovation, newNodeId, conn.outNode, conn.weight, true));
        }
        crossover(other) {
            const child = new Genome(this.tracker);
            for (const node of this.nodes.values()) {
                child.addNodeGene(new NodeGene(node.id, node.type, node.layer));
            }
            for (const conn of this.connections.values()) {
                const matching = other.connections.get(conn.innovation);
                const pick = matching && Math.random() < 0.5 ? matching : conn;
                child.addConnectionGene(new ConnectionGene(conn.innovation, pick.inNode, pick.outNode, pick.weight, pick.enabled && conn.enabled));
            }
            return child;
        }
        static compatibilityDistance(a, b, params) {
            const keysA = Array.from(a.connections.keys()).sort((x, y) => x - y);
            const keysB = Array.from(b.connections.keys()).sort((x, y) => x - y);
            let i = 0, j = 0;
            let disjoint = 0, excess = 0, weightDiff = 0, matches = 0;
            const maxA = keysA.length ? keysA[keysA.length - 1] : 0;
            const maxB = keysB.length ? keysB[keysB.length - 1] : 0;
            while (i < keysA.length && j < keysB.length) {
                const ia = keysA[i];
                const ib = keysB[j];
                if (ia === ib) {
                    const wa = a.connections.get(ia).weight;
                    const wb = b.connections.get(ib).weight;
                    weightDiff += Math.abs(wa - wb);
                    matches++;
                    i++; j++;
                } else if (ia < ib) {
                    disjoint++;
                    i++;
                } else {
                    disjoint++;
                    j++;
                }
            }
            if (i < keysA.length) excess += keysA.length - i;
            if (j < keysB.length) excess += keysB.length - j;
            const N = Math.max(a.connections.size, b.connections.size, 1);
            const avgW = matches ? weightDiff / matches : 0;
            return params.c1 * excess / N + params.c2 * disjoint / N + params.c3 * avgW;
        }
    }

    class Species {
        constructor(representative) {
            this.representative = representative.clone();
            this.members = [];
            this.bestFitness = -Infinity;
            this.stagnant = 0;
        }
        addMember(genome) {
            this.members.push(genome);
        }
        resetMembers() {
            this.members = [];
        }
        updateStagnation() {
            const best = Math.max(...this.members.map(m => m.fitness));
            if (best > this.bestFitness) {
                this.bestFitness = best;
                this.stagnant = 0;
            } else {
                this.stagnant++;
            }
        }
    }

    class Population {
        constructor(config) {
            this.config = config;
            this.tracker = new InnovationTracker();
            this.genomes = [];
            this.species = [];
            this.generation = 1;
            this.globalBest = null;
            this.globalBestFitness = -Infinity;
            this.initPopulation();
        }
        initPopulation() {
            this.genomes = [];
            this.species = [];
            const inputs = 10;
            const outputs = 4;
            const biasNodeId = this.tracker.newNodeId();
            const inputNodes = [];
            for (let i = 0; i < inputs; i++) {
                inputNodes.push(new NodeGene(this.tracker.newNodeId(), NODE_TYPES.INPUT, 0));
            }
            const biasNode = new NodeGene(biasNodeId, NODE_TYPES.BIAS, 0);
            const outputNodes = [];
            for (let i = 0; i < outputs; i++) {
                outputNodes.push(new NodeGene(this.tracker.newNodeId(), NODE_TYPES.OUTPUT, 1));
            }
            for (let i = 0; i < this.config.populationSize; i++) {
                const genome = new Genome(this.tracker);
                inputNodes.forEach(node => genome.addNodeGene(new NodeGene(node.id, node.type, node.layer)));
                genome.addNodeGene(new NodeGene(biasNode.id, biasNode.type, biasNode.layer));
                outputNodes.forEach(node => genome.addNodeGene(new NodeGene(node.id, node.type, node.layer)));
                for (const inNode of [...inputNodes, biasNode]) {
                    for (const outNode of outputNodes) {
                        const innov = this.tracker.getInnovation(inNode.id, outNode.id);
                        genome.addConnectionGene(new ConnectionGene(innov, inNode.id, outNode.id, Math.random() * 2 - 1, true));
                    }
                }
                genome.mutateWeights();
                this.genomes.push(genome);
            }
            this.speciate();
        }
        speciate() {
            for (const species of this.species) {
                species.resetMembers();
            }
            for (const genome of this.genomes) {
                let assigned = false;
                for (const species of this.species) {
                    const dist = Genome.compatibilityDistance(genome, species.representative, this.config);
                    if (dist < this.config.compatibilityThreshold) {
                        species.addMember(genome);
                        assigned = true;
                        break;
                    }
                }
                if (!assigned) {
                    const species = new Species(genome);
                    species.addMember(genome);
                    this.species.push(species);
                }
            }
            this.species = this.species.filter(s => s.members.length > 0);
            if (this.species.length > this.config.speciesTarget) {
                this.config.compatibilityThreshold += 0.05;
            } else if (this.species.length < this.config.speciesTarget) {
                this.config.compatibilityThreshold = Math.max(0.5, this.config.compatibilityThreshold - 0.05);
            }
        }
        recordFitness(genome, fitness) {
            genome.fitness = fitness;
            if (fitness > this.globalBestFitness) {
                this.globalBestFitness = fitness;
                this.globalBest = genome.clone();
            }
        }
        prepareNextGeneration() {
            for (const species of this.species) {
                for (const member of species.members) {
                    member.adjustedFitness = member.fitness / species.members.length;
                }
            }
            const totalAdjusted = this.genomes.reduce((sum, g) => sum + g.adjustedFitness, 0) || 1;
            const newGenomes = [];
            const eliteCount = Math.max(1, Math.floor(this.config.elitism * this.config.populationSize));
            const sorted = [...this.genomes].sort((a, b) => b.fitness - a.fitness);
            for (let i = 0; i < eliteCount; i++) {
                newGenomes.push(sorted[i].clone());
            }
            while (newGenomes.length < this.config.populationSize) {
                const parentA = this.selectParent(totalAdjusted);
                const parentB = this.selectParent(totalAdjusted);
                const fitter = parentA.fitness >= parentB.fitness ? parentA : parentB;
                const weaker = fitter === parentA ? parentB : parentA;
                const child = fitter.crossover(weaker);
                this.mutate(child);
                newGenomes.push(child);
            }
            this.genomes = newGenomes;
            this.generation++;
            this.speciate();
        }
        selectParent(totalAdjusted) {
            let r = Math.random() * totalAdjusted;
            for (const genome of this.genomes) {
                r -= genome.adjustedFitness;
                if (r <= 0) return genome;
            }
            return this.genomes[this.genomes.length - 1];
        }
        mutate(genome) {
            if (Math.random() < this.config.mutationRate) genome.mutateWeights();
            if (Math.random() < 0.05) genome.mutateToggle();
            if (Math.random() < this.config.addNodeRate) genome.mutateAddNode();
            if (Math.random() < this.config.addConnectionRate) genome.mutateAddConnection();
        }
    }

    const MODES = ["training", "best", "manual"];

    class Controller {
        constructor() {
            this.modeIndex = 0;
            this.manual = { jumpHeld: false, accel: false, brake: false, jumpPressed: false, jumpLatched: false };
            this.prevNetwork = [0, 0, 0, 0];
            this.currentNetwork = [0, 0, 0, 0];
            this.bindInputs();
        }
        bindInputs() {
            window.addEventListener('keydown', e => {
                if (e.repeat) return;
                switch (e.code) {
                    case 'Space':
                        e.preventDefault();
                        toggleMode();
                        break;
                    case 'KeyR':
                        e.preventDefault();
                        resetEpisode(currentEpisode.params.seed);
                        break;
                    case 'Enter':
                        e.preventDefault();
                        newSeed();
                        break;
                    case 'ArrowUp':
                    case 'KeyW':
                        this.manual.jumpHeld = true;
                        this.manual.jumpPressed = true;
                        break;
                    case 'ArrowRight':
                    case 'KeyD':
                        this.manual.accel = true;
                        break;
                    case 'ArrowLeft':
                    case 'KeyA':
                        this.manual.brake = true;
                        break;
                }
            });
            window.addEventListener('keyup', e => {
                switch (e.code) {
                    case 'ArrowUp':
                    case 'KeyW':
                        this.manual.jumpHeld = false;
                        this.manual.jumpLatched = false;
                        break;
                    case 'ArrowRight':
                    case 'KeyD':
                        this.manual.accel = false;
                        break;
                    case 'ArrowLeft':
                    case 'KeyA':
                        this.manual.brake = false;
                        break;
                }
            });
        }
        get mode() {
            return MODES[this.modeIndex];
        }
        setMode(mode) {
            const idx = MODES.indexOf(mode);
            if (idx >= 0) this.modeIndex = idx;
        }
        nextMode() {
            this.modeIndex = (this.modeIndex + 1) % MODES.length;
            return this.mode;
        }
        getAction(state, genome) {
            if (this.mode === 'manual') {
                const jumpPressed = !!this.manual.jumpPressed && !this.manual.jumpLatched;
                this.manual.jumpLatched = !!this.manual.jumpPressed;
                this.manual.jumpPressed = false;
                return {
                    jumpPressed,
                    jumpHeld: this.manual.jumpHeld,
                    accel: this.manual.accel,
                    brake: this.manual.brake
                };
            }
            if (!genome) {
                return { jumpPressed: false, jumpHeld: false, accel: false, brake: false };
            }
            const inputs = [
                state.vx,
                state.vy,
                state.onGround ? 1 : 0,
                state.groundSlope,
                state.distToNextGap,
                state.upcomingSlope,
                state.stuckTimer,
                state.heightAboveFloor,
                state.speedNormalized,
                1
            ];
            const outputs = genome.feedForward(inputs);
            this.prevNetwork = this.currentNetwork;
            this.currentNetwork = outputs;
            const jumpPressed = this.prevNetwork[0] <= 0.5 && outputs[0] > 0.5;
            const jumpHeld = outputs[1] > 0.5;
            return {
                jumpPressed,
                jumpHeld,
                accel: outputs[2] > 0.5,
                brake: outputs[3] > 0.5
            };
        }
    }

    class Trainer {
        constructor(population, params) {
            this.population = population;
            this.params = params;
            this.activeIndex = 0;
            this.currentGenome = population.genomes[0];
            this.fastTrain = false;
        }
        setFastTrain(flag) {
            this.fastTrain = flag;
        }
        get generation() {
            return this.population.generation;
        }
        get bestGenome() {
            return this.population.globalBest;
        }
        nextGenome() {
            this.activeIndex = (this.activeIndex + 1) % this.population.genomes.length;
            this.currentGenome = this.population.genomes[this.activeIndex];
            return this.currentGenome;
        }
        recordEpisode(fitness) {
            this.population.recordFitness(this.currentGenome, fitness);
            if (this.activeIndex === this.population.genomes.length - 1) {
                this.population.prepareNextGeneration();
                this.activeIndex = 0;
            } else {
                this.activeIndex++;
            }
            this.currentGenome = this.population.genomes[this.activeIndex];
        }
    }

    class Renderer {
        constructor(canvas, params) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');
            this.params = params;
            this.camera = { x: -150, y: 350 };
        }
        draw(episode, controller, trainer, hudElem, params) {
            const ctx = this.ctx;
            const { ball, track } = episode;
            const camTargetX = ball.x - 200;
            const camTargetY = ball.y - 120;
            this.camera.x = lerp(this.camera.x, camTargetX, 0.08);
            this.camera.y = lerp(this.camera.y, camTargetY, 0.08);
            ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            ctx.save();
            ctx.translate(-this.camera.x, -this.camera.y);

            ctx.fillStyle = '#141a2d';
            ctx.fillRect(this.camera.x, this.camera.y, this.canvas.width, this.canvas.height);

            this.drawTrack(track);
            this.drawBall(ball, params.showNormals);
            ctx.restore();
            this.drawHUD(episode, controller, trainer, hudElem, params);
        }
        drawTrack(track) {
            const ctx = this.ctx;
            ctx.lineWidth = 6;
            ctx.strokeStyle = 'rgba(120, 160, 255, 0.7)';
            ctx.beginPath();
            let started = false;
            for (const seg of track.segments) {
                if (seg.gap) {
                    started = false;
                    continue;
                }
                if (!started) {
                    ctx.moveTo(seg.startX, seg.startY);
                    started = true;
                }
                ctx.lineTo(seg.endX, seg.endY);
            }
            ctx.stroke();
            ctx.lineWidth = 1;
            ctx.strokeStyle = 'rgba(0,0,0,0.4)';
            ctx.beginPath();
            for (const seg of track.segments) {
                if (seg.gap) continue;
                ctx.moveTo(seg.startX, seg.endY);
                ctx.lineTo(seg.endX, 900);
            }
            ctx.stroke();
        }
        drawBall(ball, showNormals) {
            const ctx = this.ctx;
            const gradient = ctx.createRadialGradient(ball.x - 10, ball.y - 10, 6, ball.x, ball.y, ball.radius);
            gradient.addColorStop(0, '#ffffff');
            gradient.addColorStop(1, '#ff9f43');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.lineWidth = 2;
            ctx.strokeStyle = 'rgba(255,255,255,0.4)';
            ctx.stroke();
            if (showNormals && ball.onGround) {
                ctx.strokeStyle = '#6cf';
                ctx.beginPath();
                ctx.moveTo(ball.x, ball.y);
                ctx.lineTo(ball.x + ball.groundNormal.x * 60, ball.y + ball.groundNormal.y * 60);
                ctx.stroke();
            }
        }
        drawHUD(ep, controller, trainer, hudElem, params) {
            const rewardPerSec = ep.ball.reward / Math.max(ep.elapsed, 0.001);
            const stuckWarn = ep.ball.stuckCountdown < params.stuckTime * 0.6 ? `<span class="stuck-warning">Stuck: ${ep.ball.stuckCountdown.toFixed(2)}s</span>` : `<span>Stuck: ${ep.ball.stuckCountdown.toFixed(2)}s</span>`;
            const bestFitness = Number.isFinite(trainer.population.globalBestFitness) ? trainer.population.globalBestFitness.toFixed(2) : 'N/A';
            hudElem.innerHTML = `
                <span><strong>Mode:</strong> ${controller.mode.toUpperCase()}</span>
                <span><strong>Time:</strong> ${ep.elapsed.toFixed(2)}s</span>
                <span><strong>Distance:</strong> ${ep.ball.x.toFixed(1)}</span>
                <span><strong>Reward/sec:</strong> ${rewardPerSec.toFixed(2)}</span>
                ${stuckWarn}
                <span><strong>Seed:</strong> ${ep.params.seed}</span>
                <span><strong>Generation:</strong> ${trainer.generation}</span>
                <span><strong>Best fitness:</strong> ${bestFitness}</span>
            `;
        }
    }

    const canvas = document.getElementById('game');
    const hudElem = document.getElementById('hud');
    const overlayElem = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlay-title');
    const overlaySubtitle = document.getElementById('overlay-subtitle');
    const panel = document.getElementById('side-panel');
    const togglePanelBtn = document.getElementById('toggle-panel');
    const collapseBtn = document.getElementById('collapse-btn');
    const saveStatus = document.getElementById('save-status');
    const panelInputs = panel.querySelectorAll('[data-param]');

    const defaultParams = {
        seed: Math.random().toString(36).slice(2, 9),
        gravity: 550,
        groundFriction: 2,
        accelPower: 180,
        brakeStrength: 220,
        slopeForce: 180,
        stuckTime: 4,
        stuckDeltaThreshold: 0.6,
        coyoteTime: 0.1,
        jumpBufferTime: 0.1,
        jumpImpulse: 360,
        jumpCutScale: 2.4,
        rewardSurvival: 1.4,
        rewardForward: 0.4,
        penaltyBrake: 0.5,
        penaltyStuck: 1.2,
        targetSpeed: 600,
        gapFrequency: 0.25,
        populationSize: 24,
        mutationRate: 0.2,
        addNodeRate: 0.03,
        addConnectionRate: 0.18,
        elitism: 0.1,
        c1: 1,
        c2: 1,
        c3: 0.4,
        compatibilityThreshold: 2.6,
        speciesTarget: 5,
        showNormals: false,
        fastTrain: false,
        autoRestart: true
    };

    function syncPanel(params) {
        panel.querySelector('[data-param="seedText"]').value = params.seed;
    }

    panelInputs.forEach(input => {
        const key = input.dataset.param;
        if (key in defaultParams) {
            if (input.type === 'checkbox') {
                input.checked = !!defaultParams[key];
            } else if (input.type !== 'text') {
                input.value = defaultParams[key];
            }
        }
        input.addEventListener('input', () => {
            applyPanelChange(key, input);
        });
    });

    function applyPanelChange(key, input) {
        const value = input.type === 'checkbox' ? input.checked : (input.type === 'number' ? Number(input.value) : input.value);
        switch (key) {
            case 'gravity': currentEpisode.params.gravity = Number(value); break;
            case 'friction': currentEpisode.params.groundFriction = Number(value); break;
            case 'accel': currentEpisode.params.accelPower = Number(value); break;
            case 'brake': currentEpisode.params.brakeStrength = Number(value); break;
            case 'stuckTime': currentEpisode.params.stuckTime = Number(value); break;
            case 'gapFreq': currentEpisode.params.gapFrequency = Number(value); break;
            case 'population': trainer.population.config.populationSize = Number(value); break;
            case 'mutation': trainer.population.config.mutationRate = Number(value); break;
            case 'addNode': trainer.population.config.addNodeRate = Number(value); break;
            case 'addConn': trainer.population.config.addConnectionRate = Number(value); break;
            case 'elitism': trainer.population.config.elitism = Number(value); break;
            case 'c1': trainer.population.config.c1 = Number(value); break;
            case 'c2': trainer.population.config.c2 = Number(value); break;
            case 'c3': trainer.population.config.c3 = Number(value); break;
            case 'compatThreshold': trainer.population.config.compatibilityThreshold = Number(value); break;
            case 'speciesTarget': trainer.population.config.speciesTarget = Number(value); break;
            case 'showNormals': currentEpisode.params.showNormals = value; break;
            case 'fastTrain': controllerFastTrain(value); break;
            case 'autoRestart': currentEpisode.params.autoRestart = value; break;
            case 'seedText': break;
            default:
                currentEpisode.params[key] = value;
        }
    }

    togglePanelBtn.addEventListener('click', () => {
        panel.classList.toggle('collapsed');
    });
    collapseBtn.addEventListener('click', () => {
        panel.classList.toggle('collapsed');
    });

    panel.querySelectorAll('[data-action]').forEach(btn => {
        btn.addEventListener('click', () => {
            const act = btn.dataset.action;
            if (act === 'new-seed') {
                newSeed();
            } else if (act === 'use-seed') {
                const input = panel.querySelector('[data-param="seedText"]').value.trim();
                if (input) resetEpisode(input);
            } else if (act === 'save-best') {
                saveBest();
            } else if (act === 'load-best') {
                loadBest();
            } else if (act === 'clear-best') {
                clearBest();
            }
        });
    });

    overlayElem.querySelectorAll('button').forEach(btn => {
        btn.addEventListener('click', () => {
            const act = btn.dataset.action;
            if (act === 'restart') {
                resetEpisode(currentEpisode.params.seed);
            } else if (act === 'new-seed') {
                newSeed();
            } else if (act === 'toggle-mode') {
                toggleMode();
            }
        });
    });

    function showOverlay(title, subtitle) {
        overlayTitle.textContent = title;
        overlaySubtitle.textContent = subtitle;
        overlayElem.hidden = false;
    }

    function hideOverlay() {
        overlayElem.hidden = true;
    }

    const populationConfig = {
        populationSize: defaultParams.populationSize,
        mutationRate: defaultParams.mutationRate,
        addNodeRate: defaultParams.addNodeRate,
        addConnectionRate: defaultParams.addConnectionRate,
        elitism: defaultParams.elitism,
        c1: defaultParams.c1,
        c2: defaultParams.c2,
        c3: defaultParams.c3,
        compatibilityThreshold: defaultParams.compatibilityThreshold,
        speciesTarget: defaultParams.speciesTarget
    };

    const population = new Population(populationConfig);
    const trainer = new Trainer(population, populationConfig);
    const controller = new Controller();
    const renderer = new Renderer(canvas, defaultParams);

    const episodeParams = { ...defaultParams };
    const currentEpisode = new Episode(episodeParams);
    syncPanel(currentEpisode.params);

    let lastTime = performance.now();
    let accumulator = 0;

    function controllerFastTrain(flag) {
        defaultParams.fastTrain = flag;
        trainer.setFastTrain(flag);
    }

    function update(dt) {
        const mode = controller.mode;
        const stepDt = 1 / 120;
        const clamped = Math.min(dt, 0.05);
        accumulator += clamped;
        const iterations = trainer.fastTrain && mode === 'training' ? 3 : 1;
        for (let i = 0; i < iterations; i++) {
            while (accumulator >= stepDt) {
                step(stepDt);
                accumulator -= stepDt;
            }
        }
    }

    function step(dt) {
        if (currentEpisode.done) {
            if (currentEpisode.params.autoRestart) {
                handleEpisodeEnd();
                return;
            }
            return;
        }
        const rawState = currentEpisode.getState();
        const inputs = rawState.normalized;
        const genome = controller.mode === 'training' ? trainer.currentGenome : controller.mode === 'best' ? trainer.bestGenome : null;
        const action = controller.getAction(inputs, genome);
        currentEpisode.update(action, dt);
        if (typeof window.onStep === 'function') {
            window.onStep(rawState, action, currentEpisode.lastReward, currentEpisode.done);
        }
        if (currentEpisode.done) {
            handleEpisodeEnd();
        }
    }

    function handleEpisodeEnd() {
        const fitness = currentEpisode.ball.reward;
        const reason = currentEpisode.reason || 'Finished';
        const auto = !!currentEpisode.params.autoRestart;
        const mode = controller.mode;
        if (mode === 'training') {
            trainer.recordEpisode(fitness);
            if (auto) {
                resetEpisode(currentEpisode.params.seed);
            }
        } else if (mode === 'best') {
            if (auto) {
                resetEpisode(currentEpisode.params.seed);
            }
        }
        const shouldShowOverlay = !auto || mode === 'manual';
        if (shouldShowOverlay) {
            showOverlay(`Episode Over (${reason})`, `Fitness: ${fitness.toFixed(2)}`);
        }
    }

    function loop(now) {
        const dt = (now - lastTime) / 1000;
        lastTime = now;
        update(dt);
        renderer.draw(currentEpisode, controller, trainer, hudElem, currentEpisode.params);
        requestAnimationFrame(loop);
    }

    function toggleMode() {
        const mode = controller.nextMode();
        if (mode === 'training') {
            resetEpisode(currentEpisode.params.seed);
        } else if (mode === 'best') {
            if (trainer.bestGenome) {
                resetEpisode(currentEpisode.params.seed);
            }
        } else if (mode === 'manual') {
            resetEpisode(currentEpisode.params.seed);
        }
    }

    function resetEpisode(seed, genomeOverride) {
        const rngSeed = seed || Math.random().toString(36).slice(2, 9);
        currentEpisode.reset(rngSeed);
        currentEpisode.params.seed = rngSeed;
        syncPanel(currentEpisode.params);
        if (controller.mode === 'training') {
            trainer.currentGenome = genomeOverride || trainer.population.genomes[trainer.activeIndex];
        }
        controller.prevNetwork = [0, 0, 0, 0];
        controller.currentNetwork = [0, 0, 0, 0];
        controller.manual.jumpHeld = false;
        controller.manual.accel = false;
        controller.manual.brake = false;
        controller.manual.jumpPressed = false;
        controller.manual.jumpLatched = false;
        hideOverlay();
    }

    function newSeed() {
        resetEpisode(Math.random().toString(36).slice(2, 9));
    }

    function saveBest() {
        if (!trainer.bestGenome) {
            saveStatus.textContent = 'No best genome yet.';
            return;
        }
        const data = {
            fitness: trainer.population.globalBestFitness,
            genome: serializeGenome(trainer.bestGenome)
        };
        localStorage.setItem('rollingBallBest', JSON.stringify(data));
        saveStatus.textContent = 'Saved best genome to localStorage.';
    }

    function loadBest() {
        const raw = localStorage.getItem('rollingBallBest');
        if (!raw) {
            saveStatus.textContent = 'No saved genome found.';
            return;
        }
        try {
            const data = JSON.parse(raw);
            const genome = deserializeGenome(data.genome);
            trainer.population.globalBest = genome;
            trainer.population.globalBestFitness = data.fitness;
            trainer.currentGenome = genome;
            trainer.setFastTrain(false);
            controller.setMode('best');
            resetEpisode(currentEpisode.params.seed);
            saveStatus.textContent = 'Loaded best genome.';
        } catch (err) {
            console.error(err);
            saveStatus.textContent = 'Failed to load genome.';
        }
    }

    function clearBest() {
        localStorage.removeItem('rollingBallBest');
        saveStatus.textContent = 'Cleared saved genome.';
    }

    function serializeGenome(genome) {
        return {
            nodes: Array.from(genome.nodes.values()).map(n => ({ id: n.id, type: n.type, layer: n.layer })),
            connections: Array.from(genome.connections.values()).map(c => ({ innovation: c.innovation, inNode: c.inNode, outNode: c.outNode, weight: c.weight, enabled: c.enabled }))
        };
    }

    function deserializeGenome(data) {
        const genome = new Genome(population.tracker);
        let maxNode = 0;
        let maxInnovation = 0;
        data.nodes.forEach(n => {
            genome.addNodeGene(new NodeGene(n.id, n.type, n.layer));
            maxNode = Math.max(maxNode, n.id);
        });
        data.connections.forEach(c => {
            genome.addConnectionGene(new ConnectionGene(c.innovation, c.inNode, c.outNode, c.weight, c.enabled));
            maxInnovation = Math.max(maxInnovation, c.innovation);
            const key = `${c.inNode}->${c.outNode}`;
            population.tracker.map.set(key, c.innovation);
        });
        population.tracker.nextNodeId = Math.max(population.tracker.nextNodeId, maxNode + 1);
        population.tracker.nextInnovation = Math.max(population.tracker.nextInnovation, maxInnovation + 1);
        return genome;
    }

    if (typeof window.onStep !== 'function') {
        window.onStep = function(state, action, reward, done) {
            // hook placeholder for analytics
        };
    }

    window.getEpisode = function() {
        return currentEpisode;
    };

    window.resetEpisode = resetEpisode;
    window.toggleMode = toggleMode;
    window.newSeed = newSeed;

    requestAnimationFrame(function start(now) {
        lastTime = now;
        loop(now);
    });
    </script>
</body>
</html>
