<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>NEAT Data Sorting Simulation - Enhanced Input</title>
  <style>
    :root {
      /* New Color Palette - Sci-Fi / Dark Mode */
      --bg-dark: #050a14;
      --panel-bg: rgba(10, 15, 30, 0.95);
      --accent: #00eaff; /* Cyan */
      --accent-ok: #00ff99; /* Green */
      --accent-bad: #ff3366; /* Red */
      --text-main: #e8f0ff;
      --text-dim: #94a3b8;
      --font-mono: 'Fira Code', Consolas, monospace;
      --font-ui: 'Inter', system-ui, sans-serif;
    }
    * { box-sizing: border-box; user-select: none; }
    body {
      margin: 0; overflow: hidden; background: var(--bg-dark); color: var(--text-main);
      font-family: var(--font-ui); display: flex; height: 100vh;
    }
    
    /* Layout */
    .sidebar {
      width: 360px; flex-shrink: 0; display: flex; flex-direction: column;
      background: var(--panel-bg); border-right: 1px solid #334;
      backdrop-filter: blur(10px); z-index: 10; overflow-y: auto;
    }
    .main-view { 
        flex: 1; 
        position: relative; 
    }
    
    /* Viewport with improved background gradient */
    .viewport { 
        width: 100%;
        height: 100%;
        position: relative; 
        background: radial-gradient(circle at 50% 30%, #101c30 0%, #050a14 80%); 
        overflow: hidden; 
    }
    canvas#simCanvas { display: block; width: 100%; height: 100%; cursor: crosshair; }
    
    /* UI Elements */
    .panel-section { padding: 15px; border-bottom: 1px solid #334; }
    h1 { font-size: 18px; margin: 0 0 10px; color: var(--accent); text-transform: uppercase; letter-spacing: 1px; text-align: center; }
    h2 { font-size: 12px; margin: 15px 0 8px; color: var(--text-dim); text-transform: uppercase; letter-spacing: 0.5px; border-bottom: 1px solid #334; padding-bottom: 4px; }
    
    .stat-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; }
    .stat-box { background: rgba(0,0,0,0.3); padding: 8px; border-radius: 6px; border: 1px solid #334; display:flex; flex-direction:column; }
    .stat-label { font-size: 10px; color: var(--text-dim); margin-bottom: 2px; }
    .stat-val { font-size: 15px; font-weight: bold; font-family: var(--font-mono); color: #fff; }
    
    .control-group { margin-bottom: 12px; }
    label { display: flex; justify-content: space-between; font-size: 11px; margin-bottom: 4px; color: var(--text-dim); }
    label span { color: var(--accent); font-family: var(--font-mono); }
    input[type=range] { width: 100%; accent-color: var(--accent); height: 4px; border-radius: 2px; background: #334; cursor: pointer; }
    
    .btn-group { display: flex; gap: 5px; margin-top: 5px; }
    .btn {
      flex: 1; padding: 10px; background: linear-gradient(90deg, rgba(0,234,255,0.1), rgba(0,234,255,0.2));
      border: 1px solid var(--accent); color: var(--accent); font-weight: bold; text-transform: uppercase; font-size: 11px;
      cursor: pointer; transition: all 0.2s; border-radius: 4px; letter-spacing: 1px;
    }
    .btn:hover { background: var(--accent); color: #000; box-shadow: 0 0 15px var(--accent); }
    .btn.danger { border-color: var(--accent-bad); color: var(--accent-bad); background: rgba(255,51,102,0.1); }
    .btn.danger:hover { background: var(--accent-bad); color: #fff; box-shadow: 0 0 15px var(--accent-bad); }
    .btn.alt { border-color: var(--accent-ok); color: var(--accent-ok); background: rgba(0,255,153,0.1); }
    .btn.alt:hover { background: var(--accent-ok); color: #000; box-shadow: 0 0 15px var(--accent-ok); }

    
    /* HUD Overlay */
    .hud { position: absolute; pointer-events: none; padding: 20px; width: 100%; display: flex; justify-content: space-between; top: 0; }
    .generation-display { font-size: 40px; font-weight: 900; color: rgba(255,255,255,0.1); font-family: var(--font-mono); }
    .live-feed { position: absolute; bottom: 20px; left: 20px; max-width: 300px; display: flex; flex-direction: column-reverse; gap: 5px; pointer-events: none; }
    .feed-item { background: rgba(0,0,0,0.6); padding: 6px 10px; border-radius: 4px; font-size: 11px; border-left: 3px solid var(--text-dim); animation: fadeIn 0.3s ease-out; }
    .feed-item.good { border-color: var(--accent-ok); }
    .feed-item.warn { border-color: #ff9900; }
    .feed-item.bad { border-color: var(--accent-bad); }
    
    @keyframes fadeIn { from { opacity: 0; transform: translateX(-10px); } to { opacity: 1; transform: translateX(0); } }

    /* Brain & Graph */
    #brainCanvas { 
        width: 100%; 
        height: 150px; 
        background: #0a0a12; 
        border: 1px solid #334; 
        border-radius: 6px; 
        margin-top: 5px; 
    }
    #fitnessGraph { width: 100%; height: 70px; background: #0a0a12; border: 1px solid #334; border-radius: 6px; margin-top: 5px; }
    
    .checkbox-row { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; font-size: 12px; cursor: pointer; }
    .checkbox-row input { accent-color: var(--accent); }
    
    /* Agent Hover Tooltip */
    #hoverTip {
        position: absolute; background: rgba(0,0,0,0.85); padding: 8px; border-radius: 4px; border: 1px solid var(--accent);
        font-size: 10px; font-family: var(--font-mono); color: var(--text-main); pointer-events: none; z-index: 1000;
        transform: translate(15px, 15px); transition: opacity 0.1s; opacity: 0;
        line-height: 1.6;
    }

    /* Top Bar for Simulation View */
    .sim-top-bar {
        position: absolute; top: 0; left: 0; width: 100%;
        display: flex; justify-content: space-between; align-items: center;
        padding: 8px 20px; background: rgba(0,0,0,0.2);
        color: var(--text-dim); font-size: 11px;
    }
    .sim-top-bar .fps-counter { font-family: var(--font-mono); color: var(--accent-ok); }
  </style>
</head>
<body>

<aside class="sidebar">
  <div class="panel-section">
    <h1>NEAT Control Console</h1>
    
    <div class="stat-grid">
      <div class="stat-box">
        <span class="stat-label">Generation</span>
        <span class="stat-val" id="dispGen">1</span>
      </div>
      <div class="stat-box">
        <span class="stat-label">Best Fitness</span>
        <span class="stat-val" id="dispFit" style="color:var(--accent-ok)">0.0</span>
      </div>
      <div class="stat-box">
        <span class="stat-label">Accuracy</span>
        <span class="stat-val" id="dispAcc">0%</span>
      </div>
      <div class="stat-box">
        <span class="stat-label">Successes</span>
        <span class="stat-val" id="dispSolved" style="color:var(--accent-ok)">0</span>
      </div>
      <div class="stat-box">
        <span class="stat-label">Mistakes</span>
        <span class="stat-val" id="dispWrong" style="color:var(--accent-bad)">0</span>
      </div>
      <div class="stat-box">
        <span class="stat-label">Active Agents</span>
        <span class="stat-val" id="dispActive">40/40</span>
      </div>
    </div>
  </div>
  
  <div class="panel-section">
    <h2>Fitness History</h2>
    <canvas id="fitnessGraph"></canvas>
  </div>
  
  <div class="panel-section">
      <h2>Active Brain (Best Agent)</h2>
      <canvas id="brainCanvas" width="300" height="150"></canvas>
      <div style="font-size:10px; color:#667; text-align:center">Live Neural Network Activity (Red=Negative, Green=Positive)</div>
  </div>

  <div class="panel-section">
    <h2>Simulation Controls</h2>
    
    <div class="control-group">
      <label>Game Speed: <span id="valSpeed">1x</span></label>
      <input type="range" id="slSpeed" min="1" max="20" value="1">
    </div>

    <div class="control-group">
      <label>Population Size: <span id="valPop">40</span></label>
      <input type="range" id="slPop" min="10" max="100" value="40">
    </div>

    <div class="control-group">
      <label title="Antal biljetter i spelområdet">Ticket Count: <span id="valTickets">15</span></label>
      <input type="range" id="slTicketCount" min="5" max="50" value="15">
    </div>
    
    <div class="control-group">
      <label title="Antal frames per generation">Generation Duration (Frames): <span id="valDuration">2500</span></label>
      <input type="range" id="slDuration" min="500" max="10000" step="100" value="2500">
    </div>
    
    <div class="btn-group">
        <button class="btn alt" id="btnResetAI">Reset AI Only</button>
        <button class="btn" id="btnSkip">Insta-Train (Skip Gen)</button>
    </div>
    <button class="btn danger" id="btnReset">Hard Reset All</button>
  </div>

  <div class="panel-section">
    <h2>Game Physics</h2>
    
    <div class="control-group">
      <label title="Hur långt agenterna kan se">Sensor Range: <span id="valSensor">180px</span></label>
      <input type="range" id="slSensor" min="50" max="400" value="180">
    </div>
    
    <div class="control-group">
      <label title="Högre = Batterier dör snabbare">Battery Drain: <span id="valDrain">Normal</span></label>
      <input type="range" id="slDrain" min="1" max="20" value="8">
    </div>
  </div>
  
  <div class="panel-section">
    <h2>NEAT & Topology Tweaks</h2>

    <div class="control-group">
      <label title="Antal noder i dolda lagret. Högre = Mer komplex logik">Hidden Nodes: <span id="valHidden">20</span></label>
      <input type="range" id="slHidden" min="8" max="40" step="4" value="20">
    </div>

    <div class="control-group">
      <label title="Högre = Mer kaos/testning">Mutation Rate: <span id="valMut">10%</span></label>
      <input type="range" id="slMut" min="1" max="50" value="10">
    </div>

    <div class="control-group">
      <label>Elite Count: <span id="valElite">4</span></label>
      <input type="range" id="slElite" min="1" max="10" value="4">
    </div>

    <div class="control-group">
      <label title="Andel av den bästa populationen som får reproducera sig (Rank Selection)">Selection Pool: <span id="valSelection">50%</span></label>
      <input type="range" id="slSelection" min="20" max="80" step="10" value="50">
    </div>
  </div>

  <div class="panel-section">
    <h2>Visuals</h2>
    <label class="checkbox-row"><input type="checkbox" id="chkBrainViz" checked> Show Brain Visualization</label>
    <label class="checkbox-row"><input type="checkbox" id="chkSensors"> Show LIDAR Rays</label>
    <label class="checkbox-row"><input type="checkbox" id="chkHeatmap"> Show Traffic Heatmap</label>
    <label class="checkbox-row"><input type="checkbox" id="chkParticles" checked> Show Particles (Feedback)</label>
    <label class="checkbox-row"><input type="checkbox" id="chkTrail"> Show Best Agent Trail</label>
  </div>
</aside>

<main class="main-view">
  <div class="viewport">
    <div class="sim-top-bar">
        <span><strong style="color:var(--accent)">NEAT-DS:</strong> Ticket Routing Simulation</span>
        <span class="fps-counter" id="fpsDisplay">FPS: 0</span>
    </div>
    <canvas id="simCanvas"></canvas>
    <div class="hud">
      <div class="generation-display" id="hudGen">GEN 1</div>
      <div style="text-align:right; font-size:12px; color:rgba(255,255,255,0.4)">
        <p>[SPACE] Pause | [S] Skip Gen | Click & Drag Agent / NEST / Zone</p>
      </div>
    </div>
    <div class="live-feed" id="feed"></div>
    <div id="hoverTip"></div>
  </div>
</main>

<script>
// --- CONFIGURATION OBJECT (Mutable) ---
const CFG = {
  popSize: 40,
  mutationRate: 0.1,
  eliteCount: 4,
  selectionPoolRatio: 0.5, 
  ticketCount: 15,
  sensorRange: 180, 
  sensorCount: 5, 
  fov: Math.PI * 0.8,
  maxSpeed: 4.0, 
  turnRate: 0.08, 
  genDuration: 2500, // FRAME COUNT PER GENERATION
  energyDrain: 0.0008, 
  inputs: 16, // **UPDATED: 12 -> 16**
  hiddens: 20, // **UPDATED: 16 -> 20 (More capacity for new inputs)**
  outputs: 6, // [SteerLeft, SteerRight, Forward, Reverse, Brake, Memory]
  categories: [
    { id: 'incident', color: '#ff3366', label: 'Incident' }, /* Red */
    { id: 'request', color: '#00ff99', label: 'Service Req' }, /* Green */
    { id: 'problem', color: '#00eaff', label: 'Problem' } /* Cyan */
  ]
};

// --- GLOBALS ---
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
const brainCanvas = document.getElementById('brainCanvas');
const brainCtx = brainCanvas.getContext('2d');
const hoverTip = document.getElementById('hoverTip');
const fpsDisplay = document.getElementById('fpsDisplay');

let W, H;
let maxWorldDist = 1; // Used for normalization
let frame = 0;
let generation = 1;
let speedMult = 1;
let paused = false;
let agents = [];
let tickets = [];
let particles = [];
let bestBrain = null;
let history = [];
let nest = null; 
let goalZones = []; 
let mouse = { x:0, y:0, down:false, dragAgent:null, dragNest: false, dragZone: null }; 
let zoneHighlight = null; 

// FPS Counter Variables
let lastFrameTime = 0;
let fps = 0;

// Stats
let stats = {
    solved: 0,
    wrong: 0,
    activeCount: 0
};

// --- MATH UTILS ---
const dist = (x1,y1,x2,y2) => Math.hypot(x2-x1, y2-y1);
const clamp = (v,min,max) => Math.max(min, Math.min(max, v));
const rand = (min,max) => Math.random() * (max-min) + min;
// Utility to normalize a distance by the maximum possible distance
const normDist = (d) => clamp(d / maxWorldDist, 0, 1);
// Utility to normalize an angle (in radians) to a value between -1 and 1
const normAngle = (a) => {
    // Normalize angle to [-PI, PI]
    while (a > Math.PI) a -= 2 * Math.PI;
    while (a < -Math.PI) a += 2 * Math.PI;
    // Normalize to [-1, 1]
    return a / Math.PI;
}


// --- NEAT CORE ---
class Genome {
  constructor(parent = null) {
    // Säkra att de senaste CFG-värdena används för nätverksdimensioner
    const I = CFG.inputs;
    const H = CFG.hiddens;
    const O = CFG.outputs;

    if(parent) {
      // Re-initialize arrays if dimensions changed
      const getArray = (oldArr, newSize) => {
        let newArr = new Float32Array(newSize);
        for(let i=0; i<newSize; i++) {
            newArr[i] = i < oldArr.length ? this.mutate(oldArr[i]) : rand(-1,1);
        }
        return newArr;
      };

      // Handle dimension changes by copying and mutating existing weights,
      // and creating new random weights for expanded layers.
      this.w1 = getArray(parent.w1, I * H);
      this.w2 = getArray(parent.w2, H * O);
      this.bias1 = getArray(parent.bias1, H);
      this.bias2 = getArray(parent.bias2, O);

    } else {
      this.w1 = new Float32Array(I * H).map(() => rand(-1,1));
      this.w2 = new Float32Array(H * O).map(() => rand(-1,1));
      this.bias1 = new Float32Array(H).map(() => rand(-1,1));
      this.bias2 = new Float32Array(O).map(() => rand(-1,1));
    }
    this.fitness = 0;
  }

  mutate(val) {
    if(Math.random() < CFG.mutationRate) return val + rand(-0.5, 0.5);
    return val;
  }

  predict(inputs) {
    const H = CFG.hiddens;
    const I = CFG.inputs;
    const O = CFG.outputs;
    
    // Ensure inputs array matches expected size, filling with 0 if short
    const safeInputs = new Float32Array(I);
    for(let i=0; i<I; i++) safeInputs[i] = inputs[i] || 0;

    let hiddens = new Float32Array(H);
    for(let i=0; i<H; i++) {
      let sum = this.bias1[i];
      for(let j=0; j<I; j++) sum += safeInputs[j] * this.w1[j*H + i];
      hiddens[i] = Math.tanh(sum);
    }
    let outputs = new Float32Array(O);
    for(let i=0; i<O; i++) {
      let sum = this.bias2[i];
      for(let j=0; j<H; j++) sum += hiddens[j] * this.w2[j*O + i];
      outputs[i] = Math.tanh(sum);
    }
    return { outputs, hiddens };
  }
}

// --- ENTITIES ---
class Nest {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.r = 25;
  }
  draw() {
    // Outer Ring (Pulsating Effect)
    const pulseR = this.r * (1 + Math.sin(frame * 0.1) * 0.1);
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(this.x, this.y, pulseR + 5, 0, Math.PI * 2);
    ctx.stroke();

    // Inner Body
    ctx.fillStyle = 'rgba(255, 255, 255, 0.08)';
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    
    // Text Label
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.font = '12px ' + varStyles.fontUi;
    ctx.fillText('NEST', this.x, this.y + 4);
    
    // Highlight if being dragged
    if (mouse.dragNest) {
        ctx.strokeStyle = varStyles.accent;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r + 5, 0, Math.PI * 2);
        ctx.stroke();
    }
  }
}

class Ticket {
  constructor() { this.respawn(); }

  update() {
    // Subtle float animation
    this.x += Math.sin(frame * 0.05 + this.id) * 0.2;
    this.y += Math.cos(frame * 0.05 + this.id) * 0.2;
    
    this.life -= this.decay;
    if(this.life <= 0) {
      spawnParticles(this.x, this.y, '#555', 5);
      this.respawn();
    }
  }

  respawn() {
    this.id = Math.random();
    this.x = rand(50, W-50);
    this.y = rand(150, H-150);
    this.life = 1.0;
    this.typeIdx = Math.floor(Math.random() * 3);
    this.def = CFG.categories[this.typeIdx];
    this.decay = rand(0.0002, 0.0008); 
    this.r = 8;
  }

  draw() {
    const w = 12, h = 16; 
    ctx.save();
    ctx.translate(this.x, this.y);

    // Paper Body (Rounded Rectangle - using polyfill/function)
    ctx.fillStyle = this.def.color;
    ctx.globalAlpha = 0.8;
    ctx.beginPath();
    ctx.roundRectPolyfill(-w/2, -h/2, w, h, 3);
    ctx.fill();
    ctx.globalAlpha = 1;

    // SLA Bar (Life) - White bar
    ctx.fillStyle = '#fff';
    ctx.fillRect(-w/2 + 1, -h/2 + 1, (w-2) * this.life, 2);
    
    // Highlight based on type
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1;
    ctx.stroke();

    ctx.restore();
  }
}

class Agent {
  constructor(genome) {
    this.brain = genome || new Genome();
    this.x = nest ? nest.x : W/2; 
    this.y = nest ? nest.y : H/2; 
    this.angle = rand(0, Math.PI*2);
    this.vel = 0;
    this.r = 10;
    this.teamHue = 210; 
    this.carrying = null;
    this.energy = 1.0;
    this.memory = 0;
    this.fitness = 0;
    this.sensors = [];
    this.stalled = false;
    this.trail = []; 
  }

  update() {
    if(mouse.dragAgent === this || mouse.dragNest || mouse.dragZone) return; 

    this.fireSensors();

    // --- INPUT GENERATION (16 Inputs) ---
    const inputs = [...this.sensors]; // 5 inputs (LIDAR)

    // Carrying Info (4 inputs)
    if(this.carrying) {
      inputs.push(this.carrying.typeIdx === 0 ? 1:0); // 6: INC
      inputs.push(this.carrying.typeIdx === 1 ? 1:0); // 7: REQ
      inputs.push(this.carrying.typeIdx === 2 ? 1:0); // 8: PROB
      inputs.push(this.carrying.life);               // 9: SLA Life
    } else {
      inputs.push(0,0,0,0);
    }
    
    // Status (3 inputs)
    inputs.push(this.energy);                       // 10: Energy
    inputs.push(this.vel / CFG.maxSpeed);           // 11: Speed (Normalized)
    inputs.push(this.memory);                       // 12: Memory

    // Directional Context (4 new inputs)
    // 1. Nest Information (Always relevant)
    const dNest = dist(this.x, this.y, nest.x, nest.y);
    const aNest = Math.atan2(nest.y - this.y, nest.x - this.x);
    const angleDiffNest = aNest - this.angle;
    
    inputs.push(normDist(dNest));                   // 13: Nest Distance
    inputs.push(normAngle(angleDiffNest));          // 14: Nest Angle

    // 2. Target Zone Information (Only relevant when carrying)
    let dTarget = 0, aTarget = 0;
    if(this.carrying) {
        const targetZone = getZones().find(z => z.id === this.carrying.def.id);
        if(targetZone) {
            dTarget = dist(this.x, this.y, targetZone.x, targetZone.y);
            aTarget = Math.atan2(targetZone.y - this.y, targetZone.x - this.x);
            const angleDiffTarget = aTarget - this.angle;
            inputs.push(normDist(dTarget));         // 15: Target Distance
            inputs.push(normAngle(angleDiffTarget)); // 16: Target Angle
        } else {
            inputs.push(0, 0);
        }
    } else {
        inputs.push(0, 0); // Not carrying, distance/angle are 0
    }
    // --- END INPUT GENERATION ---
    
    this.lastInputs = inputs;
    const { outputs, hiddens } = this.brain.predict(inputs);
    this.lastHiddens = hiddens;
    this.lastOutputs = outputs; 

    // outputs: [steerLeft, steerRight, forward, reverse, brake, memory]
    const steerLeft = (outputs[0] + 1) / 2; // Normalize from [-1, 1] to [0, 1]
    const steerRight = (outputs[1] + 1) / 2;
    const thrust = (outputs[2] + 1) / 2;
    const reverse = (outputs[3] + 1) / 2;
    const brake = (outputs[4] + 1) / 2;
    this.memory = outputs[5];

    // 1. Steering
    const turnRate = CFG.turnRate;
    let turn = (steerRight - steerLeft) * turnRate;
    this.angle += turn;

    // 2. Propulsion
    let netThrust = 0;
    if (thrust > reverse) {
        netThrust = thrust; // Forward acceleration
    } else {
        netThrust = -reverse; // Reverse acceleration
    }

    if(this.energy > 0) {
        if (Math.abs(netThrust) > 0.1) {
            this.vel += netThrust * 0.2;
            this.energy -= CFG.energyDrain * (1 + Math.abs(netThrust));
        }
        this.stalled = false;
        // Reward for movement/activity
        this.fitness += 0.1 * Math.abs(this.vel);
    } else {
        this.stalled = true;
    }

    // 3. Braking / Friction
    if (brake > 0.1) {
        this.vel *= (1 - brake * 0.2); 
        this.energy -= CFG.energyDrain * 0.5; 
    } else {
        // Standard friction
        this.vel *= 0.92; 
    }

    // Velocity limits and Energy Recharge
    this.vel = clamp(this.vel, -CFG.maxSpeed, CFG.maxSpeed);
    
    if(Math.abs(this.vel) < 0.1) {
        this.vel = 0;
        this.energy = Math.min(1, this.energy + 0.02); 
    }

    this.x += Math.cos(this.angle) * this.vel;
    this.y += Math.sin(this.angle) * this.vel;
    
    // Bounds (Wall Bounce)
    if(this.x < this.r || this.x > W-this.r || this.y < this.r || this.y > H-this.r) {
      this.x = clamp(this.x, this.r, W-this.r);
      this.y = clamp(this.y, this.r, H-this.r);
      this.vel *= -0.5;
      this.fitness -= 5; 
    }

    // Interactions
    if(!this.carrying) {
      for(let t of tickets) {
        if(dist(this.x, this.y, t.x, t.y) < this.r + 5 && t.x > 0) {
          this.carrying = t;
          t.x = -1000;
          pushFeed(`Picked up ${t.def.label}`, 'good');
          this.fitness += 10; 
          zoneHighlight = { id: t.def.id, frame: frame }; 
          break;
        }
      }
    } else {
      // Reward for carrying a ticket
      this.fitness += 0.5; 
      
      const zones = getZones();
      for(let z of zones) {
        if(dist(this.x, this.y, z.x, z.y) < z.r) {
          if(z.id === this.carrying.def.id) {
            // Proportional reward based on urgency
            const urgencyFactor = 1 / this.carrying.decay; 
            const baseReward = 50 + (this.energy * 10);
            this.fitness += baseReward + (baseReward * urgencyFactor * 0.01); 

            stats.solved++;
            spawnParticles(this.x, this.y, z.color, 15);
            pushFeed(`Sorted: ${this.carrying.def.label}`, 'good');
          } else {
            this.fitness -= 25; // High penalty for wrong sort
            stats.wrong++;
            spawnParticles(this.x, this.y, varStyles.accentBad, 8);
            pushFeed(`Wrong Zone!`, 'bad');
          }
          this.carrying.respawn();
          this.carrying = null;
          break;
        }
      }
    }

    // Trail update
    if(this === bestBrain && document.getElementById('chkTrail')?.checked) {
        this.trail.push({ x: this.x, y: this.y, alpha: 1.0 });
        if(this.trail.length > 50) this.trail.shift(); 
    } else if (this !== bestBrain) {
        this.trail = [];
    }
  }

  fireSensors() {
    this.sensors = [];
    const startAngle = this.angle - CFG.fov/2;
    const step = CFG.fov / (CFG.sensorCount - 1);
    const range = CFG.sensorRange; 
    
    for(let i=0; i<CFG.sensorCount; i++) {
      const rayAngle = startAngle + (step * i);
      let minDist = 1.0; 
      
      // Check Tickets
      for(let t of tickets) {
        if(t.x < 0) continue; 
        let d = dist(this.x, this.y, t.x, t.y);
        if(d < range) {
          let angleTo = Math.atan2(t.y - this.y, t.x - this.x);
          let diff = Math.abs(angleTo - rayAngle);
          if(diff > Math.PI) diff = Math.PI*2 - diff;
          if(diff < step/2) minDist = Math.min(minDist, d / range);
        }
      }
      
      // Check Walls
      let dx = Math.cos(rayAngle);
      let dy = Math.sin(rayAngle);
      let dX = dx > 0 ? (W - this.x) / dx : -this.x / dx;
      let dY = dy > 0 ? (H - this.y) / dy : -this.y / dy;
      let dWall = Math.min(dX, dY);
      if(dWall < range) minDist = Math.min(minDist, dWall/range);

      this.sensors.push(minDist);
    }
  }

  draw() {
    if(this.carrying) this.drawCarryingLink(); 

    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.angle);
    
    // Battery Ring (Pulsating low energy)
    let ringColor = this.energy > 0.3 ? varStyles.accentOk : (this.stalled ? varStyles.accentBad : '#ff9900');
    if(this.energy < 0.3) {
        ctx.globalAlpha = 0.5 + Math.sin(frame * 0.2) * 0.5; 
        ctx.lineWidth = 3;
    } else {
        ctx.lineWidth = 1.5;
        ctx.globalAlpha = 1;
    }
    ctx.beginPath();
    ctx.arc(0, 0, this.r + 3, 0, Math.PI * 2 * this.energy);
    ctx.strokeStyle = ringColor;
    ctx.stroke();
    
    
    // Body (Arrow/Wedge Shape) 
    ctx.globalAlpha = 1;
    
    // Color logic
    let agentFillColor;
    if (this.carrying) {
        agentFillColor = this.carrying.def.color;
    } else {
        const memSaturation = 50 + Math.abs(this.memory) * 40; 
        agentFillColor = `hsl(${this.teamHue}, ${memSaturation}%, 50%)`;
    }

    // Apply fill style before drawing
    ctx.fillStyle = this.stalled ? '#552222' : agentFillColor;
    
    // Highlight Best Agent
    if(this === bestBrain) {
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#ffffaa';
        ctx.fillStyle = '#fff';
    }

    // Draw the arrow/wedge shape
    ctx.beginPath();
    ctx.moveTo(this.r * 1.5, 0); // Tip
    ctx.lineTo(-this.r, this.r * 0.8); // Back right
    ctx.lineTo(-this.r * 0.5, 0); // Center point in the back for a cleaner wedge
    ctx.lineTo(-this.r, -this.r * 0.8); // Back left
    ctx.closePath();
    ctx.fill();

    // Reset shadow/highlight
    ctx.shadowBlur = 0;

    ctx.restore();

    // Draw Sensors (LIDAR)
    if(document.getElementById('chkSensors')?.checked) {
      const startAngle = this.angle - CFG.fov/2;
      const step = CFG.fov / (CFG.sensorCount - 1);
      ctx.globalAlpha = 0.05;
      for(let i=0; i<this.sensors.length; i++) {
        const rayAngle = startAngle + (step * i);
        const len = this.sensors[i] * CFG.sensorRange;
        ctx.strokeStyle = varStyles.accent;
        ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.x + Math.cos(rayAngle)*len, this.y + Math.sin(rayAngle)*len); ctx.stroke();
      }
      ctx.globalAlpha = 1;
    }
  }

  drawCarryingLink() {
      // Visual link to the ticket being carried (animated)
      if(!this.carrying || this.carrying.x > -100) return; 
      
      const zones = getZones();
      const targetZone = zones.find(z => z.id === this.carrying.def.id);
      if(!targetZone) return;

      const gradient = ctx.createLinearGradient(this.x, this.y, targetZone.x, targetZone.y);
      gradient.addColorStop(0, this.carrying.def.color);
      gradient.addColorStop(1, 'rgba(255,255,255,0.05)');
      
      ctx.strokeStyle = gradient;
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]); 
      ctx.lineDashOffset = -frame * 0.5; 
      ctx.globalAlpha = 0.5;

      ctx.beginPath();
      ctx.moveTo(this.x, this.y);
      ctx.lineTo(targetZone.x, targetZone.y);
      ctx.stroke();

      ctx.setLineDash([]);
      ctx.lineDashOffset = 0;
      ctx.globalAlpha = 1;
  }
}

// --- SYSTEM ---

// Utility for roundRect (Compatibility for older browsers/environments)
if (!CanvasRenderingContext2D.prototype.roundRectPolyfill) {
    CanvasRenderingContext2D.prototype.roundRectPolyfill = function(x, y, w, h, r) {
        if (typeof r === 'number') r = { tl: r, tr: r, br: r, bl: r };
        else r = { ...{ tl: 0, tr: 0, br: 0, bl: 0 }, ...r };
        this.moveTo(x + r.tl, y);
        this.lineTo(x + w - r.tr, y);
        this.arcTo(x + w, y, x + w, y + r.tr, r.tr);
        this.lineTo(x + w, y + h - r.br);
        this.arcTo(x + w, y + h, x + w - r.br, y + h, r.br);
        this.lineTo(x + r.bl, y + h);
        this.arcTo(x, y + h, x, y + h - r.bl, r.bl);
        this.lineTo(x, y + r.tl);
        this.arcTo(x, y, x + r.tl, y, r.tl);
        this.closePath();
    };
}

// Helper to get CSS variables for use in JS drawing
const varStyles = {
    fontUi: getComputedStyle(document.documentElement).getPropertyValue('--font-ui').trim(),
    accent: getComputedStyle(document.documentElement).getPropertyValue('--accent').trim(),
    accentOk: getComputedStyle(document.documentElement).getPropertyValue('--accent-ok').trim(),
    accentBad: getComputedStyle(document.documentElement).getPropertyValue('--accent-bad').trim(),
    textDim: getComputedStyle(document.documentElement).getPropertyValue('--text-dim').trim(),
};


function getZones() {
  return goalZones; 
}

function drawZones() {
  getZones().forEach(z => {
    // Highlighting logic (Pulsating White Border)
    if (zoneHighlight && z.id === zoneHighlight.id && frame < zoneHighlight.frame + 30) {
        ctx.globalAlpha = (Math.sin(frame*0.2) + 1.5) * 0.3; 
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 5;
        ctx.beginPath(); ctx.arc(z.x, z.y, z.r + 5, 0, Math.PI*2); ctx.stroke();
    }
    
    // Highlight if being dragged
    if (mouse.dragZone === z) { 
        ctx.globalAlpha = 1;
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(z.x, z.y, z.r + 5, 0, Math.PI * 2);
        ctx.stroke();
    }
    
    // Inner Glow
    const grad = ctx.createRadialGradient(z.x, z.y, z.r*0.2, z.x, z.y, z.r);
    grad.addColorStop(0, z.color + '80'); // 80 alpha
    grad.addColorStop(1, 'transparent');
    ctx.fillStyle = grad; 
    ctx.globalAlpha = 0.5;
    ctx.beginPath(); ctx.arc(z.x, z.y, z.r, 0, Math.PI*2); ctx.fill();
    
    // Outer Ring
    ctx.globalAlpha = 1; 
    ctx.strokeStyle = z.color; 
    ctx.lineWidth = 2; 
    ctx.beginPath(); ctx.arc(z.x, z.y, z.r, 0, Math.PI*2); ctx.stroke();

    // Text Label (Always Visible)
    ctx.fillStyle = '#fff'; 
    ctx.textAlign = 'center'; 
    ctx.font = '14px ' + varStyles.fontUi;
    ctx.fillText(z.label, z.x, z.y + 5);
  });
  ctx.globalAlpha = 1;
}

function drawAgentTrail() {
    if(!bestBrain || !document.getElementById('chkTrail')?.checked) return;
    
    ctx.lineWidth = 2;
    ctx.beginPath();
    
    bestBrain.trail.forEach((p, i) => {
        const alpha = (i / bestBrain.trail.length) * 0.5;
        ctx.strokeStyle = `rgba(255, 215, 0, ${alpha})`;
        
        if(i === 0) ctx.moveTo(p.x, p.y);
        else {
            const prev = bestBrain.trail[i-1];
            ctx.beginPath();
            ctx.moveTo(prev.x, prev.y);
            ctx.lineTo(p.x, p.y);
            ctx.stroke();
        }
    });
    ctx.globalAlpha = 1;
}

function spawnParticles(x, y, color, count) {
  if(!document.getElementById('chkParticles')?.checked) return;
  for(let i=0; i<count; i++) {
    particles.push({ 
        x, y, 
        vx: rand(-2, 2), 
        vy: rand(-2, 2), 
        life: 1.0, 
        color, 
        size: rand(2, 5) 
    });
  }
}

function updateParticles() {
  for(let i=particles.length-1; i>=0; i--) {
    let p = particles[i];
    p.x += p.vx * p.life; 
    p.y += p.vy * p.life;
    p.life -= 0.03; 
    if(p.life <= 0) particles.splice(i, 1);
  }
}

function drawParticles() {
  particles.forEach(p => {
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x, p.y, p.size, p.size);
  });
  ctx.globalAlpha = 1;
}

function drawHeatmap() {
  if(!document.getElementById('chkHeatmap')?.checked) return;
  
  // Use a soft, non-blur gradient circle for each agent
  ctx.globalCompositeOperation = 'lighter'; 
  agents.forEach(a => {
    const grad = ctx.createRadialGradient(a.x, a.y, 0, a.x, a.y, 40);
    grad.addColorStop(0, 'rgba(0, 200, 255, 0.05)');
    grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(a.x, a.y, 40, 0, Math.PI * 2);
    ctx.fill();
  });
  ctx.globalCompositeOperation = 'source-over'; 
}

function updateFPS(now) {
    if (lastFrameTime) {
        fps = 1000 / (now - lastFrameTime);
        fpsDisplay.innerText = `FPS: ${fps.toFixed(0)}`;
    }
    lastFrameTime = now;
}

function updateUI() {
  // Update the large HUD Generation display
  document.getElementById('hudGen').innerText = `GEN ${generation}`; 
  
  // Update sidebar Generation stat
  document.getElementById('dispGen').innerText = generation;
  
  // Update all other stats
  document.getElementById('dispSolved').innerText = stats.solved;
  document.getElementById('dispWrong').innerText = stats.wrong;
  
  let total = stats.solved + stats.wrong;
  let acc = total === 0 ? 0 : (stats.solved / total) * 100;
  document.getElementById('dispAcc').innerText = acc.toFixed(1) + '%';
  document.getElementById('dispAcc').style.color = acc > 80 ? varStyles.accentOk : (acc > 50 ? '#fff' : varStyles.accentBad);

  let stalledCount = agents.filter(a => a.stalled).length;
  stats.activeCount = agents.length - stalledCount;

  document.getElementById('dispActive').innerText = `${stats.activeCount}/${agents.length}`;
  if(bestBrain) document.getElementById('dispFit').innerText = bestBrain.fitness.toFixed(2);

  // Toggle Brain Visualization visibility based on checkbox
  brainCanvas.style.display = document.getElementById('chkBrainViz').checked ? 'block' : 'none';
}

function drawBrain(agent) {
  if(!document.getElementById('chkBrainViz').checked || !agent) return;
  
  const W_B = brainCanvas.width;
  const H_B = brainCanvas.height;
  brainCtx.clearRect(0, 0, W_B, H_B);
  
  const net = agent.brain;
  const nodeR = 4; 
  
  const layerX = [W_B*0.15, W_B*0.5, W_B*0.85];
  const getY = (idx, total) => (H_B / (total + 1)) * (idx + 1);
  
  // --- DRAW CONNECTIONS (Color Coded by Weight and Activation) ---
  brainCtx.lineWidth = 0.5; 
  
  const getLineColor = (weight, inputVal) => {
    const activation = weight * inputVal;
    const alpha = clamp(Math.abs(activation) * 0.8, 0.1, 0.6);
    return activation > 0 ? `rgba(0,255,150,${alpha})` : `rgba(255,50,50,${alpha})`;
  }

  // Input to Hidden
  for(let i=0; i<CFG.inputs; i++) {
    for(let h=0; h<CFG.hiddens; h++) {
      try{
        const w = net.w1[i*CFG.hiddens + h];
        brainCtx.strokeStyle = getLineColor(w, agent.lastInputs[i] || 0);
        brainCtx.beginPath(); brainCtx.moveTo(layerX[0], getY(i, CFG.inputs)); brainCtx.lineTo(layerX[1], getY(h, CFG.hiddens)); brainCtx.stroke();
      } catch(e) {/* Skip if index is out of bounds due to CFG.hiddens change */}
    }
  }
  
  // Hidden to Output
  for(let h=0; h<CFG.hiddens; h++) {
    for(let o=0; o<CFG.outputs; o++) {
      try{
        const w = net.w2[h*CFG.outputs + o];
        const hVal = agent.lastHiddens ? agent.lastHiddens[h] : 0;
        brainCtx.strokeStyle = getLineColor(w, hVal);
        brainCtx.beginPath(); brainCtx.moveTo(layerX[1], getY(h, CFG.hiddens)); brainCtx.lineTo(layerX[2], getY(o, CFG.outputs)); brainCtx.stroke();
      } catch(e) {/* Skip if index is out of bounds due to CFG.hiddens change */}
    }
  }

  // --- DRAW NODES & LABELS (Color Coded by Activation/Bias) ---
  brainCtx.globalAlpha = 1;
  brainCtx.font = '8px monospace'; 
  
  // Input Nodes (16 inputs)
  brainCtx.textAlign = 'right';
  const inputLabels = [
    'Wall(1)', 'Wall(2)', 'Wall(3)', 'Wall(4)', 'Wall(5)', 
    'Carry_INC', 'Carry_REQ', 'Carry_PROB', 'Carry_SLA', 
    'Energy', 'Speed', 'Memory', 
    'Nest_Dist', 'Nest_Ang', 
    'Goal_Dist', 'Goal_Ang'
  ];
  for(let i=0; i<CFG.inputs; i++) {
    const val = agent.lastInputs[i] || 0;
    // Node Color based on value
    const c = Math.round(clamp(val, 0, 1) * 255);
    brainCtx.fillStyle = `rgb(${c}, ${c}, ${c})`;
    brainCtx.beginPath(); brainCtx.arc(layerX[0], getY(i, CFG.inputs), nodeR, 0, Math.PI*2); brainCtx.fill();
    // Label
    brainCtx.fillStyle = '#94a3b8';
    brainCtx.fillText(inputLabels[i], layerX[0] - nodeR - 2, getY(i, CFG.inputs) + 2);
  }

  // Hidden Nodes
  for(let i=0; i<CFG.hiddens; i++) {
    const val = agent.lastHiddens ? agent.lastHiddens[i] : 0;
    let color = 'rgb(68, 68, 85)'; // Default
    if (Math.abs(val) > 0.01) {
        const intensity = clamp(Math.abs(val) * 255, 50, 255);
        color = val > 0 ? `rgb(0, ${intensity}, 150)` : `rgb(${intensity}, 0, 50)`;
    }
    brainCtx.fillStyle = color;
    brainCtx.beginPath(); brainCtx.arc(layerX[1], getY(i, CFG.hiddens), nodeR-1, 0, Math.PI*2); brainCtx.fill();
  }
  
  // Output Nodes
  brainCtx.textAlign = 'left';
  const outputLabels = ['STEER_L', 'STEER_R', 'FORWARD', 'REVERSE', 'BRAKE', 'MEMORY_OUT']; 
  for(let i=0; i<CFG.outputs; i++) {
    const val = agent.lastOutputs ? agent.lastOutputs[i] : 0;
    
    let color = '#fff';
    if (Math.abs(val) > 0.01) {
        const intensity = clamp(Math.abs(val) * 255, 50, 255);
        color = val > 0 ? `rgb(0, ${intensity}, 150)` : `rgb(${intensity}, 0, 50)`;
    }

    brainCtx.fillStyle = color;
    brainCtx.beginPath(); brainCtx.arc(layerX[2], getY(i, CFG.outputs), nodeR, 0, Math.PI*2); brainCtx.fill();
    
    // Label
    brainCtx.fillStyle = '#94a3b8';
    brainCtx.fillText(outputLabels[i], layerX[2] + nodeR + 2, getY(i, CFG.outputs) + 2);
  }
}

function drawFitnessGraph() {
  const W_G = 360, H_G = 70;
  const fitCtx = document.getElementById('fitnessGraph').getContext('2d');
  
  // Always set dimensions to match CSS for correct drawing
  const canvasElement = document.getElementById('fitnessGraph');
  canvasElement.width = W_G;
  canvasElement.height = H_G;

  if(history.length < 2) { fitCtx.clearRect(0,0,W_G,H_G); return; }
  
  fitCtx.clearRect(0,0,W_G,H_G);
  const maxFit = Math.max(...history.map(h=>h.best), 1); // Ensure maxFit is at least 1
  const stepX = W_G / (history.length - 1);
  
  fitCtx.strokeStyle = varStyles.accentOk;
  fitCtx.lineWidth = 2;
  fitCtx.beginPath();
  
  history.forEach((h, i) => {
    const y = H_G - (h.best / maxFit * H_G * 0.9 + 5);
    if(i===0) fitCtx.moveTo(0, y); else fitCtx.lineTo(i*stepX, y);
  });
  fitCtx.stroke();
}


function pushFeed(msg, type='normal') {
  const el = document.getElementById('feed');
  const div = document.createElement('div');
  div.className = `feed-item ${type}`;
  div.innerText = msg;
  el.prepend(div);
  if(el.children.length > 6) el.lastChild.remove();
}

function updateHoverTip(e) {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    let hoveredAgent = null;
    for(let a of agents) {
        if(dist(a.x, a.y, x, y) < a.r * 2) {
            hoveredAgent = a;
            break;
        }
    }
    
    if (hoveredAgent) {
        hoverTip.style.opacity = 1;
        hoverTip.style.left = `${e.clientX}px`;
        hoverTip.style.top = `${e.clientY}px`;
        hoverTip.innerHTML = `
            <strong>Status:</strong><br>
            Fitness: <span style="color:var(--accent-ok)">${hoveredAgent.fitness.toFixed(2)}</span><br>
            Energy: <span style="color:${hoveredAgent.energy > 0.3 ? '#0f0' : '#ff9900'}">${(hoveredAgent.energy * 100).toFixed(0)}%</span><br>
            Speed: ${hoveredAgent.vel.toFixed(1)} / ${CFG.maxSpeed}<br>
            Memory: ${hoveredAgent.memory.toFixed(3)}<br>
            Carrying: ${hoveredAgent.carrying ? hoveredAgent.carrying.def.label : 'None'}
        `;
    } else {
        hoverTip.style.opacity = 0;
    }
}


// --- MAIN LOOP ---
function init(resetStats = true) {
  // Update canvas dimensions based on parent container
  W = canvas.width = canvas.parentElement.offsetWidth;
  H = canvas.height = canvas.parentElement.offsetHeight;
  maxWorldDist = Math.hypot(W, H); // Calculate maximum possible distance for normalization
  
  // Set brain canvas fixed dimensions for drawing
  brainCanvas.width = 300;
  brainCanvas.height = 150;
  
  // Initialize NEST
  if (!nest) { 
      nest = new Nest(W / 2, H / 2);
  }

  // Initialize or Reset Goal Zones
  if (goalZones.length === 0 || resetStats) {
      goalZones = [
          { x: W*0.2, y: H*0.2, r: 40, id: 'incident', color: CFG.categories.find(c=>c.id==='incident').color, label: 'INCIDENT' },
          { x: W*0.8, y: H*0.2, r: 40, id: 'request', color: CFG.categories.find(c=>c.id==='request').color, label: 'SERVICE' },
          { x: W*0.5, y: H*0.9, r: 40, id: 'problem', color: CFG.categories.find(c=>c.id==='problem').color, label: 'PROBLEM' }
      ];
  }

  CFG.popSize = parseInt(document.getElementById('slPop').value); 
  CFG.ticketCount = parseInt(document.getElementById('slTicketCount').value); 
  CFG.eliteCount = parseInt(document.getElementById('slElite').value);
  CFG.selectionPoolRatio = parseInt(document.getElementById('slSelection').value) / 100;
  CFG.genDuration = parseInt(document.getElementById('slDuration').value); 

  if(resetStats) {
      // Tvinga en full reset av AI:n om Hidden Nodes eller Input/Output har ändrats
      const newHiddens = parseInt(document.getElementById('slHidden').value);
      if (newHiddens !== CFG.hiddens || CFG.inputs !== 16 || CFG.outputs !== 6) {
          CFG.hiddens = newHiddens;
          CFG.inputs = 16;
          CFG.outputs = 6;
          pushFeed(`Topology updated. Performing AI Hard Reset.`, 'warn');
          // Tvinga en fullständig nystart nedan
      }

      generation = 1; 
      history = []; 
      stats = { solved: 0, wrong: 0, activeCount: 0 };
  }
  
  // Re-initialize agents and tickets based on current CFG
  if(resetStats || !bestBrain || agents.length !== CFG.popSize) { 
    if(resetStats || !bestBrain || agents.length !== CFG.popSize) {
        agents = [];
        for(let i=0; i<CFG.popSize; i++) agents.push(new Agent());
        bestBrain = agents[0];
    } else {
        nextGeneration(true); 
    }
  }
  
  tickets = [];
  for(let i=0; i<CFG.ticketCount; i++) tickets.push(new Ticket());
  
  requestAnimationFrame(loop);
}

function nextGeneration(forceNew = false) {
  // Update CFG values from sliders
  CFG.popSize = parseInt(document.getElementById('slPop').value); 
  CFG.eliteCount = parseInt(document.getElementById('slElite').value);
  CFG.selectionPoolRatio = parseInt(document.getElementById('slSelection').value) / 100;
  
  const validAgents = agents.filter(a => a && typeof a.fitness === 'number');

  if(validAgents.length === 0) {
      pushFeed('No valid agents found. Starting fresh population.', 'bad');
      init(true);
      return;
  }
  
  // 1. Calculate and find best agent
  const sorted = [...validAgents].sort((a,b) => b.fitness - a.fitness);

  // Update bestBrain
  if(!bestBrain || sorted[0].fitness > bestBrain.fitness) {
    bestBrain = sorted[0];
  }
  
  if (bestBrain.fitness > 0 || generation === 1) {
    history.push({ gen: generation, best: bestBrain.fitness });
  }

  const newAgents = [];
  
  // 2. Eliteism (Keep best genomes)
  const eliteLimit = Math.min(CFG.eliteCount, sorted.length);

  for(let i=0; i<eliteLimit; i++) {
    const el = new Agent(sorted[i].brain);
    if (sorted[i] === bestBrain) {
        el.trail = sorted[i].trail;
    }
    newAgents.push(el);
  }
  
  // 3. Reproduction (Fill remaining slots)
  while(newAgents.length < CFG.popSize) {
    const selectionPoolSize = Math.max(1, Math.floor(sorted.length * CFG.selectionPoolRatio));
    const p1 = sorted[Math.floor(Math.random()*selectionPoolSize)]; 
    newAgents.push(new Agent(new Genome(p1.brain)));
  }
  
  // 4. Reset state for new agents
  newAgents.forEach(a => {
    a.x = nest.x;
    a.y = nest.y;
    if(a !== bestBrain) a.trail = []; 
  });

  agents = newAgents;
  
  generation++;
  frame = 0;
  stats.solved = 0;
  stats.wrong = 0;
  
  tickets.forEach(t => t.respawn());
  pushFeed('--- NEW GENERATION ---');
}

function loop(now) {
  updateFPS(now);

  if(!paused) {
    for(let n=0; n<speedMult; n++) {
      ctx.clearRect(0, 0, W, H);
      frame++;
      
      if(frame > CFG.genDuration) { nextGeneration(); break; }
      
      drawAgentTrail(); 
      drawHeatmap();
      drawZones();
      nest.draw(); 
      tickets.forEach(t => { t.update(); t.draw(); });
      
      let currentBest = bestBrain;
      let maxF = bestBrain ? bestBrain.fitness : -Infinity;

      agents.forEach(a => {
        a.update();
        a.draw();
        // Update bestBrain live if a better one is found in current generation
        if(a.fitness > maxF) { maxF = a.fitness; currentBest = a; }
      });
      
      bestBrain = currentBest;
      updateParticles();
      drawParticles();
      
      // Drag logic
      if(mouse.dragAgent) {
        mouse.dragAgent.x = mouse.x; mouse.dragAgent.y = mouse.y; mouse.dragAgent.vel = 0;
      }
    }
  }
  drawBrain(bestBrain);
  drawFitnessGraph();
  updateUI();
  requestAnimationFrame(loop);
}

// --- EVENT LISTENERS ---
window.addEventListener('resize', () => { 
    W = canvas.width = canvas.parentElement.offsetWidth; 
    H = canvas.height = canvas.parentElement.offsetHeight; 
    maxWorldDist = Math.hypot(W, H); 
    nest.x = W / 2; nest.y = H / 2; 
});

canvas.addEventListener('mousedown', e => {
  const rect = canvas.getBoundingClientRect();
  mouse.x = e.clientX - rect.left; mouse.y = e.clientY - rect.top;
  mouse.down = true;
  
  // 1. Check for Nest hit (Highest priority)
  if (dist(nest.x, nest.y, mouse.x, mouse.y) < nest.r) {
    mouse.dragNest = true;
  } else {
    // 2. Check for other Zone hit
    const hitZone = goalZones.find(z => dist(z.x, z.y, mouse.x, mouse.y) < z.r);
    if(hitZone) {
      mouse.dragZone = hitZone; 
    } else {
      // 3. Check for Agent hit
      const hit = agents.find(a => dist(a.x, a.y, mouse.x, mouse.y) < 20);
      if(hit) mouse.dragAgent = hit;
    }
  }
});

canvas.addEventListener('mousemove', e => { 
  const rect = canvas.getBoundingClientRect(); 
  mouse.x = e.clientX - rect.left; mouse.y = e.clientY - rect.top; 
  
  if(mouse.dragNest) {
      nest.x = clamp(mouse.x, nest.r, W - nest.r);
      nest.y = clamp(mouse.y, nest.r, H - nest.r);
  } else if (mouse.dragZone) { 
      const r = mouse.dragZone.r;
      mouse.dragZone.x = clamp(mouse.x, r, W - r);
      mouse.dragZone.y = clamp(mouse.y, r, H - r);
  }
  updateHoverTip(e);
});

canvas.addEventListener('mouseup', () => { 
  mouse.down = false; 
  mouse.dragAgent = null; 
  mouse.dragNest = false; 
  mouse.dragZone = null; 
  hoverTip.style.opacity = 0; 
});

// Buttons & Keyboard
document.getElementById('btnSkip').onclick = () => { 
    if(paused) paused = false; 
    speedMult = 100; 
    pushFeed('Fast Forwarding...', 'warn');
    setTimeout(() => {
        speedMult = parseInt(document.getElementById('slSpeed').value);
        pushFeed(`Speed set to ${speedMult}x`);
    }, 500); 
};
document.getElementById('btnReset').onclick = () => { init(true); pushFeed('Hard Reset: All settings and AI reset', 'bad'); };
document.getElementById('btnResetAI').onclick = () => { init(true); pushFeed('AI Reset: New generation started with current settings', 'alt'); };

document.addEventListener('keydown', e => { 
    if(e.code === 'Space') { 
        paused = !paused; 
        pushFeed(paused ? 'Paused' : 'Unpaused', 'warn'); 
    }
    if(e.code === 'KeyS') document.getElementById('btnSkip').click(); 
});

// Sliders Logic
document.getElementById('slSpeed').oninput = (e) => { speedMult = parseInt(e.target.value); document.getElementById('valSpeed').innerText = speedMult + 'x'; };

document.getElementById('slPop').oninput = (e) => { 
    document.getElementById('valPop').innerText = e.target.value; 
    CFG.popSize = parseInt(e.target.value);
    init(false); 
};

document.getElementById('slTicketCount').oninput = (e) => { 
    CFG.ticketCount = parseInt(e.target.value); 
    document.getElementById('valTickets').innerText = CFG.ticketCount; 
    tickets = [];
    for(let i=0; i<CFG.ticketCount; i++) tickets.push(new Ticket());
};

document.getElementById('slDuration').oninput = (e) => { 
    CFG.genDuration = parseInt(e.target.value); 
    document.getElementById('valDuration').innerText = CFG.genDuration; 
};

document.getElementById('slSensor').oninput = (e) => { 
    CFG.sensorRange = parseInt(e.target.value); 
    document.getElementById('valSensor').innerText = CFG.sensorRange + 'px'; 
};

document.getElementById('slMut').oninput = (e) => { 
    let val = parseInt(e.target.value);
    CFG.mutationRate = val / 100; 
    document.getElementById('valMut').innerText = val + '%'; 
};

document.getElementById('slDrain').oninput = (e) => { 
    let val = parseInt(e.target.value);
    CFG.energyDrain = val * 0.0001; 
    let label = val < 5 ? 'Low' : (val > 15 ? 'Extreme' : 'Normal');
    document.getElementById('valDrain').innerText = label; 
};

document.getElementById('slElite').oninput = (e) => { 
    CFG.eliteCount = parseInt(e.target.value); 
    document.getElementById('valElite').innerText = CFG.eliteCount;
};

document.getElementById('slSelection').oninput = (e) => { 
    let val = parseInt(e.target.value);
    CFG.selectionPoolRatio = val / 100;
    document.getElementById('valSelection').innerText = val + '%'; 
};

document.getElementById('slHidden').oninput = (e) => { 
    document.getElementById('valHidden').innerText = e.target.value; 
    // Must force a hard reset to apply the change in neural network size
    pushFeed('Hidden Nodes ändrat. Tryck "Hard Reset All" för att uppdatera nätverket.', 'warn');
};

init();
</script>
</body>
</html>
