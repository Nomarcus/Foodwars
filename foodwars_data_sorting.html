<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Data Sorting – Ticket Routing with NEAT-lite</title>
  <style>
    :root {
      --bg1:#050516;
      --bg2:#161b3f;
      --panel:rgba(18,24,56,.82);
      --ink:#f1f5ff;
      --muted:#a1a9d8;
      --accent:#f472b6;
      --accent-emerald:#2dd4bf;
      --accent-cyan:#38bdf8;
      --silver:rgba(222,231,255,.55);
    }
    *{box-sizing:border-box}
    body{margin:0; min-height:100vh; display:flex; flex-direction:column; background:radial-gradient(circle at 45% 12%, rgba(87,51,183,.55) 0%, rgba(39,56,121,.85) 45%, var(--bg1) 100%); color:var(--ink); font-family:"Inter",system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;}

    .main-nav{position:sticky; top:0; z-index:200; padding:22px 48px; display:flex; align-items:center; justify-content:space-between; background:linear-gradient(120deg, rgba(15,20,48,.92) 0%, rgba(10,14,34,.75) 60%, rgba(10,14,34,.35) 100%); backdrop-filter:blur(14px); border-bottom:1px solid var(--silver); box-shadow:0 22px 45px rgba(5,9,25,.55)}
    .brand{display:flex; align-items:center; gap:12px; font-size:22px; font-weight:700; letter-spacing:.02em; color:var(--ink)}
    .brand-dot{width:14px; height:14px; border-radius:50%; background:linear-gradient(135deg, var(--accent) 0%, #8b5cf6 100%); box-shadow:0 0 18px rgba(244,114,182,.6)}
    .nav-links{display:flex; align-items:center; gap:12px}
    .pill-link,.pill-button{display:inline-flex; align-items:center; justify-content:center; padding:10px 20px; border-radius:999px; border:1px solid rgba(45,212,191,.45); background:linear-gradient(120deg, rgba(45,212,191,.18), rgba(59,130,246,.18)); color:var(--ink); text-decoration:none; font-size:14px; font-weight:600; letter-spacing:.03em; transition:transform .2s ease, box-shadow .2s ease, filter .2s ease, border-color .2s ease; cursor:pointer; font-family:inherit}
    .pill-link.secondary{border-color:rgba(139,92,246,.45); background:linear-gradient(120deg, rgba(139,92,246,.18), rgba(244,114,182,.18))}
    .pill-link:hover,.pill-button:hover{transform:translateY(-1px); filter:brightness(1.05); box-shadow:0 16px 32px rgba(45,212,191,.25)}
    .pill-link:focus-visible,.pill-button:focus-visible{outline:2px solid rgba(56,189,248,.65); outline-offset:3px}
    .pill-button{background:linear-gradient(120deg, rgba(139,92,246,.22), rgba(56,189,248,.22)); border-color:rgba(56,189,248,.45)}
    .pill-button.pill-button--active{border-color:rgba(244,114,182,.65); background:linear-gradient(120deg, rgba(244,114,182,.25), rgba(59,130,246,.25)); box-shadow:0 18px 40px rgba(244,114,182,.32)}

    main{flex:1; display:flex; justify-content:center; align-items:flex-start; padding:40px 48px 64px}
    .wrap{display:flex; align-items:flex-start; justify-content:center; gap:40px; width:100%; max-width:2000px}
    .field-area{flex:1 1 auto; display:flex; flex-direction:column; align-items:stretch; gap:18px; min-width:0}
    .playfield-frame{position:relative; padding:18px; border-radius:30px; background:rgba(4,8,26,.85); box-shadow:0 18px 36px rgba(9,14,36,.55); border:1px solid rgba(148,163,209,.22); transition:box-shadow .3s ease, transform .3s ease, background .3s ease, border-color .3s ease; width:100%; max-width:min(1100px, 100%)}
    .playfield-frame::before{content:""; position:absolute; inset:-8px; border-radius:inherit; background:linear-gradient(135deg, rgba(56,189,248,.35), rgba(244,114,182,.32)); opacity:0; filter:blur(12px); transition:opacity .35s ease, filter .35s ease; z-index:0}
    .playfield-frame canvas{position:relative; z-index:1; width:100%; height:auto; display:block}
    canvas{border-radius:24px; background:#04091f; box-shadow:0 0 45px rgba(15,23,61,.65), inset 0 0 22px rgba(118,133,255,.12); cursor:crosshair; border:1px solid var(--silver);}
    .stats-bar{display:grid; grid-template-columns:repeat(auto-fit,minmax(150px,1fr)); gap:16px; padding:18px 22px; border-radius:18px; background:rgba(11,16,44,.78); border:1px solid var(--silver); box-shadow:0 18px 32px rgba(5,9,25,.45)}
    .stat-card{display:flex; flex-direction:column; gap:6px; padding:6px 0}
    .stat-label{font-size:12px; text-transform:uppercase; letter-spacing:.12em; color:var(--muted)}
    .stat-value{font-size:26px; font-weight:700; letter-spacing:.02em; color:var(--ink)}

    .brain-viz{padding:20px 24px; border-radius:22px; background:rgba(11,16,44,.82); border:1px solid var(--silver); box-shadow:0 18px 32px rgba(5,9,25,.4); display:flex; flex-direction:column; gap:14px}
    .brain-viz.brain-viz--hidden{box-shadow:0 12px 24px rgba(5,9,25,.35)}
    .brain-head{display:flex; align-items:flex-start; justify-content:space-between; gap:18px; flex-wrap:wrap}
    .brain-title{font-size:16px; font-weight:600; letter-spacing:.03em}
    .brain-sub{font-size:12px; color:var(--muted); margin-top:4px; max-width:420px}
    .brain-controls{display:flex; align-items:center; flex-wrap:wrap; gap:10px; margin-top:12px}
    .brain-select{padding:7px 16px; border-radius:999px; border:1px solid rgba(56,189,248,.35); background:rgba(12,20,46,.75); color:var(--ink); font-size:12px; font-weight:600; letter-spacing:.05em; text-transform:uppercase; cursor:pointer; appearance:none; position:relative; min-width:190px; box-shadow:inset 0 0 16px rgba(56,189,248,.12)}
    .brain-select:focus-visible{outline:2px solid rgba(56,189,248,.65); outline-offset:3px}
    .brain-toggle{padding:6px 14px; border-radius:999px; border:1px solid rgba(56,189,248,.45); background:rgba(15,23,61,.6); color:var(--ink); font-size:11px; font-weight:600; letter-spacing:.12em; text-transform:uppercase; cursor:pointer; transition:transform .18s ease, box-shadow .2s ease, filter .2s ease}
    .brain-toggle:hover{filter:brightness(1.05); transform:translateY(-1px); box-shadow:0 12px 24px rgba(56,189,248,.25)}
    .brain-toggle[aria-pressed="false"]{border-color:rgba(244,114,182,.45); background:rgba(24,16,38,.65); color:var(--muted)}
    .brain-score{display:flex; flex-direction:column; align-items:flex-end; min-width:120px}
    .brain-score-label{font-size:11px; text-transform:uppercase; letter-spacing:.12em; color:var(--muted)}
    .brain-score-value{font-size:30px; font-weight:700; color:var(--ink)}
    .brain-team{display:flex; align-items:center; gap:10px; font-size:13px; color:var(--muted); flex-wrap:wrap}
    .brain-badge{display:inline-flex; align-items:center; justify-content:center; width:26px; height:26px; border-radius:50%; background:rgba(56,189,248,.3); color:#020617; font-size:15px; font-weight:700; box-shadow:0 0 18px rgba(56,189,248,.28)}
    .brain-gen{margin-left:auto; font-size:11px; color:var(--muted); letter-spacing:.08em; text-transform:uppercase}
    .brain-visual-wrap{display:flex; flex-wrap:wrap; gap:18px; align-items:stretch}
    .brain-canvas-wrap{flex:1 1 360px; min-width:0; display:flex; flex-direction:column; gap:10px}
    .brain-canvas{width:100%; height:220px; border-radius:18px; background:linear-gradient(135deg, rgba(15,23,61,.65), rgba(12,18,44,.92)); border:1px solid rgba(148,163,209,.28)}
    .brain-paused{padding:12px 14px; border-radius:14px; border:1px dashed rgba(148,163,209,.4); background:rgba(15,23,61,.55); font-size:12px; line-height:1.6; color:var(--muted)}
    .brain-legend{flex:0 1 240px; min-width:220px; align-self:stretch; border-radius:18px; border:1px solid rgba(148,163,209,.22); background:linear-gradient(135deg, rgba(10,18,46,.65), rgba(7,12,30,.82)); padding:16px 18px; display:flex; flex-direction:column; gap:14px; box-shadow:inset 0 0 18px rgba(59,130,246,.08)}
    .brain-legend.brain-legend--under{flex:1 1 100%; min-width:0; width:100%; margin-top:4px}
    .brain-legend-title{font-size:12px; font-weight:700; text-transform:uppercase; letter-spacing:.08em; color:var(--muted)}
    .brain-legend-list{list-style:none; margin:0; padding:0; display:grid; gap:10px}
    .brain-legend-item{display:flex; align-items:center; gap:10px; font-size:12px; line-height:1.5; color:var(--ink)}
    .brain-legend-dot{width:14px; height:14px; border-radius:50%; box-shadow:0 0 10px rgba(56,189,248,.45)}
    .brain-legend-dot-pair{display:inline-flex; align-items:center; gap:6px}
    .brain-legend-dot--target{background:linear-gradient(135deg, rgba(56,189,248,.9), rgba(96,165,250,.75))}
    .brain-legend-dot--target-home{background:linear-gradient(135deg, rgba(251,191,36,.9), rgba(253,224,71,.75)); box-shadow:0 0 10px rgba(251,191,36,.45)}
    .brain-legend-dot--gradient{background:linear-gradient(135deg, rgba(45,212,191,.9), rgba(16,185,129,.75)); box-shadow:0 0 10px rgba(45,212,191,.45)}
    .brain-legend-dot--separation{background:linear-gradient(135deg, rgba(244,114,182,.9), rgba(251,191,188,.75)); box-shadow:0 0 10px rgba(244,114,182,.45)}
    .brain-legend-dot--velocity{background:linear-gradient(135deg, rgba(167,139,250,.9), rgba(129,140,248,.75)); box-shadow:0 0 10px rgba(167,139,250,.45)}
    .brain-legend-dot--obstacle{background:linear-gradient(135deg, rgba(248,113,113,.9), rgba(239,68,68,.75)); box-shadow:0 0 10px rgba(248,113,113,.45)}
    .brain-legend-dot--boundary{background:linear-gradient(135deg, rgba(96,165,250,.9), rgba(59,130,246,.75)); box-shadow:0 0 10px rgba(96,165,250,.45)}
    .brain-legend-note{font-size:11px; line-height:1.6; color:var(--muted); border-top:1px dashed rgba(148,163,209,.3); padding-top:10px}
    .brain-guide{margin-top:16px; padding:18px 20px; border-radius:18px; border:1px solid var(--silver); background:rgba(11,16,44,.78); box-shadow:0 12px 28px rgba(5,9,25,.35);}
    .brain-guide summary{cursor:pointer; font-weight:600; letter-spacing:.04em; text-transform:uppercase; font-size:12px; color:var(--muted); display:flex; align-items:center; justify-content:space-between; gap:12px}
    .brain-guide summary::-webkit-details-marker{display:none}
    .brain-guide summary::after{content:'▾'; font-size:12px; transition:transform .25s ease}
    .brain-guide[open] summary::after{transform:rotate(-180deg)}
    .brain-guide-body{margin-top:14px; display:grid; gap:16px}
    .brain-guide-body p{margin:0; font-size:13px; color:var(--ink); line-height:1.7}
    .brain-diagram{border-radius:16px; border:1px solid rgba(148,163,209,.28); background:linear-gradient(135deg, rgba(15,23,61,.55), rgba(12,18,44,.9)); padding:14px}
    .brain-diagram svg{width:100%; height:auto}
    .brain-diagram text{fill:rgba(226,232,255,0.82); font-family:"Inter",system-ui,-apple-system,sans-serif; font-size:12px; letter-spacing:.02em}
    .brain-diagram .label{font-size:13px; font-weight:600}

    .side{width:420px; flex:0 1 420px; display:flex; flex-direction:column; gap:20px}
    .panel{background:var(--panel); border:1px solid var(--silver); padding:22px; border-radius:20px; backdrop-filter:blur(16px); box-shadow:0 18px 45px rgba(5,7,24,.55); position:relative}
    .panel-head{display:flex; align-items:center; justify-content:space-between; gap:12px; cursor:pointer; user-select:none; padding-bottom:10px; margin-bottom:14px; border-bottom:1px dashed rgba(189,206,255,.28)}
    .panel-head .h{margin:0; font-size:17px; letter-spacing:.03em}
    .chev{font-weight:900; font-size:16px; opacity:.75; transition:transform .25s ease}
    .panel-body{max-height:none; overflow:visible; transition:opacity .25s ease; opacity:1}
    .panel.collapsed .panel-body{max-height:0; opacity:0; overflow:hidden; pointer-events:none}
    .panel.collapsed .chev{transform:rotate(-90deg)}

    .grid{display:grid; grid-template-columns: 1fr 1.3fr auto; gap:12px 12px; align-items:center}
    .label{font-size:13px; color:var(--muted); letter-spacing:.02em}
    .val{font-family:ui-monospace,Menlo,Consolas,monospace; font-size:12px; padding:4px 8px; border-radius:8px; background:rgba(10,16,46,.7); border:1px solid var(--silver); color:var(--accent-cyan); box-shadow:inset 0 0 12px rgba(56,189,248,.12)}
    input[type=range]{width:100%; accent-color:var(--accent-cyan)}
    .ticket-placement-options{grid-column:2 / span 2; display:flex; flex-wrap:wrap; gap:8px}
    .ticket-placement-option{position:relative; display:inline-flex; align-items:center; gap:8px; padding:8px 12px; border-radius:12px; border:1px solid var(--silver); background:rgba(12,18,44,.65); color:var(--muted); font-size:12px; font-weight:600; letter-spacing:.03em; cursor:pointer; transition:filter .2s ease, transform .2s ease, box-shadow .2s ease, border-color .2s ease}
    .ticket-placement-option:hover{filter:brightness(1.05); transform:translateY(-1px)}
    .ticket-placement-option.active{border-color:rgba(56,189,248,.55); color:var(--ink); background:rgba(12,22,56,.9); box-shadow:0 10px 24px rgba(56,189,248,.18)}
    .ticket-placement-option input{position:absolute; inset:0; opacity:0; pointer-events:none}
    .btn{display:block; width:100%; padding:12px 14px; border-radius:12px; border:1px solid rgba(45,212,191,.45); background:linear-gradient(120deg, rgba(45,212,191,.18), rgba(59,130,246,.18)); color:var(--ink); cursor:pointer; text-align:center; margin-top:14px; font-weight:600; letter-spacing:.02em; transition:transform .2s ease, box-shadow .2s ease, filter .2s ease}
    .btn:hover{filter:brightness(1.08); transform:translateY(-1px); box-shadow:0 20px 36px rgba(45,212,191,.28)}
    .btn:disabled{opacity:.55; cursor:not-allowed; filter:saturate(.5); box-shadow:none}
    .tool-hint{margin:0 0 14px; font-size:12px; line-height:1.6; color:var(--muted)}
    .tool-buttons{display:grid; grid-template-columns:repeat(auto-fit,minmax(120px,1fr)); gap:10px}
    .tool-btn{padding:10px 12px; border-radius:12px; border:1px solid rgba(59,130,246,.28); background:rgba(18,27,66,.6); color:var(--ink); font-size:13px; font-weight:600; letter-spacing:.02em; cursor:pointer; transition:transform .2s ease, box-shadow .2s ease, filter .2s ease, border-color .2s ease}
    .tool-btn:hover{filter:brightness(1.05); transform:translateY(-1px); box-shadow:0 12px 26px rgba(59,130,246,.22)}
    .tool-btn.active{border-color:rgba(45,212,191,.65); background:linear-gradient(120deg, rgba(45,212,191,.24), rgba(59,130,246,.24)); box-shadow:0 14px 28px rgba(45,212,191,.24)}
    .control-chips{display:flex; flex-wrap:wrap; gap:8px; grid-column:2 / span 2}
    .chip-btn{padding:8px 12px; border-radius:10px; border:1px solid rgba(148,163,209,.35); background:rgba(12,18,44,.65); color:var(--ink); font-size:12px; font-weight:700; letter-spacing:.05em; cursor:pointer; transition:transform .18s ease, box-shadow .2s ease, filter .2s ease}
    .chip-btn:hover{filter:brightness(1.07); transform:translateY(-1px); box-shadow:0 12px 20px rgba(56,189,248,.18)}
    .chip-btn.chip-btn--ghost{border-style:dashed; color:var(--muted)}
    .chip-btn.chip-btn--hot{border-color:rgba(244,114,182,.65); box-shadow:0 12px 26px rgba(244,114,182,.18)}
    .dual-input{display:grid; grid-template-columns:1fr auto; gap:10px; grid-column:2 / span 2}
    .dual-input input[type=number]{width:120px; padding:9px 10px; border-radius:10px; border:1px solid var(--silver); background:rgba(12,18,44,.7); color:var(--ink); font-weight:700; letter-spacing:.03em}
    .layout-readout{margin:10px 0 4px; font-size:12px; line-height:1.6; color:var(--muted); background:rgba(11,16,44,.65); border:1px dashed rgba(148,163,209,.35); padding:12px 14px; border-radius:12px}
    .layout-readout strong{color:var(--ink)}
    .layout-hint{font-size:11px; color:var(--muted); grid-column:1 / span 3; line-height:1.5; background:rgba(8,12,32,.65); border:1px solid rgba(148,163,209,.28); padding:10px 12px; border-radius:12px}
    .layout-mini-grid{display:grid; grid-template-columns:repeat(auto-fit,minmax(160px,1fr)); gap:10px; grid-column:1 / span 3}
    .layout-mini-grid .val{text-align:left}
    .sub{font-weight:800; font-size:14px; opacity:.9; margin:10px 0 8px; letter-spacing:.05em; color:var(--ink)}
    .team-roster{display:grid; grid-template-columns:repeat(auto-fit,minmax(160px,1fr)); gap:12px}
    .team-card{position:relative; display:flex; flex-direction:column; gap:6px; padding:14px 16px; border-radius:14px; border:1px solid var(--silver); background:rgba(12,18,44,.72); box-shadow:0 10px 24px rgba(5,9,28,.4); transition:transform .2s ease, box-shadow .2s ease, border-color .2s ease}
    .team-card:hover{transform:translateY(-2px); box-shadow:0 16px 32px rgba(5,9,28,.5)}
    .team-card.active{border-color:rgba(45,212,191,.6); box-shadow:0 18px 36px rgba(45,212,191,.22)}
    .team-card input[type=checkbox]{position:absolute; inset:0; opacity:0; cursor:pointer; border-radius:14px}
    .team-card .team-header{display:flex; align-items:center; gap:10px}
    .team-card .team-name{font-weight:600; letter-spacing:.02em}
    .team-card .team-meta{font-size:12px; color:var(--muted)}
    .team-score{font-size:12px; color:var(--ink); font-weight:600; margin-top:2px}
    .team-score span{color:var(--muted); font-weight:500}
    .team-badge{display:inline-flex; align-items:center; justify-content:center; width:28px; height:28px; border-radius:50%; font-size:16px; box-shadow:0 0 18px rgba(255,255,255,.2); color:#020617}
    .team-configs{display:grid; gap:16px; margin-top:16px}
    .team-config-card{border:1px solid var(--silver); border-radius:16px; background:rgba(12,18,44,.72); padding:18px 20px; box-shadow:0 12px 28px rgba(5,9,28,.45); display:grid; gap:14px; transition:filter .2s ease, border-color .2s ease}
    .team-config-card.inactive{filter:saturate(.65) brightness(.85); border-color:rgba(148,163,209,.28)}
    .team-config-header{display:flex; align-items:center; justify-content:space-between; gap:12px}
    .team-config-title{display:flex; align-items:center; gap:10px; font-weight:600; letter-spacing:.02em}
    .team-config-badge{display:inline-flex; align-items:center; justify-content:center; width:26px; height:26px; border-radius:50%; box-shadow:0 0 12px rgba(148,163,209,.28); font-size:15px}
    .team-config-status{font-size:12px; color:var(--muted)}
    .team-config-grid{display:grid; grid-template-columns: minmax(90px,0.9fr) 1fr auto; gap:10px 12px; align-items:center}
    .team-config-grid .label{font-size:12px; text-transform:uppercase; letter-spacing:.08em}
    .team-config-grid .val{min-width:56px; text-align:right}
    .music-lead{font-size:13px; line-height:1.6; opacity:.85; margin:0 0 14px}
    .music-select{display:flex; flex-direction:column; gap:6px}
    .music-dropdown{width:100%; padding:10px 12px; border-radius:12px; border:1px solid var(--silver); background:rgba(12,18,44,.82); color:var(--ink); font-size:13px; font-family:inherit; letter-spacing:.01em; box-shadow:inset 0 0 12px rgba(118,133,255,.15)}
    .music-controls{display:flex; align-items:center; gap:12px; margin-top:12px; flex-wrap:wrap}
    .music-controls .btn{flex:0 0 auto; width:auto; padding:10px 18px; margin-top:0}
    .music-volume{display:flex; flex:1; align-items:center; gap:10px; min-width:200px}
    .music-volume .label{min-width:60px}
    .music-volume input[type=range]{flex:1}
    .music-meta{margin-top:14px; font-size:12px; line-height:1.6; background:rgba(11,16,44,.65); border:1px solid var(--silver); padding:12px 14px; border-radius:14px; box-shadow:inset 0 0 14px rgba(138,92,246,.12)}
    .music-status{display:flex; align-items:center; gap:8px; font-size:12px; text-transform:uppercase; letter-spacing:.08em; opacity:.82; color:var(--accent-cyan)}
    .music-attr{opacity:.72}
    .sr-only{position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0}

    .gen-history{margin-top:10px; padding:10px 12px; border-radius:12px; border:1px solid rgba(148,163,209,.28); background:rgba(8,12,32,.68); box-shadow:inset 0 0 12px rgba(59,130,246,.12); display:flex; flex-direction:column; gap:8px}
    .gen-history .title{font-size:12px; text-transform:uppercase; letter-spacing:.08em; color:var(--muted)}
    .gen-history-row{display:flex; align-items:flex-end; gap:4px; min-height:36px}
    .gen-history-bar{flex:1; min-width:6px; background:linear-gradient(180deg, rgba(59,130,246,.8), rgba(109,40,217,.75)); border-radius:6px 6px 0 0; box-shadow:0 6px 14px rgba(59,130,246,.14)}
    .gen-history-bar.avg{background:linear-gradient(180deg, rgba(45,212,191,.8), rgba(16,185,129,.75))}
    .gen-history-bar.acc{background:linear-gradient(180deg, rgba(250,204,21,.9), rgba(234,179,8,.8))}
    .gen-history-legend{display:flex; gap:8px; flex-wrap:wrap; font-size:11px; color:var(--muted)}
    .gen-history-dot{width:10px; height:10px; border-radius:50%; display:inline-block; margin-right:6px; box-shadow:0 0 10px currentColor}

    .chip-line{display:flex; flex-wrap:wrap; gap:8px; margin-top:12px}
    .chip-line .chip{display:inline-flex; align-items:center; gap:6px; padding:8px 12px; border-radius:14px; border:1px solid rgba(148,163,209,.35); background:rgba(12,18,44,.65); box-shadow:0 8px 18px rgba(15,23,61,.25); font-size:12px; font-weight:700; letter-spacing:.03em; color:var(--ink)}
    .chip .dot{width:10px; height:10px; border-radius:50%; box-shadow:0 0 12px currentColor}
    .chip-line .chip.heat{border-color:rgba(59,130,246,.45); background:linear-gradient(120deg, rgba(56,189,248,.16), rgba(99,102,241,.18))}
    .chip-line .chip.low{opacity:.7; filter:saturate(.75)}

    .holo-feed{margin-top:12px; border:1px solid rgba(148,163,209,.28); border-radius:14px; background:rgba(8,12,32,.68); box-shadow:inset 0 0 18px rgba(59,130,246,.12); padding:12px 14px; display:grid; gap:8px}
    .feed-item{display:grid; grid-template-columns:auto 1fr; gap:8px; align-items:center; font-size:12px; color:var(--ink)}
    .feed-pill{display:inline-flex; align-items:center; justify-content:center; padding:4px 8px; border-radius:10px; border:1px solid rgba(148,163,209,.35); background:rgba(12,18,44,.82); font-weight:700; letter-spacing:.05em}
    .feed-item strong{color:var(--ink)}
    .feed-item .tone-good{color:#22d3ee}
    .feed-item .tone-warn{color:#facc15}
    .feed-item .tone-bad{color:#f87171}

    body.performance-mode{background:radial-gradient(circle at 50% 18%, rgba(59,130,246,.22) 0%, rgba(15,23,42,.9) 55%, #030513 100%);}
    body.performance-mode .brand, body.performance-mode .nav-links{display:none}
    body.performance-mode .main-nav{background:transparent; border:none; box-shadow:none; padding:20px 28px; justify-content:flex-end}
    body.performance-mode .main-nav::before{display:none}
    body.performance-mode .wrap{max-width:none; justify-content:center}
    body.performance-mode main{padding:40px 0 60px}
    body.performance-mode .side, body.performance-mode .stats-bar, body.performance-mode .brain-viz, body.performance-mode .brain-guide{display:none !important}
    body.performance-mode .field-area{align-items:center; gap:28px}
    body.performance-mode .field-area > :not(.playfield-frame){display:none !important}
    body.performance-mode .playfield-frame{max-width:min(1100px, 92vw); width:100%; padding:28px; border:1px solid rgba(148,163,209,.35); background:rgba(8,12,30,.82); box-shadow:0 0 40px rgba(56,189,248,.35), 0 0 140px rgba(244,114,182,.25)}
    body.performance-mode .playfield-frame::before{opacity:1; filter:blur(22px)}
    body.performance-mode canvas{width:100%; height:auto; box-shadow:0 0 55px rgba(56,189,248,.22), inset 0 0 28px rgba(148,163,209,.16); border:1px solid rgba(148,163,209,.45)}
    body.performance-mode #btnPerformance{pointer-events:auto}

    @media (max-width:1200px){
      .wrap{flex-direction:column; align-items:center}
      .field-area{width:100%}
      .side{width:100%; max-width:720px}
    }
    @media (max-width:900px){
      main{padding:32px 28px 56px}
    }
    @media (max-width:768px){
      .main-nav{flex-direction:column; align-items:flex-start; gap:16px; padding:18px 24px}
      .nav-links{flex-wrap:wrap}
      main{padding:28px 20px 56px}
      .wrap{gap:28px}
      canvas{width:100%; height:auto}
      .stats-bar{grid-template-columns:repeat(auto-fit,minmax(130px,1fr)); gap:12px; padding:16px 18px}
      .stat-value{font-size:22px}
      .side{max-width:100%}
      .brain-canvas{height:200px}
      .brain-visual-wrap{flex-direction:column}
      .brain-legend{width:100%; min-width:0}
    }
  </style>
</head>
<body>
  <header class="main-nav">
    <div class="brand"><span class="brand-dot"></span>Data Sorting NEAT Lab</div>
    <nav class="nav-links" aria-label="Primary navigation">
      <a class="pill-link secondary" href="learn-neat.html">How NEAT works</a>
      <a class="pill-link" href="index.html">← Start</a>
    </nav>
    <button type="button" id="btnPerformance" class="pill-button" aria-pressed="false" title="Focus on the playfield and boost frame rates">Performance</button>
  </header>
  <main>
  <div class="wrap">
    <!-- Left panel: Learning (NEAT) -->
    <aside class="side" id="left-panel">
      <div class="panel collapsed" id="panel-learn">
        <div class="panel-head" role="button" tabindex="0" aria-expanded="false" aria-controls="panel-learn-body"><div class="h">Learning (NEAT-lite)</div><span class="chev">▾</span></div>
        <div class="panel-body" id="panel-learn-body">
          <div class="grid">
            <div class="label" title="Number of simulation steps each generation runs before evaluating fitness.">Steps / gen</div>
            <input id="slGenSteps" type="range" min="600" max="100000" value="2800" title="Number of simulation steps each generation runs before evaluating fitness."><div class="val" id="lbGenSteps">2800</div>

            <div class="label" title="Hidden neurons connecting the sensory inputs to the outputs.">Hidden neurons</div>
            <input id="slHidden" type="range" min="4" max="96" value="16" title="Hidden neurons connecting the sensory inputs to the outputs."><div class="val" id="lbHidden">16 neurons</div>

            <div class="label" title="Percentage of offspring genomes that receive random mutations.">Mutation %</div>
            <input id="slMut" type="range" min="1" max="80" value="16" title="Percentage of offspring genomes that receive random mutations."><div class="val" id="lbMut">16%</div>

            <div class="label" title="Share of the best performers copied directly into the next generation.">Elite ratio</div>
            <input id="slElite" type="range" min="1" max="100" value="20" title="Share of the best performers copied directly into the next generation."><div class="val" id="lbElite">20%</div>

            <div class="label" title="Strength of the random adjustments applied to neural network connection weights.">Mutate weights</div>
            <input id="slMutStrengthW" type="range" min="5" max="100" value="20" title="Strength of the random adjustments applied to neural network connection weights."><div class="val" id="lbMutStrengthW">0.20</div>

            <div class="label" title="Strength of the random adjustments applied to neuron bias values.">Mutate biases</div>
            <input id="slMutStrengthB" type="range" min="5" max="100" value="20" title="Strength of the random adjustments applied to neuron bias values."><div class="val" id="lbMutStrengthB">0.20</div>

            <div class="label" title="Chance that crossover keeps genes from parent A versus parent B.">Crossover bias</div>
            <input id="slCrossover" type="range" min="0" max="100" value="50" title="Chance that crossover keeps genes from parent A versus parent B."><div class="val" id="lbCrossover">50% A</div>

            <div class="label" title="Number of contenders in the tournament pool when picking parents.">Selection pool</div>
            <input id="slTournament" type="range" min="10" max="60" value="20" step="1" title="Number of contenders in the tournament pool when picking parents."><div class="val" id="lbTournament">×2.0</div>

            <div class="label" title="Percentage of brand new genomes injected into each generation.">Fresh spawn %</div>
            <input id="slFresh" type="range" min="0" max="40" value="0" title="Percentage of brand new genomes injected into each generation."><div class="val" id="lbFresh">0%</div>

            <div class="label" title="Automatically advance once the current generation finishes simulating.">Auto next gen</div>
            <input id="chkAuto" type="checkbox" checked title="Automatically advance once the current generation finishes simulating."><div class="val" id="lbAuto">on</div>
          </div>
          <button id="btnNextGen" class="btn">Advance generation now</button>
          <button id="btnResetTraining" class="btn">Reset training</button>
          <button id="btnSaveTraining" class="btn">Save training (.json)</button>
          <button id="btnLoadTraining" class="btn">Load training…</button>
          <input type="file" id="inputLoadTraining" accept="application/json" style="display:none">
          <button id="btnReplayChampion" class="btn">Replay best genome</button>
        </div>
      </div>

      <div class="panel collapsed" id="panel-toolbox">
        <div class="panel-head" role="button" tabindex="0" aria-expanded="false" aria-controls="panel-toolbox-body"><div class="h">Obstacle toolbox</div><span class="chev">▾</span></div>
        <div class="panel-body" id="panel-toolbox-body">
          <p class="tool-hint">Choose a tool to draw glowing obstacles directly on the field.</p>
          <div class="tool-buttons" role="group" aria-label="Obstacle drawing tools">
            <button class="tool-btn active" data-tool="select" aria-pressed="true">Move</button>
            <button class="tool-btn" data-tool="circle" aria-pressed="false">Circle</button>
            <button class="tool-btn" data-tool="rect" aria-pressed="false">Rectangle</button>
            <button class="tool-btn" data-tool="line" aria-pressed="false">Line</button>
            <button class="tool-btn" data-tool="half" aria-pressed="false">Half circle</button>
          </div>
          <button id="btnUndoManual" class="btn" disabled>Undo last manual obstacle</button>
          <button id="btnClearManual" class="btn">Clear manual obstacles</button>
          <button id="btnGenerateLabyrinth" class="btn">Generate labyrinth</button>
          <button id="btnSaveObstacles" class="btn">Save obstacles (.json)</button>
          <button id="btnLoadObstacles" class="btn">Load obstacles…</button>
          <input type="file" id="inputLoadObstacles" accept="application/json" style="display:none">
        </div>
      </div>

      <div class="panel collapsed" id="panel-music">
        <div class="panel-head" role="button" tabindex="0" aria-expanded="false" aria-controls="panel-music-body"><div class="h">Ambient Sound Lounge</div><span class="chev">▾</span></div>
        <div class="panel-body" id="panel-music-body">
          <p class="music-lead">Play MP3 files from your audio folder. Add your own tracks to the list!</p>
          <div class="music-select">
            <label class="label" for="selMusic">Curated playlist</label>
            <select id="selMusic" class="music-dropdown"></select>
          </div>
          <div class="music-controls">
            <button id="btnMusicToggle" class="btn">Play</button>
            <div class="music-volume">
              <span class="label">Volume</span>
              <input id="slMusicVolume" type="range" min="0" max="100" value="55">
              <span class="val" id="lbMusicVolume">55%</span>
            </div>
          </div>
          <div class="music-meta">
            <div class="music-status"><span id="lbMusicState">Paused</span></div>
            <div id="lbMusicNow" class="music-attr">Choose a track to begin.</div>
            <div id="lbMusicSource" class="music-attr">Royalty-free ambient selections streamed from Pixabay artists.</div>
          </div>
        </div>
      </div>
    </aside>

    <!-- Middle: playfield -->
    <div class="field-area">
      <div class="playfield-frame">
        <canvas id="world" width="1100" height="640"></canvas>
      </div>
      <section class="stats-bar" aria-label="Simulation progress" aria-live="polite">
        <div class="stat-card">
          <span class="stat-label">Generation</span>
          <span class="stat-value" id="stat-gen">1</span>
        </div>
        <div class="stat-card">
          <span class="stat-label">Agents active</span>
          <span class="stat-value" id="stat-teams">2</span>
        </div>
        <div class="stat-card">
          <span class="stat-label">Tickets on field</span>
          <span class="stat-value" id="stat-tickets">0</span>
        </div>
        <div class="stat-card">
          <span class="stat-label">Sorting result</span>
          <span class="stat-value" id="stat-deliveries">0</span>
        </div>
        <div class="stat-card">
          <span class="stat-label">Top fitness</span>
          <span class="stat-value" id="stat-top">0</span>
        </div>
      </section>
      <div class="gen-history" id="genHistory" aria-label="Generation history">
        <div class="title">Recent generations</div>
        <div class="gen-history-row" id="genHistoryBars"></div>
        <div class="gen-history-legend">
          <span><span class="gen-history-dot" style="color:#60a5fa"></span>Best</span>
          <span><span class="gen-history-dot" style="color:#34d399"></span>Avg</span>
          <span><span class="gen-history-dot" style="color:#facc15"></span>Accuracy</span>
        </div>
      </div>
      <div class="layout-readout" id="layoutReadout">Drag handles are off. Enable them in Layout lab to reposition targets and the nest.</div>
      <div class="chip-line" id="chipLine" aria-label="Ticket heat"></div>
      <div class="holo-feed" id="eventFeed" aria-live="polite" aria-label="Live agent feed"></div>
      <section class="brain-viz brain-viz--hidden" aria-live="polite" aria-label="Best performing neural network">
        <div class="brain-head">
          <div>
            <div class="brain-title">Neural Network Monitor</div>
            <div class="brain-sub" id="brain-subtitle">The leading brain will appear here once a team starts scoring.</div>
            <div class="brain-controls">
              <label class="sr-only" for="brainTeamSelect">Choose the team to visualize</label>
              <select id="brainTeamSelect" class="brain-select">
                <option value="auto">Auto — top performer</option>
              </select>
              <button type="button" id="brainToggleBtn" class="brain-toggle" aria-pressed="false">
                Show visualization
              </button>
            </div>
          </div>
          <div class="brain-score">
            <span class="brain-score-label">Fitness</span>
            <span class="brain-score-value" id="brain-fitness">—</span>
          </div>
        </div>
        <div class="brain-team">
          <span class="brain-badge" id="brain-badge">●</span>
          <span id="brain-team">No leader yet</span>
          <span class="brain-gen" id="brain-generation">Gen —</span>
        </div>
        <div class="brain-visual-wrap">
          <div class="brain-canvas-wrap">
            <canvas id="brainVizCanvas" class="brain-canvas" width="560" height="240" role="img" aria-label="Visualization of the current top neural network" hidden></canvas>
            <div id="brainPausedNotice" class="brain-paused">
              Visualization hidden to save performance. Toggle it back on anytime to resume live updates.
            </div>
          </div>
          <aside class="brain-legend brain-legend--under" aria-label="Neural network legend">
            <div class="brain-legend-section">
              <div class="brain-legend-title">Inputs</div>
              <ul class="brain-legend-list">
                <li class="brain-legend-item"><span class="brain-legend-dot-pair" aria-hidden="true"><span class="brain-legend-dot brain-legend-dot--target"></span><span class="brain-legend-dot brain-legend-dot--target-home"></span></span><span>Ticket direction turns cyan — it glows amber while carrying an item to the right zone.</span></li>
                <li class="brain-legend-item"><span class="brain-legend-dot brain-legend-dot--gradient" aria-hidden="true"></span><span>Trail gradient pointing toward a ticket or back to its destination.</span></li>
                <li class="brain-legend-item"><span class="brain-legend-dot brain-legend-dot--separation" aria-hidden="true"></span><span>Repulsion from nearby teammates to prevent crowding.</span></li>
                <li class="brain-legend-item"><span class="brain-legend-dot brain-legend-dot--obstacle" aria-hidden="true"></span><span>Obstacle avoidance pulse steering away from hazards.</span></li>
                <li class="brain-legend-item"><span class="brain-legend-dot brain-legend-dot--boundary" aria-hidden="true"></span><span>Wall clearance hint nudging agents toward open space.</span></li>
                <li class="brain-legend-item"><span class="brain-legend-dot brain-legend-dot--velocity" aria-hidden="true"></span><span>Blocker-only: predicted movement of the closest rival.</span></li>
              </ul>
            </div>
            <div class="brain-legend-note">Toggle “Sensor overlay” in Global controls to paint these signals directly on the field.</div>
            <div class="brain-legend-section">
              <div class="brain-legend-title">Outputs</div>
              <ul class="brain-legend-list">
                <li class="brain-legend-item">Drive X / Drive Y — steering left &amp; right</li>
                <li class="brain-legend-item">Speed + — accelerate</li>
                <li class="brain-legend-item">Speed − — brake</li>
              </ul>
            </div>
          </aside>
        </div>
      </section>
      <details class="brain-guide" id="brainGuide">
        <summary>Neural network visual guide</summary>
        <div class="brain-guide-body">
          <p>
            This panel shows the brain of whichever agent is leading the sorting challenge right now. Circles on the left are the signals the
            agents feel — ticket direction, teammate distance, obstacle pings and the round timer. The middle dots mix those signals,
            and the four outputs on the right tell the agent how to turn and how fast to move.
          </p>
          <figure class="brain-diagram">
            <svg viewBox="0 0 520 220" role="img" aria-labelledby="brain-diagram-title brain-diagram-desc">
              <title id="brain-diagram-title">Neural network layers</title>
              <desc id="brain-diagram-desc">Inputs flow to hidden neurons and then to four output commands.</desc>
              <defs>
                <linearGradient id="nodeInput" x1="0" x2="1" y1="0" y2="1">
                  <stop offset="0%" stop-color="#38bdf8" stop-opacity="0.6" />
                  <stop offset="100%" stop-color="#38bdf8" stop-opacity="0.2" />
                </linearGradient>
                <linearGradient id="nodeHidden" x1="0" x2="1" y1="0" y2="1">
                  <stop offset="0%" stop-color="#2dd4bf" stop-opacity="0.6" />
                  <stop offset="100%" stop-color="#2dd4bf" stop-opacity="0.2" />
                </linearGradient>
                <linearGradient id="nodeOutput" x1="0" x2="1" y1="0" y2="1">
                  <stop offset="0%" stop-color="#f472b6" stop-opacity="0.6" />
                  <stop offset="100%" stop-color="#f472b6" stop-opacity="0.2" />
                </linearGradient>
              </defs>
              <g stroke="rgba(148,163,209,0.35)" stroke-width="1.2">
                <line x1="110" y1="40" x2="260" y2="40" />
                <line x1="110" y1="40" x2="260" y2="100" />
                <line x1="110" y1="40" x2="260" y2="160" />
                <line x1="110" y1="100" x2="260" y2="40" />
                <line x1="110" y1="100" x2="260" y2="100" />
                <line x1="110" y1="100" x2="260" y2="160" />
                <line x1="110" y1="160" x2="260" y2="40" />
                <line x1="110" y1="160" x2="260" y2="100" />
                <line x1="110" y1="160" x2="260" y2="160" />
                <line x1="260" y1="40" x2="410" y2="40" />
                <line x1="260" y1="40" x2="410" y2="90" />
                <line x1="260" y1="40" x2="410" y2="140" />
                <line x1="260" y1="40" x2="410" y2="190" />
                <line x1="260" y1="100" x2="410" y2="40" />
                <line x1="260" y1="100" x2="410" y2="90" />
                <line x1="260" y1="100" x2="410" y2="140" />
                <line x1="260" y1="100" x2="410" y2="190" />
                <line x1="260" y1="160" x2="410" y2="40" />
                <line x1="260" y1="160" x2="410" y2="90" />
                <line x1="260" y1="160" x2="410" y2="140" />
                <line x1="260" y1="160" x2="410" y2="190" />
              </g>
              <g fill="url(#nodeInput)">
                <circle cx="110" cy="40" r="18"></circle>
                <circle cx="110" cy="100" r="18"></circle>
                <circle cx="110" cy="160" r="18"></circle>
              </g>
              <g fill="url(#nodeHidden)">
                <circle cx="260" cy="40" r="16"></circle>
                <circle cx="260" cy="100" r="16"></circle>
                <circle cx="260" cy="160" r="16"></circle>
              </g>
              <g fill="url(#nodeOutput)">
                <circle cx="410" cy="40" r="18"></circle>
                <circle cx="410" cy="90" r="18"></circle>
                <circle cx="410" cy="140" r="18"></circle>
                <circle cx="410" cy="190" r="18"></circle>
              </g>
              <text class="label" x="110" y="200" text-anchor="middle">Inputs</text>
              <text class="label" x="260" y="200" text-anchor="middle">Hidden layer</text>
              <text class="label" x="410" y="200" text-anchor="middle">Outputs</text>
              <text x="440" y="40" text-anchor="start" dominant-baseline="middle">Drive X</text>
              <text x="440" y="90" text-anchor="start" dominant-baseline="middle">Drive Y</text>
              <text x="440" y="140" text-anchor="start" dominant-baseline="middle">Speed +</text>
              <text x="440" y="190" text-anchor="start" dominant-baseline="middle">Speed −</text>
            </svg>
          </figure>
          <p>
            Bright lines mean a strong signal. Cyan edges push movement in the same direction as the input, while magenta edges flip
            the response. Watching the colours change makes it easier to spot why a team turns, speeds up or slows down.
          </p>
          <p>
            The badge above the diagram lists which team owns the brain and which generation discovered it so you always know whose
            strategy you are following.
          </p>
        </div>
      </details>
    </div>

    <!-- Right panels: controls and teams -->
    <aside class="side" id="right-panel">
      <div class="panel collapsed" id="panel-global">
        <div class="panel-head" role="button" tabindex="0" aria-expanded="false" aria-controls="panel-global-body"><div class="h">Global controls</div><span class="chev">▾</span></div>
        <div class="panel-body" id="panel-global-body">
          <div class="grid">
            <div class="label">Ticket (max)</div>
            <input id="slTickets" type="range" min="2" max="1000" value="32"><div class="val" id="lbTickets">32</div>

            <div class="label">Population</div>
            <input id="slPopulation" type="range" min="5" max="180" value="30"><div class="val" id="lbPopulation">30</div>

            <div class="label">Population presets</div>
            <div class="control-chips">
              <button class="chip-btn" data-pop="20">Sprint (20)</button>
              <button class="chip-btn" data-pop="60">Balanced (60)</button>
              <button class="chip-btn chip-btn--hot" data-pop="120">Swarm (120)</button>
            </div>

            <div class="label">Population exact</div>
            <div class="dual-input">
              <input id="numPopulation" type="number" min="5" max="240" value="30" step="1">
              <button class="chip-btn chip-btn--ghost" id="btnPopApply">Apply</button>
            </div>

            <div class="layout-hint">Tip: set a small sprint population to test a layout tweak, then jump to a swarm to stress test the strategy.</div>

            <div class="label" id="ticketPlacementLabel">Ticket placement</div>
            <div class="ticket-placement-options" role="group" aria-labelledby="ticketPlacementLabel">
              <label class="ticket-placement-option">
                <input type="checkbox" name="ticketPlacement" value="sw">
                <span aria-hidden="true">BL</span>
                <span class="sr-only">Bottom left</span>
              </label>
              <label class="ticket-placement-option">
                <input type="checkbox" name="ticketPlacement" value="se">
                <span aria-hidden="true">BR</span>
                <span class="sr-only">Bottom right</span>
              </label>
              <label class="ticket-placement-option">
                <input type="checkbox" name="ticketPlacement" value="ne">
                <span aria-hidden="true">TR</span>
                <span class="sr-only">Top right</span>
              </label>
              <label class="ticket-placement-option">
                <input type="checkbox" name="ticketPlacement" value="nw">
                <span aria-hidden="true">TL</span>
                <span class="sr-only">Top left</span>
              </label>
              <label class="ticket-placement-option">
                <input type="checkbox" name="ticketPlacement" value="center">
                <span aria-hidden="true">C</span>
                <span class="sr-only">Center</span>
              </label>
              <label class="ticket-placement-option">
                <input type="checkbox" name="ticketPlacement" value="random" checked>
                <span aria-hidden="true">R</span>
                <span class="sr-only">Random</span>
              </label>
            </div>

            <div class="label">Spawn (ms)</div>
            <input id="slSpawn" type="range" min="120" max="15000" value="900"><div class="val" id="lbSpawn">900</div>

            <div class="label">Adaptive load</div>
            <input id="chkAdaptiveLoad" type="checkbox" checked><div class="val" id="lbAdaptiveLoad">on</div>

            <div class="label">Scenario presets</div>
            <div class="control-chips">
              <button class="chip-btn" id="btnPresetBalanced">Balanced</button>
              <button class="chip-btn" id="btnPresetIncident">Incident storm</button>
              <button class="chip-btn chip-btn--hot" id="btnPresetService">Service Friday</button>
            </div>

            <div class="label">Simulation speed</div>
            <input id="slSimSpeed" type="range" min="10" max="600" value="100" step="5"><div class="val" id="lbSimSpeed">1.00×</div>

            <div class="label">Obstacles</div>
            <input id="slObst" type="range" min="0" max="40" value="0"><div class="val" id="lbObst">0</div>

            <div class="label">Trail length</div>
            <input id="slTail" type="range" min="4" max="1500" value="24"><div class="val" id="lbTail">24</div>

            <div class="label">Snake size</div>
            <input id="slAgentScale" type="range" min="50" max="150" value="100" step="5"><div class="val" id="lbAgentScale">1.00×</div>

            <div class="label">Agent collisions</div>
            <input id="chkAgentCollisions" type="checkbox"><div class="val" id="lbAgentCollisions">off</div>

            <div class="label">Top performer glow</div>
            <input id="chkTopHighlight" type="checkbox" checked><div class="val" id="lbTopHighlight">on</div>

            <div class="label">Energy rings</div>
            <input id="chkEnergyHalo" type="checkbox" checked><div class="val" id="lbEnergyHalo">on</div>

            <div class="label">Energy empty speed</div>
            <input id="slEnergyEmptySpeed" type="range" min="10" max="100" value="45" step="5"><div class="val" id="lbEnergyEmptySpeed">45%</div>

            <div class="label">Energy capacity</div>
            <input id="slEnergyCapacity" type="range" min="0" max="300" value="120" step="10"><div class="val" id="lbEnergyCapacity">120</div>

            <div class="label">Awareness boost</div>
            <input id="slAwarenessBoost" type="range" min="50" max="200" value="100" step="5"><div class="val" id="lbAwarenessBoost">100%</div>

            <div class="label" title="Agents that run out of energy will be removed and penalized.">Energy exhaustion death</div>
            <input id="chkEnergyDeath" type="checkbox"><div class="val" id="lbEnergyDeath">off</div>

            <div class="label">Sensor overlay</div>
            <input id="chkSensorRadar" type="checkbox"><div class="val" id="lbSensorRadar">off</div>

            <div class="label">Navigation preset</div>
            <select id="selNavPreset" class="music-dropdown">
              <option value="open">Open Field</option>
              <option value="lab">Labyrinth</option>
            </select><div class="val" id="lbNavPreset">Open Field</div>

            <div class="layout-hint">Layout lab controls — drag the three category targets or the nest while this mode is enabled to sculpt the arena.</div>
            <div class="layout-mini-grid">
              <div>
                <div class="label">Drag targets + nest</div>
                <div class="val"><label><input id="chkLayoutDrag" type="checkbox" checked> Drag enabled</label></div>
              </div>
              <div>
                <div class="label">Snap to grid</div>
                <div class="val"><label><input id="chkLayoutSnap" type="checkbox"> Off</label></div>
              </div>
              <div>
                <div class="label">Grid size</div>
                <input id="slGridSize" type="range" min="20" max="140" value="60" step="5"><div class="val" id="lbGridSize">60 px</div>
              </div>
              <div>
                <div class="label">Nest radius</div>
                <input id="slNestR" type="range" min="30" max="140" value="64"><div class="val" id="lbNestR">64</div>
              </div>
              <div>
                <div class="label">Target radius</div>
                <input id="slTargetR" type="range" min="30" max="140" value="60"><div class="val" id="lbTargetR">60</div>
              </div>
              <div>
                <div class="label">Ticket scatter</div>
                <input id="slScatter" type="range" min="20" max="240" value="40"><div class="val" id="lbScatter">40</div>
              </div>
            </div>

            <div class="control-chips" style="grid-column:1 / span 3">
              <button class="chip-btn" id="btnLayoutReset">Reset layout</button>
              <button class="chip-btn" id="btnLayoutRandom">Randomize</button>
              <button class="chip-btn chip-btn--hot" id="btnLayoutFan">Fan-out arc</button>
              <button class="chip-btn chip-btn--ghost" id="btnToggleGrid">Grid overlay</button>
            </div>
          </div>
          <button id="btnReset" class="btn">Restart</button>
        </div>
      </div>

      <div class="panel collapsed" id="panel-teams">
        <div class="panel-head" role="button" tabindex="0" aria-expanded="false" aria-controls="panel-teams-body"><div class="h">Team settings</div><span class="chev">▾</span></div>
        <div class="panel-body" id="panel-teams-body">
          <div class="sub">Teams</div>
          <div class="team-roster" id="teamRoster"></div>
          <div class="sub" style="margin-top:14px">Attributes per team</div>
          <div class="team-configs" id="teamConfigs"></div>
        </div>
      </div>
    </aside>
  </div>
  </main>


<script>

// Data Sorting variant of Foodwars
const Q = (id)=>document.getElementById(id);
const canvas = Q('world');
const ctx = canvas.getContext('2d');
const W = canvas.width;
const H = canvas.height;
const diag = Math.hypot(W, H);

const categories = [
  { id:'incident', label:'Incident', color:'#ef4444', zone:{ x: W*0.18, y: H*0.25, r: 60 } },
  { id:'service', label:'Service Request', color:'#22c55e', zone:{ x: W*0.5, y: H*0.75, r: 60 } },
  { id:'problem', label:'Problem', color:'#3b82f6', zone:{ x: W*0.82, y: H*0.35, r: 60 } }
];

const pickupByType = Object.fromEntries(categories.map(c=> [c.id,0]));
const deliveredByType = Object.fromEntries(categories.map(c=> [c.id,0]));
const liveFeed = [];

const nest = { x: W*0.5, y: H*0.12, r: 64 };

const defaultLayout = {
  nest: {...nest},
  categories: categories.map(c=> ({...c, zone:{...c.zone}}))
};

const ticketTypeWeights = Object.fromEntries(categories.map(c=> [c.id, 1]));
let placementPreset = 'balanced';
let replayMode = false;
let replaySeed = 1;

const layoutState = {
  dragEnabled: true,
  snap: false,
  gridSize: 60,
  showGrid: false,
  active: null
};

const generationHistory = [];

function resetReplaySeed(){ replaySeed = 1; }
function rand(){
  if(replayMode){
    replaySeed = (replaySeed * 9301 + 49297) % 233280;
    return replaySeed / 233280;
  }
  return Math.random();
}

function pickTicketType(){
  const options = categories.map(c=> ({id:c.id, w: Math.max(0.01, ticketTypeWeights[c.id] || 1)}));
  const total = options.reduce((s,o)=> s + o.w, 0);
  let r = rand()*total;
  for(const o of options){
    r -= o.w;
    if(r <= 0) return o.id;
  }
  return options[options.length-1].id;
}

const params = {
  maxTickets: 32,
  spawnMs: 900,
  simSpeed: 1,
  tailLen: 24,
  agentScale: 1,
  agentCollisions: false,
  topHighlight: true,
  maxObstacles: 0,
  generationSteps: 2800,
  populationSize: 30,
  ticketScatter: 40,
  accel: 90,
  maxSpeed: 110,
  turnRate: 4.2,
  idlePenalty: 0.0004,
  wrongPenalty: 1.0,
  correctReward: 1.0,
  driftPenalty: 0.0002,
  progressReward: 0.8,
  regressPenalty: 1.2,
  fastDeliveryBonus: 1.1,
  priorityRewardScale: 0.35,
  priorityPenaltyScale: 0.4,
  adaptiveLoad: true,
};

const learn = {
  hidden: 16,
  mut: 0.16,
  elite: 0.20,
  mutStrengthW: 0.20,
  mutStrengthB: 0.20,
  crossoverBias: 0.50,
  tournamentFactor: 2.0,
  fresh: 0,
  auto: true,
};

function bindRange(sliderId, labelId, fmt=(v)=>v){
  const slider = Q(sliderId);
  const label = Q(labelId);
  if(!slider || !label) return;
  const apply = ()=>{
    label.textContent = fmt(+slider.value);
    readParams();
    readLearnParams();
  };
  slider.addEventListener('input', apply);
  apply();
}

function readParams(){
  const ticketSlider = Q('slTickets');
  const spawnSlider = Q('slSpawn');
  const speedSlider = Q('slSimSpeed');
  const tailSlider = Q('slTail');
  const scaleSlider = Q('slAgentScale');
  const popSlider = Q('slPopulation');
  const popInput = Q('numPopulation');
  const collideToggle = Q('chkAgentCollisions');
  const topToggle = Q('chkTopHighlight');
  const obstSlider = Q('slObst');
  const scatterSlider = Q('slScatter');
  const adaptiveToggle = Q('chkAdaptiveLoad');
  params.maxTickets = ticketSlider ? +ticketSlider.value : params.maxTickets;
  params.spawnMs = spawnSlider ? +spawnSlider.value : params.spawnMs;
  params.simSpeed = speedSlider ? (+speedSlider.value / 100) : params.simSpeed;
  params.tailLen = tailSlider ? +tailSlider.value : params.tailLen;
  params.agentScale = scaleSlider ? (+scaleSlider.value / 100) : params.agentScale;
  const popVal = popSlider ? +popSlider.value : params.populationSize;
  params.populationSize = popVal;
  if(popInput && popInput.value !== String(popVal)) popInput.value = popVal;
  params.agentCollisions = collideToggle ? collideToggle.checked : params.agentCollisions;
  params.topHighlight = topToggle ? topToggle.checked : params.topHighlight;
  params.maxObstacles = obstSlider ? +obstSlider.value : params.maxObstacles;
  params.ticketScatter = scatterSlider ? +scatterSlider.value : params.ticketScatter;
  params.adaptiveLoad = adaptiveToggle ? adaptiveToggle.checked : params.adaptiveLoad;
  refreshAutoObstacles();
}

function readLearnParams(){
  const stepSlider = Q('slGenSteps');
  const hiddenSlider = Q('slHidden');
  const mutSlider = Q('slMut');
  const eliteSlider = Q('slElite');
  const mutW = Q('slMutStrengthW');
  const mutB = Q('slMutStrengthB');
  const cross = Q('slCrossover');
  const tour = Q('slTournament');
  const fresh = Q('slFresh');
  const auto = Q('chkAuto');
  learn.hidden = hiddenSlider ? +hiddenSlider.value : learn.hidden;
  learn.mut = mutSlider ? (+mutSlider.value/100) : learn.mut;
  learn.elite = eliteSlider ? (+eliteSlider.value/100) : learn.elite;
  learn.mutStrengthW = mutW ? (+mutW.value/100) : learn.mutStrengthW;
  learn.mutStrengthB = mutB ? (+mutB.value/100) : learn.mutStrengthB;
  learn.crossoverBias = cross ? (+cross.value/100) : learn.crossoverBias;
  learn.tournamentFactor = tour ? (+tour.value/10) : learn.tournamentFactor;
  learn.fresh = fresh ? (+fresh.value/100) : learn.fresh;
  learn.auto = auto ? auto.checked : learn.auto;
  params.generationSteps = stepSlider ? +stepSlider.value : params.generationSteps;
}

function bindToggle(toggleId, labelId, onText='on', offText='off'){
  const el = Q(toggleId);
  const label = Q(labelId);
  if(!el || !label) return;
  const apply = ()=>{
    label.textContent = el.checked ? onText : offText;
    readParams();
    readLearnParams();
  };
  el.addEventListener('change', apply);
  apply();
}

function readTicketPlacements(){
  const boxes = document.querySelectorAll('input[name="ticketPlacement"]');
  const active = Array.from(boxes).filter(b=>b.checked).map(b=>b.value);
  return active.length ? active : ['random'];
}

function syncPlacementButtons(){
  document.querySelectorAll('.ticket-placement-option input').forEach(box=>{
    box.parentElement.classList.toggle('active', box.checked);
  });
}

function setPlacementSelection(values){
  document.querySelectorAll('input[name="ticketPlacement"]').forEach(box=>{
    box.checked = values.includes(box.value);
  });
  syncPlacementButtons();
}

const INPUT_COUNT = 30;
const OUTPUT_COUNT = 2;

class Genome {
  constructor(){
    this.inputSize = INPUT_COUNT;
    this.hiddenSize = learn.hidden;
    this.outputSize = OUTPUT_COUNT; // turn, thrust
    this.weights1 = Array.from({length: this.inputSize * this.hiddenSize}, () => Math.random()*2 - 1);
    this.weights2 = Array.from({length: this.hiddenSize * this.outputSize}, () => Math.random()*2 - 1);
    this.biasH = Array.from({length:this.hiddenSize}, ()=> Math.random()*0.4-0.2);
    this.biasO = Array.from({length:this.outputSize}, ()=> Math.random()*0.4-0.2);
    this.fitness = 0;
  }
  activate(inputs){
    const hidden = new Array(this.hiddenSize);
    let w = 0;
    for(let h=0; h<this.hiddenSize; h++){
      let sum = this.biasH[h];
      for(let i=0; i<this.inputSize; i++) sum += inputs[i] * this.weights1[w++];
      hidden[h] = Math.tanh(sum);
    }
    const outputs = [];
    w = 0;
    for(let o=0; o<this.outputSize; o++){
      let sum = this.biasO[o];
      for(let h=0; h<this.hiddenSize; h++) sum += hidden[h] * this.weights2[w++];
      outputs.push(Math.tanh(sum));
    }
    return outputs;
  }
  mutate(rate){
    const mutateArray = (arr, strength)=>{
      for(let i=0;i<arr.length;i++){
        if(Math.random() < rate){
          if(Math.random() < learn.mut*0.5){
            arr[i] = Math.random()*2 - 1;
          } else {
            arr[i] += (Math.random()-0.5) * strength * 2;
            arr[i] = Math.max(-2.5, Math.min(2.5, arr[i]));
          }
        }
      }
    };
    mutateArray(this.weights1, learn.mutStrengthW);
    mutateArray(this.weights2, learn.mutStrengthW);
    mutateArray(this.biasH, learn.mutStrengthB);
    mutateArray(this.biasO, learn.mutStrengthB);
  }
  crossover(other){
    const child = new Genome();
    for(let i=0;i<this.weights1.length;i++) child.weights1[i] = Math.random() < learn.crossoverBias ? this.weights1[i] : other.weights1[i];
    for(let i=0;i<this.weights2.length;i++) child.weights2[i] = Math.random() < learn.crossoverBias ? this.weights2[i] : other.weights2[i];
    for(let i=0;i<this.biasH.length;i++) child.biasH[i] = Math.random() < learn.crossoverBias ? this.biasH[i] : other.biasH[i];
    for(let i=0;i<this.biasO.length;i++) child.biasO[i] = Math.random() < learn.crossoverBias ? this.biasO[i] : other.biasO[i];
    return child;
  }
}

function cloneGenome(src){
  const g = new Genome();
  g.weights1 = Array.from(src.weights1 || g.weights1);
  g.weights2 = Array.from(src.weights2 || g.weights2);
  g.biasH = Array.from(src.biasH || g.biasH);
  g.biasO = Array.from(src.biasO || g.biasO);
  g.fitness = src.fitness || 0;
  return g;
}

function hydrateGenome(raw){
  const template = new Genome();
  const g = new Genome();
  g.weights1 = Array.isArray(raw?.weights1) && raw.weights1.length === template.weights1.length ? Array.from(raw.weights1) : g.weights1;
  g.weights2 = Array.isArray(raw?.weights2) && raw.weights2.length === template.weights2.length ? Array.from(raw.weights2) : g.weights2;
  g.biasH = Array.isArray(raw?.biasH) && raw.biasH.length === template.biasH.length ? Array.from(raw.biasH) : g.biasH;
  g.biasO = Array.isArray(raw?.biasO) && raw.biasO.length === template.biasO.length ? Array.from(raw.biasO) : g.biasO;
  g.fitness = typeof raw?.fitness === 'number' ? raw.fitness : 0;
  return g;
}

class Population {
  constructor(size){
    this.genomes = Array.from({length:size}, ()=> new Genome());
    this.generation = 1;
    this.bestFitness = 0;
    this.champion = null;
  }
  evolve(){
    this.genomes.sort((a,b)=> b.fitness - a.fitness);
    this.bestFitness = Math.max(this.bestFitness, this.genomes[0].fitness);
    if(!this.champion || this.genomes[0].fitness > this.champion.fitness){
      this.champion = cloneGenome(this.genomes[0]);
    }
    const eliteCount = Math.max(1, Math.floor(this.genomes.length * learn.elite));
    const freshCount = Math.max(0, Math.floor(this.genomes.length * learn.fresh));
    const next = this.genomes.slice(0, eliteCount).map(g=>g);
    const target = this.genomes.length;
    while(next.length < target - freshCount){
      const p1 = this.selectParent();
      const p2 = this.selectParent();
      const child = p1.crossover(p2);
      child.mutate(learn.mut);
      next.push(child);
    }
    while(next.length < target){
      next.push(new Genome());
    }
    this.genomes = next.slice(0, target);
    this.generation++;
  }
  selectParent(){
    const k = Math.max(2, Math.floor(learn.tournamentFactor));
    let best = null;
    for(let i=0;i<k;i++){
      const contender = this.genomes[Math.floor(Math.random()*this.genomes.length)];
      if(!best || contender.fitness > best.fitness) best = contender;
    }
    return best || this.genomes[0];
  }
}

class Ticket {
  constructor(type, x, y, priority=1){
    this.type = type;
    this.x = x;
    this.y = y;
    this.priority = priority;
  }
}

class SortingAgent {
  constructor(genome){
    this.genome = genome;
    this.hue = Math.floor(Math.random()*220 + 80);
    this.color = `hsl(${this.hue},72%,74%)`;
    this.reset();
  }
  reset(){
    this.x = nest.x + (rand()*2-1) * nest.r * 0.45;
    this.y = nest.y + (rand()*2-1) * nest.r * 0.35;
    this.vx = 0;
    this.vy = 0;
    this.angle = Math.PI/2 + (rand()*0.6 - 0.3);
    this.carrying = null;
    this.carryTime = 0;
    this.goalDistancePrev = null;
    this.fitness = 0;
    this.tail = Array.from({length: Math.max(4, Math.floor(params.tailLen/6))}, ()=>({x:this.x, y:this.y}));
    this.tailTimer = 0;
    this.pickupFlash = 0;
    this.deliveryFlash = 0;
    this.lastTicketType = null;
  }
  think(tickets, obstacles, teammates){
    // 1) Perception of the nearest ticket (vector), its type one-hot, and priority level
    let target = null;
    let distToTicket = Infinity;
    for(const t of tickets){
      const dx = t.x - this.x;
      const dy = t.y - this.y;
      const d = Math.hypot(dx, dy);
      if(d < distToTicket){ distToTicket = d; target = t; }
    }
    const inputs = [];
    if(target){
      inputs.push((target.x - this.x)/W);
      inputs.push((target.y - this.y)/H);
      const typeIndex = categories.findIndex(c=> c.id===target.type);
      categories.forEach((cat, idx)=> inputs.push(idx===typeIndex ? 1 : 0));
      inputs.push(target.priority/3);
    } else {
      inputs.push(0,0);
      inputs.push(0,0,0);
      inputs.push(0);
    }

    // 2) Zone direction vectors and radial distances to each delivery circle
    for(const cat of categories){
      const dx = cat.zone.x - this.x;
      const dy = cat.zone.y - this.y;
      inputs.push(dx/W);
      inputs.push(dy/H);
      inputs.push(Math.min(1, Math.hypot(dx, dy) / diag));
    }

    // 3) Carry-state flags and progress awareness
    const carryingFlags = categories.map(cat=> this.carrying?.type === cat.id ? 1 : 0);
    inputs.push(...carryingFlags);

    // 4) Separation / avoidance vs teammates
    let sepX = 0, sepY = 0;
    for(const mate of teammates){
      if(mate === this) continue;
      const dx = this.x - mate.x;
      const dy = this.y - mate.y;
      const d2 = dx*dx + dy*dy;
      if(d2 < 1) continue;
      if(d2 < 900){
        const inv = 1/Math.sqrt(d2);
        sepX += dx * inv;
        sepY += dy * inv;
      }
    }

    // 5) Velocity, obstacle force (vector + magnitude), nest pull, timers, and backlog pressure
    const obs = obstacleForce(this, obstacles);
    const obsMag = Math.min(1, Math.hypot(obs.x, obs.y));
    const goalZone = this.carrying ? categories.find(c=> c.id===this.carrying.type)?.zone : null;
    const goalDist = goalZone ? Math.min(1, Math.hypot(goalZone.x - this.x, goalZone.y - this.y)/diag) : 0;
    inputs.push(this.vx/params.maxSpeed);
    inputs.push(this.vy/params.maxSpeed);
    inputs.push(sepX*0.01);
    inputs.push(sepY*0.01);
    inputs.push(obs.x);
    inputs.push(obs.y);
    inputs.push(obsMag);
    inputs.push((nest.x - this.x)/W);
    inputs.push((nest.y - this.y)/H);
    inputs.push(Math.min(1, this.carryTime/8));
    inputs.push(Math.min(1, tickets.length / Math.max(1, params.maxTickets)));
    inputs.push(goalDist);
    return this.genome.activate(inputs);
  }
  update(dt, tickets, obstacles, teammates){
    const goalZone = this.carrying ? categories.find(c=> c.id===this.carrying.type)?.zone : null;
    const prevGoalDist = goalZone ? Math.hypot(goalZone.x - this.x, goalZone.y - this.y) : null;
    // Brain outputs steering (turn) and thrust
    const [turn, thrustRaw] = this.think(tickets, obstacles, teammates);
    const thrust = (thrustRaw+1)/2;
    this.angle += turn * params.turnRate * dt;
    const obsVec = obstacleForce(this, obstacles);
    // Physics integration with obstacle deflection baked in
    this.vx += (Math.cos(this.angle) * thrust * params.accel + 18*obsVec.x) * dt;
    this.vy += (Math.sin(this.angle) * thrust * params.accel + 18*obsVec.y) * dt;
    const speed = Math.hypot(this.vx, this.vy);
    if(speed > params.maxSpeed){
      const scale = params.maxSpeed / speed;
      this.vx *= scale; this.vy *= scale;
    }
    // Soft collision separation
    if(params.agentCollisions){
      for(const mate of teammates){
        if(mate === this) continue;
        const dx = this.x - mate.x;
        const dy = this.y - mate.y;
        const dist = Math.hypot(dx, dy);
        const minD = 10 * params.agentScale;
        if(dist > 0 && dist < minD){
          const push = (minD - dist) * 0.6;
          this.vx += (dx/dist) * push;
          this.vy += (dy/dist) * push;
        }
      }
    }
    this.x += this.vx * dt;
    this.y += this.vy * dt;
    if(this.x < 6 || this.x > W-6){ this.vx *= -0.8; this.x = Math.max(6, Math.min(W-6, this.x)); }
    if(this.y < 6 || this.y > H-6){ this.vy *= -0.8; this.y = Math.max(6, Math.min(H-6, this.y)); }

    const newGoalDist = goalZone ? Math.hypot(goalZone.x - this.x, goalZone.y - this.y) : null;
    const progress = goalZone ? ((prevGoalDist ?? newGoalDist) - newGoalDist) / diag : 0;
    if(this.carrying){
      this.carryTime += dt;
      // Shaping reward when moving toward the correct zone, penalty when drifting away
      if(progress > 0){
        this.fitness += params.progressReward * progress;
      } else if(progress < 0){
        this.fitness -= params.regressPenalty * Math.abs(progress);
      }
      // Idle penalty that scales up when orbiting or backtracking
      const idleScale = progress > 0.002 ? 0 : Math.min(3.2, Math.abs(progress)*40 + (progress < 0 ? 1.4 : 1));
      this.fitness -= params.idlePenalty * idleScale * dt;
    }

    // Small drift penalty every step, scaled by whether movement is helpful
    const driftScale = this.carrying ? (progress >= 0 ? 0.6 : 1.4) : 1;
    this.fitness -= params.driftPenalty * driftScale * dt;
    this.goalDistancePrev = goalZone ? newGoalDist : null;

    this.tailTimer += dt;
    if(this.tailTimer > 0.01){
      this.tail.push({x:this.x, y:this.y});
      while(this.tail.length > params.tailLen){ this.tail.shift(); }
      this.tailTimer = 0;
    }
    this.pickupFlash = Math.max(0, this.pickupFlash - dt*0.8);
    this.deliveryFlash = Math.max(0, this.deliveryFlash - dt*0.9);
  }
}

let population = new Population(params.populationSize);
let agents = [];
let tickets = [];
let spawnTimer = 0;
let generationTimer = 0;
let correctSorted = 0;
let wrongSorted = 0;
let bestFitness = 0;
let lastGenStats = {best:0, avg:0, acc:0};
let manualObstacles = [];
let currentTool = 'select';
let drawingState = null;
let stepCounter = 0;

const canvasRect = ()=> canvas.getBoundingClientRect();
function pointerPos(evt){
  const r = canvasRect();
  const scaleX = canvas.width / r.width;
  const scaleY = canvas.height / r.height;
  return { x:(evt.clientX - r.left)*scaleX, y:(evt.clientY - r.top)*scaleY };
}

function hitLayoutTarget(pos){
  for(const cat of categories){
    const d = Math.hypot(pos.x - cat.zone.x, pos.y - cat.zone.y);
    if(d < Math.max(18, cat.zone.r*0.22)+6) return {type:'category', ref:cat.zone};
  }
  const dNest = Math.hypot(pos.x - nest.x, pos.y - nest.y);
  if(dNest < Math.max(18, nest.r*0.22)+6) return {type:'nest', ref:nest};
  return null;
}

function clampLayoutPosition(val, min=24, max=W-24){
  return Math.min(max, Math.max(min, val));
}

function pushFeed(label, message, tone='tone-good'){
  liveFeed.unshift({label, message, tone, ts: performance.now()});
  while(liveFeed.length > 8) liveFeed.pop();
  renderFeed();
}

function renderFeed(){
  const box = Q('eventFeed');
  if(!box) return;
  if(!liveFeed.length){
    box.innerHTML = '<div class="feed-item"><span class="feed-pill">Calm</span><span class="tone-good">Waiting for the first pickup…</span></div>';
    return;
  }
  box.innerHTML = liveFeed.map(evt=>
    `<div class="feed-item"><span class="feed-pill">${evt.label}</span><span class="${evt.tone}">${evt.message}</span></div>`
  ).join('');
}

function renderChips(ticketCounts){
  const chipLine = Q('chipLine');
  if(!chipLine) return;
  chipLine.innerHTML = categories.map(cat=>{
    const open = ticketCounts[cat.id] ?? 0;
    const delivered = deliveredByType[cat.id] ?? 0;
    const classList = open > 2 ? 'chip heat' : open === 0 ? 'chip low' : 'chip';
    return `<span class="${classList}" style="border-color:${cat.color}66"><span class="dot" style="background:${cat.color}"></span>${cat.label}: ${open} open • ${delivered} delivered</span>`;
  }).join('');
}

canvas.addEventListener('mousemove', (e)=>{
  if(!layoutState.active) return;
  const pos = pointerPos(e);
  const snap = layoutState.snap ? layoutState.gridSize : 1;
  layoutState.active.target.x = clampLayoutPosition(Math.round((pos.x - layoutState.active.offsetX)/snap)*snap);
  layoutState.active.target.y = clampLayoutPosition(Math.round((pos.y - layoutState.active.offsetY)/snap)*snap, 24, H-24);
  updateLayoutReadout();
});

function setTool(tool){
  currentTool = tool;
  document.querySelectorAll('.tool-btn').forEach(btn=>{
    const active = btn.dataset.tool === tool;
    btn.classList.toggle('active', active);
    btn.setAttribute('aria-pressed', active);
  });
}

function obstacleForce(agent, obstacles){
  let fx = 0, fy = 0;
  for(const ob of obstacles){
    let dx = 0, dy = 0, dist = 0;
    if(ob.type === 'circle'){
      dx = agent.x - ob.x; dy = agent.y - ob.y; dist = Math.hypot(dx, dy) - ob.r;
    } else if(ob.type === 'rect'){
      const cx = Math.min(Math.max(agent.x, ob.x), ob.x+ob.w);
      const cy = Math.min(Math.max(agent.y, ob.y), ob.y+ob.h);
      dx = agent.x - cx; dy = agent.y - cy; dist = Math.hypot(dx, dy) - 6;
    } else if(ob.type === 'line'){
      const vx = ob.x2 - ob.x1; const vy = ob.y2 - ob.y1;
      const len2 = vx*vx + vy*vy || 1;
      const t = Math.max(0, Math.min(1, ((agent.x - ob.x1)*vx + (agent.y - ob.y1)*vy)/len2));
      const cx = ob.x1 + t*vx; const cy = ob.y1 + t*vy;
      dx = agent.x - cx; dy = agent.y - cy; dist = Math.hypot(dx, dy) - 8;
    } else if(ob.type === 'half'){
      dx = agent.x - ob.x; dy = agent.y - ob.y; const ang = Math.atan2(dy, dx);
      const diff = Math.abs(((ang - ob.angle + Math.PI) % (Math.PI*2)) - Math.PI);
      if(diff < Math.PI/2){
        dist = Math.hypot(dx, dy) - ob.r;
      } else {
        continue;
      }
    }
    if(dist < 28){
      const inv = Math.max(0.0001, (28 - dist))/28;
      const mag = inv*inv;
      fx += (dx||0) * mag * 0.04;
      fy += (dy||0) * mag * 0.04;
    }
  }
  return {x:fx, y:fy};
}

function refreshAutoObstacles(){
  manualObstacles = manualObstacles.filter(o=>!o.auto);
  for(let i=manualObstacles.length; i<params.maxObstacles; i++){
    manualObstacles.push({
      type:'circle',
      x: Math.random()*W*0.8 + W*0.1,
      y: Math.random()*H*0.7 + H*0.2,
      r: 24 + Math.random()*30,
      auto:true
    });
  }
}

function resetLayout(){
  Object.assign(nest, {...defaultLayout.nest});
  categories.forEach((c,i)=> Object.assign(c.zone, {...defaultLayout.categories[i].zone}));
  updateLayoutReadout();
}

function randomizeLayout(){
  const margin = 90;
  categories.forEach(cat=>{
    cat.zone.x = Math.random()*(W - margin*2)+margin;
    cat.zone.y = Math.random()*(H - margin*2)+margin;
  });
  nest.x = W/2 + (Math.random()*2-1)*80;
  nest.y = H*0.15 + Math.random()*90;
  updateLayoutReadout();
}

function fanLayout(){
  const radius = Math.min(W,H)*0.32;
  const centerX = W/2;
  const centerY = H*0.45;
  categories.forEach((cat, i)=>{
    const ang = (-0.9 + i*0.9) * Math.PI;
    cat.zone.x = centerX + Math.cos(ang)*radius;
    cat.zone.y = centerY + Math.sin(ang)*radius;
  });
  nest.x = centerX;
  nest.y = H*0.18;
  updateLayoutReadout();
}

function applyLayoutRadii(){
  const targetSlider = Q('slTargetR');
  if(targetSlider) categories.forEach(cat=> cat.zone.r = +targetSlider.value);
  const nestSlider = Q('slNestR');
  if(nestSlider) nest.r = +nestSlider.value;
}

function placementPool(){
  if(placementPreset === 'incidentStorm') return ['nw','ne','center'];
  if(placementPreset === 'serviceFriday') return ['sw','se','center'];
  const chosen = readTicketPlacements();
  return chosen.length ? chosen : ['random'];
}

// Adaptive backlog-aware spawn interval
function computeSpawnMs(){
  if(!params.adaptiveLoad) return params.spawnMs;
  const backlogRatio = tickets.length / Math.max(1, params.maxTickets);
  const total = correctSorted + wrongSorted;
  const accuracy = total ? correctSorted / total : 0.75;
  let factor = 1;
  if(backlogRatio < 0.25 && accuracy > 0.65) factor *= 0.7;
  if(backlogRatio < 0.1 && accuracy > 0.8) factor *= 0.6;
  if(backlogRatio > 0.6 && accuracy < 0.55) factor *= 1.4;
  if(backlogRatio > 0.8 && accuracy < 0.45) factor *= 1.6;
  return params.spawnMs * Math.min(2.5, Math.max(0.4, factor));
}

function applyScenarioPreset(preset){
  Object.keys(ticketTypeWeights).forEach(k=> ticketTypeWeights[k] = 1);
  let placements = ['random'];
  if(preset === 'incidentStorm'){
    ticketTypeWeights.incident = 2.4;
    ticketTypeWeights.service = 0.7;
    ticketTypeWeights.problem = 1.1;
    placementPreset = 'incidentStorm';
    placements = ['nw','ne','center'];
    pushFeed('Preset', 'Incident storm: north-heavy urgent tickets.', 'tone-warn');
  } else if(preset === 'serviceFriday'){
    ticketTypeWeights.service = 2.4;
    ticketTypeWeights.problem = 1.1;
    ticketTypeWeights.incident = 0.7;
    placementPreset = 'serviceFriday';
    placements = ['sw','se','center'];
    pushFeed('Preset', 'Service Friday: requests spread low on the map.', 'tone-good');
  } else {
    placementPreset = 'balanced';
    placements = ['random','center','sw','se','nw','ne'];
    pushFeed('Preset', 'Balanced queues with even ticket mix.', 'tone-good');
  }
  setPlacementSelection(placements);
}

function spawnTicket(){
  if(tickets.length >= params.maxTickets) return;
  const type = pickTicketType();
  const spots = placementPool();
  const pick = spots[Math.floor(rand()*spots.length)];
  const padding = Math.max(20, params.ticketScatter);
  let x = rand() * (W - padding*2) + padding;
  let y = rand() * (H - padding*2) + padding;
  if(pick === 'center'){ x = W*0.5 + (rand()*2-1)*80; y = H*0.5 + (rand()*2-1)*60; }
  if(pick === 'nw'){ x = padding + rand()*W*0.28; y = padding + rand()*H*0.28; }
  if(pick === 'ne'){ x = W*0.72 + rand()*W*0.28 - padding; y = padding + rand()*H*0.28; }
  if(pick === 'sw'){ x = padding + rand()*W*0.28; y = H*0.72 + rand()*H*0.2 - padding; }
  if(pick === 'se'){ x = W*0.72 + rand()*W*0.28 - padding; y = H*0.72 + rand()*H*0.2 - padding; }
  // Priority spice: higher numbers glow more and reward/penalize fitness harder
  const priority = 1 + Math.floor(rand()*3);
  tickets.push(new Ticket(type, x, y, priority));
}

function resetGeneration(){
  applyLayoutRadii();
  replayMode = false;
  resetReplaySeed();
  tickets = [];
  agents = population.genomes.map(g=> new SortingAgent(g));
  spawnTimer = 0;
  generationTimer = 0;
  correctSorted = 0;
  wrongSorted = 0;
  bestFitness = population.bestFitness;
  stepCounter = 0;
  refreshAutoObstacles();
  for(let i=0;i<Math.min(params.maxTickets, 10); i++) spawnTicket();
  Object.keys(pickupByType).forEach(k=> pickupByType[k] = 0);
  Object.keys(deliveredByType).forEach(k=> deliveredByType[k] = 0);
  liveFeed.length = 0;
  renderFeed();
}

function recordGenerationStats(){
  if(replayMode) return;
  const fitnesses = agents.map(a=> a.fitness);
  const best = fitnesses.length ? Math.max(...fitnesses) : 0;
  const avg = fitnesses.length ? fitnesses.reduce((s,f)=> s+f,0)/fitnesses.length : 0;
  const total = correctSorted + wrongSorted;
  const acc = total ? correctSorted/total : 0;
  lastGenStats = {best, avg, acc};
  // Append compact telemetry for lightweight DOM history rendering
  generationHistory.push({gen: population.generation, best, avg, acc});
  while(generationHistory.length > 30) generationHistory.shift();
}

function commitGenerationFitness(){
  for(let i=0;i<population.genomes.length;i++){
    population.genomes[i].fitness = agents[i]?.fitness ?? population.genomes[i].fitness;
  }
  recordGenerationStats();
}

function startChampionReplay(){
  if(!population.champion){
    pushFeed('Replay', 'Train a champion before replaying.', 'tone-warn');
    return;
  }
  replayMode = true;
  resetReplaySeed();
  placementPreset = 'balanced';
  setPlacementSelection(['random','center']);
  resetLayout();
  applyLayoutRadii();
  updateLayoutReadout();
  manualObstacles = [];
  tickets = [];
  const champ = cloneGenome(population.champion);
  agents = [new SortingAgent(champ)];
  const a = agents[0];
  a.x = nest.x; a.y = nest.y; a.vx = 0; a.vy = 0; a.angle = Math.PI/2;
  spawnTimer = 0;
  generationTimer = 0;
  correctSorted = 0; wrongSorted = 0; stepCounter = 0;
  const starter = [
    new Ticket('incident', W*0.2, H*0.18, 3),
    new Ticket('service', W*0.55, H*0.72, 2),
    new Ticket('problem', W*0.8, H*0.32, 1)
  ];
  starter.forEach(t=> tickets.push(t));
  liveFeed.length = 0;
  renderFeed();
  pushFeed('Replay', 'Champion dropped into a fixed arena — watch the routing!', 'tone-good');
}

function deliver(agent, zoneCat){
  if(!agent.carrying) return;
  const priority = agent.carrying?.priority || 1;
  const priorityBoost = 1 + (priority-1) * params.priorityRewardScale;
  if(agent.carrying.type === zoneCat.id){
    const speedFactor = 1 + params.fastDeliveryBonus / Math.max(0.6, agent.carryTime + 0.001);
    const reward = params.correctReward * priorityBoost * speedFactor;
    agent.fitness += reward;
    correctSorted++;
    deliveredByType[zoneCat.id] = (deliveredByType[zoneCat.id]||0)+1;
    agent.deliveryFlash = 1.1;
    pushFeed(zoneCat.label, `Priority ${priority} in ${agent.carryTime.toFixed(1)}s — fitness +${reward.toFixed(2)}`, 'tone-good');
  } else {
    const penalty = params.wrongPenalty * (1 + (priority-1) * params.priorityPenaltyScale);
    agent.fitness -= penalty;
    wrongSorted++;
    pushFeed('Oops', `Misrouted ${agent.carrying.type} (P${priority}) to ${zoneCat.label} — penalty ${penalty.toFixed(1)}`, 'tone-bad');
  }
  agent.carrying = null;
  agent.carryTime = 0;
  agent.goalDistancePrev = null;
}

function tryPickup(agent){
  if(agent.carrying) return;
  let targetIndex = -1;
  let closest = 12;
  for(let i=0;i<tickets.length;i++){
    const t = tickets[i];
    const d = Math.hypot(t.x-agent.x, t.y-agent.y);
    if(d < closest){ closest = d; targetIndex = i; }
  }
  if(targetIndex >= 0){
    const t = tickets.splice(targetIndex,1)[0];
    agent.carrying = {type:t.type, priority:t.priority};
    agent.carryTime = 0;
    const goalZone = categories.find(c=> c.id===t.type)?.zone;
    agent.goalDistancePrev = goalZone ? Math.hypot(goalZone.x - agent.x, goalZone.y - agent.y) : null;
    agent.pickupFlash = 1.2;
    agent.lastTicketType = t.type;
    pickupByType[t.type] = (pickupByType[t.type]||0)+1;
    const cat = categories.find(c=> c.id===t.type);
    pushFeed('Pickup', `${cat?.label || 'Ticket'} locked — sprint to ${cat?.label || 'zone'}`, 'tone-warn');
  }
}

function drawTicket(t){
  const cat = categories.find(c=>c.id===t.type);
  const color = cat?.color || '#e2e8f0';
  ctx.save();
  ctx.translate(t.x, t.y);
  ctx.rotate(-0.1);
  ctx.fillStyle = 'rgba(15,23,42,0.9)';
  ctx.strokeStyle = color;
  ctx.lineWidth = 1.8 + t.priority*0.6;
  ctx.shadowColor = color;
  ctx.shadowBlur = 4 + t.priority*4;
  ctx.beginPath();
  ctx.moveTo(-9,-12);
  ctx.lineTo(9,-12);
  ctx.lineTo(12,-8);
  ctx.lineTo(12,12);
  ctx.lineTo(-9,12);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(9,-12);
  ctx.lineTo(9,-6);
  ctx.lineTo(12,-8);
  ctx.closePath();
  ctx.fillStyle = color;
  ctx.fill();
  ctx.stroke();
  ctx.fillStyle = '#e2e8f0';
  ctx.font = '10px Inter, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(cat?.label?.[0] || '?', 0, 3);
  ctx.fillStyle = '#cbd5e1';
  ctx.font = '8px Inter, sans-serif';
  ctx.fillText(`P${t.priority}`, 0, 12);
  ctx.restore();
}

function drawObstacle(ob){
  ctx.save();
  ctx.globalAlpha = 0.85;
  ctx.strokeStyle = 'rgba(148,163,209,0.75)';
  ctx.fillStyle = 'rgba(56,189,248,0.12)';
  ctx.lineWidth = 2;
  if(ob.type === 'circle'){
    ctx.beginPath(); ctx.arc(ob.x, ob.y, ob.r, 0, Math.PI*2); ctx.fill(); ctx.stroke();
  } else if(ob.type === 'rect'){
    ctx.beginPath(); ctx.rect(ob.x, ob.y, ob.w, ob.h); ctx.fill(); ctx.stroke();
  } else if(ob.type === 'line'){
    ctx.beginPath(); ctx.moveTo(ob.x1, ob.y1); ctx.lineTo(ob.x2, ob.y2); ctx.stroke();
  } else if(ob.type === 'half'){
    ctx.beginPath();
    ctx.arc(ob.x, ob.y, ob.r, ob.angle - Math.PI/2, ob.angle + Math.PI/2);
    ctx.fill(); ctx.stroke();
  }
  ctx.restore();
}

function drawAgent(agent, highlight=false){
  const size = 10 * params.agentScale;
  const tailColor = agent.carrying ? '#facc15' : agent.color;
  ctx.save();
  if(agent.pickupFlash > 0 || agent.deliveryFlash > 0){
    const halo = ctx.createRadialGradient(agent.x, agent.y, 2, agent.x, agent.y, 80 * (1+agent.deliveryFlash));
    const alpha = Math.min(0.8, (agent.pickupFlash + agent.deliveryFlash)*0.6);
    halo.addColorStop(0, `rgba(56,189,248,${alpha})`);
    halo.addColorStop(1, `rgba(15,23,42,0)`);
    ctx.fillStyle = halo;
    ctx.beginPath();
    ctx.arc(agent.x, agent.y, 80 * (1+agent.deliveryFlash*0.6), 0, Math.PI*2);
    ctx.fill();
  }
  ctx.lineWidth = 3;
  ctx.strokeStyle = 'rgba(56,189,248,0.4)';
  ctx.beginPath();
  const tail = agent.tail;
  if(tail && tail.length){
    ctx.moveTo(tail[0].x, tail[0].y);
    for(let i=1;i<tail.length;i++) ctx.lineTo(tail[i].x, tail[i].y);
    const grad = ctx.createLinearGradient(tail[0].x, tail[0].y, agent.x, agent.y);
    grad.addColorStop(0,'rgba(56,189,248,0.1)');
    const tailStopColor = tailColor.startsWith('hsl')
      ? tailColor.replace('hsl','hsla').replace(')',',0.33)')
      : `${tailColor}55`;
    grad.addColorStop(1, tailStopColor);
    ctx.strokeStyle = grad;
    ctx.lineWidth = params.agentScale * 3;
    ctx.stroke();
  }
  ctx.restore();

  ctx.save();
  ctx.translate(agent.x, agent.y);
  ctx.rotate(agent.angle);
  const bodyColor = agent.carrying ? '#facc15' : '#c4d4ff';
  ctx.fillStyle = bodyColor;
  ctx.strokeStyle = highlight && params.topHighlight ? '#f472b6' : '#0f172a';
  ctx.lineWidth = highlight ? 2.5 : 1.5;
  ctx.beginPath();
  ctx.moveTo(size,0);
  ctx.lineTo(-size*0.8, size*0.7);
  ctx.lineTo(-size*0.8, -size*0.7);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  if(agent.carrying){
    ctx.save();
    ctx.translate(size*0.2,0);
    ctx.rotate(0.25);
    ctx.fillStyle = '#0f172a';
    ctx.strokeStyle = '#facc15';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.rect(-6,-6,12,12);
    ctx.fill(); ctx.stroke();
    ctx.fillStyle = '#facc15';
    ctx.font = '9px Inter, sans-serif';
    ctx.textAlign = 'center';
    const carryLabel = agent.carrying.type?.[0]?.toUpperCase() || '?';
    ctx.fillText(carryLabel, 0, 2);
    ctx.fillStyle = '#cbd5e1';
    ctx.font = '7px Inter, sans-serif';
    ctx.fillText(`P${agent.carrying.priority||1}`, 0, 9);
    ctx.restore();
  }
  ctx.restore();
}

function update(dt){
  if(population.genomes.length !== params.populationSize){
    population = new Population(params.populationSize);
    resetGeneration();
  }

  spawnTimer += dt*1000;
  const targetSpawn = computeSpawnMs();
  if(spawnTimer >= targetSpawn){
    spawnTicket();
    spawnTimer = 0;
  }
  for(const agent of agents){
    agent.update(dt, tickets, manualObstacles, agents);
    tryPickup(agent);
    for(const cat of categories){
      const zone = cat.zone;
      const d = Math.hypot(zone.x - agent.x, zone.y - agent.y);
      if(d < zone.r && agent.carrying){
        deliver(agent, cat);
      }
    }
  }
  stepCounter += dt*60;
  if(stepCounter >= params.generationSteps){
    if(!replayMode){
      commitGenerationFitness();
      if(learn.auto){
        population.evolve();
        resetGeneration();
      }
    }
    stepCounter = 0;
  }
}

function draw(){
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle = '#050516';
  ctx.fillRect(0,0,W,H);

  const ticketCounts = categories.reduce((acc,c)=>{acc[c.id]=0; return acc;},{});
  for(const t of tickets){ ticketCounts[t.type] = (ticketCounts[t.type]||0)+1; }
  renderChips(ticketCounts);

  if(layoutState.showGrid){
    ctx.save();
    ctx.strokeStyle = 'rgba(148,163,209,0.18)';
    ctx.lineWidth = 1;
    for(let x=0;x<=W;x+= layoutState.gridSize){
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();
    }
    for(let y=0;y<=H;y+= layoutState.gridSize){
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
    }
    ctx.restore();
  }

  // Nest
  const nestGrad = ctx.createRadialGradient(nest.x, nest.y, nest.r*0.1, nest.x, nest.y, nest.r + correctSorted*2);
  nestGrad.addColorStop(0,'rgba(248,250,252,0.32)');
  nestGrad.addColorStop(1,'rgba(59,130,246,0.12)');
  ctx.fillStyle = nestGrad;
  ctx.beginPath();
  ctx.arc(nest.x, nest.y, nest.r, 0, Math.PI*2);
  ctx.fill();
  ctx.strokeStyle = 'rgba(125,211,252,0.6)';
  ctx.lineWidth = 2;
  ctx.stroke();
  ctx.fillStyle = '#e2e8f0';
  ctx.font = '13px Inter, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Nest', nest.x, nest.y+4);

  categories.forEach(cat=>{
    const open = ticketCounts[cat.id] || 0;
    ctx.fillStyle = `${cat.color}${open>0 ? '38' : '24'}`;
    ctx.beginPath();
    ctx.arc(cat.zone.x, cat.zone.y, cat.zone.r, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = cat.color;
    ctx.lineWidth = 3 + open;
    ctx.stroke();
    ctx.fillStyle = '#e2e8f0';
    ctx.font = '14px Inter, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(`${cat.label} (${open} waiting)`, cat.zone.x, cat.zone.y+4);
  });

  manualObstacles.forEach(drawObstacle);
  tickets.forEach(drawTicket);

  let bestAgent = agents.reduce((p,c)=> c.fitness > (p?.fitness ?? -Infinity) ? c : p, null);
  if(bestAgent){
    const target = tickets.reduce((p,c)=>{
      const d = Math.hypot(c.x-bestAgent.x, c.y-bestAgent.y);
      return !p || d < p.d ? {t:c, d} : p;
    }, null);
    if(target){
      ctx.save();
      ctx.strokeStyle = '#38bdf8aa';
      ctx.setLineDash([8,6]);
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(bestAgent.x, bestAgent.y);
      ctx.lineTo(target.t.x, target.t.y);
      ctx.stroke();
      ctx.restore();
    }
    if(bestAgent.carrying){
      const zone = categories.find(c=> c.id===bestAgent.carrying.type)?.zone;
      if(zone){
        ctx.save();
        ctx.strokeStyle = '#facc15aa';
        ctx.setLineDash([4,10]);
        ctx.lineWidth = 2.5;
        ctx.beginPath();
        ctx.moveTo(bestAgent.x, bestAgent.y);
        ctx.lineTo(zone.x, zone.y);
        ctx.stroke();
        ctx.restore();
      }
    }
  }
  agents.forEach(agent=>{
    drawAgent(agent, bestAgent === agent);
  });

  drawLayoutHandles();
}

function drawLayoutHandles(){
  if(!layoutState.dragEnabled) return;
  ctx.save();
  ctx.lineWidth = 2;
  for(const cat of categories){
    ctx.strokeStyle = `${cat.color}aa`;
    ctx.fillStyle = `${cat.color}26`;
    ctx.beginPath(); ctx.arc(cat.zone.x, cat.zone.y, Math.max(18, cat.zone.r*0.22), 0, Math.PI*2); ctx.fill(); ctx.stroke();
    ctx.fillStyle = '#e2e8f0';
    ctx.font = '11px Inter, sans-serif';
    ctx.fillText(`${cat.label} (${cat.zone.x.toFixed(0)}, ${cat.zone.y.toFixed(0)})`, cat.zone.x, cat.zone.y - Math.max(18, cat.zone.r*0.22) - 6);
  }
  ctx.strokeStyle = 'rgba(59,130,246,0.9)';
  ctx.fillStyle = 'rgba(59,130,246,0.2)';
  ctx.beginPath(); ctx.arc(nest.x, nest.y, Math.max(18, nest.r*0.22), 0, Math.PI*2); ctx.fill(); ctx.stroke();
  ctx.fillStyle = '#e2e8f0';
  ctx.font = '11px Inter, sans-serif';
  ctx.fillText(`Nest (${nest.x.toFixed(0)}, ${nest.y.toFixed(0)})`, nest.x, nest.y - Math.max(18, nest.r*0.22) - 6);
  ctx.restore();
}

let last = performance.now();
function loop(now){
  const dt = Math.min(0.05, (now-last)/1000) * params.simSpeed;
  last = now;
  update(dt);
  draw();
  updateStats();
  requestAnimationFrame(loop);
}

function renderGenerationHistory(){
  const barWrap = Q('genHistoryBars');
  if(!barWrap) return;
  if(!generationHistory.length){
    barWrap.innerHTML = '<div style="font-size:11px; color:var(--muted);">Waiting for first generation…</div>';
    return;
  }
  const maxBest = generationHistory.reduce((m,g)=> Math.max(m, g.best), 1);
  barWrap.innerHTML = generationHistory.map(g=>{
    const bestH = Math.max(4, Math.min(42, (g.best/maxBest)*42));
    const avgH = Math.max(4, Math.min(42, (g.avg/maxBest)*42));
    const accH = Math.max(4, Math.min(42, g.acc*42));
    return `<div style="display:flex;flex-direction:column;gap:2px;align-items:center; width:14px;">
      <div class="gen-history-bar acc" style="height:${accH}px"></div>
      <div class="gen-history-bar avg" style="height:${avgH}px"></div>
      <div class="gen-history-bar" style="height:${bestH}px"></div>
      <span style="font-size:9px;color:var(--muted);">${g.gen}</span>
    </div>`;
  }).join('');
}

function updateStats(){
  const totalDeliveries = correctSorted + wrongSorted;
  const accuracy = totalDeliveries ? (correctSorted/totalDeliveries)*100 : null;
  const deliveryText = accuracy===null ? `${correctSorted} ✓ / ${wrongSorted} ✗` : `${correctSorted} ✓ / ${wrongSorted} ✗ (${accuracy.toFixed(1)}%)`;
  const stats = {
    gen: population.generation,
    teams: agents.length,
    tickets: tickets.length,
    deliveries: deliveryText,
    top: `${population.bestFitness.toFixed(2)} / ${lastGenStats.best.toFixed(2)}`
  };
  for(const [key,val] of Object.entries(stats)){
    const el = Q(`stat-${key}`);
    if(el) el.textContent = val;
  }
  const brainSub = Q('brain-subtitle');
  if(brainSub){
    brainSub.textContent = 'Neon hints pulse harder when more tickets pile up — follow the cyan beams to see the leader think.';
  }
  const brainTeam = Q('brain-team');
  if(brainTeam){
    const avg = agents.reduce((s,a)=> s+a.fitness,0)/Math.max(1, agents.length);
    const accText = lastGenStats.acc ? `${(lastGenStats.acc*100).toFixed(1)}%` : '—';
    brainTeam.textContent = `Best run ${population.bestFitness.toFixed(2)} • Gen best ${lastGenStats.best.toFixed(2)} • Gen avg ${lastGenStats.avg.toFixed(2)} • Acc ${accText}`;
  }
  const brainBadge = Q('brain-badge');
  if(brainBadge){
    const hottest = Object.entries(pickupByType).sort((a,b)=>b[1]-a[1])[0];
    brainBadge.textContent = hottest ? hottest[0][0].toUpperCase() : '⇄';
  }
  const brainGen = Q('brain-generation');
  if(brainGen){
    brainGen.textContent = `Generation ${population.generation}`;
  }
  updateLayoutReadout();
  renderFeed();
  renderGenerationHistory();
}

function updateLayoutReadout(){
  const box = Q('layoutReadout');
  if(!box) return;
  const cats = categories.map(c=> `${c.label}: ${c.zone.x.toFixed(0)}, ${c.zone.y.toFixed(0)} (r${c.zone.r})`).join(' • ');
  box.innerHTML = `<strong>Layout</strong> — ${cats} • Nest ${nest.x.toFixed(0)}, ${nest.y.toFixed(0)} (r${nest.r})<br>`+
    `Handles ${layoutState.dragEnabled ? 'on' : 'off'}, grid ${layoutState.showGrid ? 'on' : 'off'} @ ${layoutState.gridSize}px, `+
    `scatter ${params.ticketScatter}px, snap ${layoutState.snap ? 'on' : 'off'}.<br>`+
    `<span style="opacity:.85">Delivery streak: ${Object.entries(deliveredByType).map(([k,v])=> `${k[0].toUpperCase()}:${v}`).join(' • ')} • Pickups ${Object.values(pickupByType).reduce((s,v)=>s+v,0)}</span>`;
}

bindRange('slTickets','lbTickets',(v)=>v);
bindRange('slPopulation','lbPopulation',(v)=>v);
bindRange('slSpawn','lbSpawn',(v)=>v);
bindRange('slSimSpeed','lbSimSpeed',(v)=> (v/100).toFixed(2)+'×');
bindRange('slTail','lbTail',(v)=>v);
bindRange('slAgentScale','lbAgentScale',(v)=> (v/100).toFixed(2)+'×');
bindRange('slObst','lbObst',(v)=>v);
bindRange('slGridSize','lbGridSize',(v)=> `${v} px`);
bindRange('slNestR','lbNestR',(v)=>v);
bindRange('slTargetR','lbTargetR',(v)=>v);
bindRange('slScatter','lbScatter',(v)=>v);
bindRange('slGenSteps','lbGenSteps',(v)=>v);
bindRange('slHidden','lbHidden',(v)=> `${v} neurons`);
bindRange('slMut','lbMut',(v)=> `${v}%`);
bindRange('slElite','lbElite',(v)=> `${v}%`);
bindRange('slMutStrengthW','lbMutStrengthW',(v)=> (v/100).toFixed(2));
bindRange('slMutStrengthB','lbMutStrengthB',(v)=> (v/100).toFixed(2));
bindRange('slCrossover','lbCrossover',(v)=> `${v}% A`);
bindRange('slTournament','lbTournament',(v)=> `×${(v/10).toFixed(1)}`);
bindRange('slFresh','lbFresh',(v)=> `${v}%`);
bindToggle('chkAuto','lbAuto');
bindToggle('chkAdaptiveLoad','lbAdaptiveLoad');
bindToggle('chkAgentCollisions','lbAgentCollisions');
bindToggle('chkTopHighlight','lbTopHighlight');

document.querySelectorAll('.ticket-placement-option input').forEach(box=>{
  box.addEventListener('change', ()=>{
    syncPlacementButtons();
  });
});
syncPlacementButtons();

const btnPresetBalanced = Q('btnPresetBalanced');
const btnPresetIncident = Q('btnPresetIncident');
const btnPresetService = Q('btnPresetService');
if(btnPresetBalanced) btnPresetBalanced.addEventListener('click', ()=> applyScenarioPreset('balanced'));
if(btnPresetIncident) btnPresetIncident.addEventListener('click', ()=> applyScenarioPreset('incidentStorm'));
if(btnPresetService) btnPresetService.addEventListener('click', ()=> applyScenarioPreset('serviceFriday'));

readParams();
readLearnParams();
applyLayoutRadii();
updateLayoutReadout();
refreshAutoObstacles();
resetGeneration();
requestAnimationFrame(loop);

// Toolbox setup
document.querySelectorAll('.tool-btn').forEach(btn=>{
  btn.addEventListener('click', ()=> setTool(btn.dataset.tool));
});
setTool(currentTool);

document.querySelectorAll('.chip-btn[data-pop]').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const val = +btn.dataset.pop;
    const popSlider = Q('slPopulation');
    const popInput = Q('numPopulation');
    if(popSlider){ popSlider.value = val; popSlider.dispatchEvent(new Event('input')); }
    if(popInput) popInput.value = val;
    updateLayoutReadout();
  });
});

const popApply = Q('btnPopApply');
if(popApply){
  popApply.addEventListener('click', ()=>{
    const popInput = Q('numPopulation');
    const val = Math.max(+popInput.min, Math.min(+popInput.max, +popInput.value || params.populationSize));
    const popSlider = Q('slPopulation');
    if(popSlider){ popSlider.value = val; popSlider.dispatchEvent(new Event('input')); }
  });
}

const popInputBox = Q('numPopulation');
if(popInputBox){
  popInputBox.addEventListener('change', ()=>{
    const val = Math.max(+popInputBox.min, Math.min(+popInputBox.max, +popInputBox.value || params.populationSize));
    const popSlider = Q('slPopulation');
    if(popSlider){ popSlider.value = val; popSlider.dispatchEvent(new Event('input')); }
  });
}

const chkLayoutDrag = Q('chkLayoutDrag');
if(chkLayoutDrag){
  chkLayoutDrag.addEventListener('change', ()=>{ layoutState.dragEnabled = chkLayoutDrag.checked; updateLayoutReadout(); });
  layoutState.dragEnabled = chkLayoutDrag.checked;
}

const chkLayoutSnap = Q('chkLayoutSnap');
if(chkLayoutSnap){
  chkLayoutSnap.addEventListener('change', ()=>{ layoutState.snap = chkLayoutSnap.checked; updateLayoutReadout(); });
}

const btnToggleGrid = Q('btnToggleGrid');
if(btnToggleGrid){
  btnToggleGrid.addEventListener('click', ()=>{ layoutState.showGrid = !layoutState.showGrid; updateLayoutReadout(); });
}

const gridSizeSlider = Q('slGridSize');
if(gridSizeSlider){
  gridSizeSlider.addEventListener('input', ()=>{ layoutState.gridSize = +gridSizeSlider.value; Q('lbGridSize').textContent = `${gridSizeSlider.value} px`; updateLayoutReadout(); });
  layoutState.gridSize = +gridSizeSlider.value;
}

const nestRSlider = Q('slNestR');
if(nestRSlider){
  nestRSlider.addEventListener('input', ()=>{ nest.r = +nestRSlider.value; Q('lbNestR').textContent = nestRSlider.value; updateLayoutReadout(); });
}

const targetRSlider = Q('slTargetR');
if(targetRSlider){
  targetRSlider.addEventListener('input', ()=>{ categories.forEach(cat=> cat.zone.r = +targetRSlider.value); Q('lbTargetR').textContent = targetRSlider.value; updateLayoutReadout(); });
}

const scatterSlider = Q('slScatter');
if(scatterSlider){
  scatterSlider.addEventListener('input', ()=>{ Q('lbScatter').textContent = scatterSlider.value; readParams(); updateLayoutReadout(); });
}

const btnLayoutReset = Q('btnLayoutReset');
if(btnLayoutReset) btnLayoutReset.addEventListener('click', ()=>{ resetLayout(); applyLayoutRadii(); });

const btnLayoutRandom = Q('btnLayoutRandom');
if(btnLayoutRandom) btnLayoutRandom.addEventListener('click', ()=>{ randomizeLayout(); applyLayoutRadii(); });

const btnLayoutFan = Q('btnLayoutFan');
if(btnLayoutFan) btnLayoutFan.addEventListener('click', ()=>{ fanLayout(); applyLayoutRadii(); });

function addObstacleFromDrag(start, end){
  const dx = end.x - start.x;
  const dy = end.y - start.y;
  const dist = Math.hypot(dx, dy) || 1;
  if(currentTool === 'circle'){
    manualObstacles.push({type:'circle', x:start.x, y:start.y, r: Math.max(12, dist)});
  } else if(currentTool === 'rect'){
    manualObstacles.push({type:'rect', x:Math.min(start.x,end.x), y:Math.min(start.y,end.y), w:Math.abs(dx), h:Math.abs(dy)});
  } else if(currentTool === 'line'){
    manualObstacles.push({type:'line', x1:start.x, y1:start.y, x2:end.x, y2:end.y});
  } else if(currentTool === 'half'){
    manualObstacles.push({type:'half', x:start.x, y:start.y, r:Math.max(16, dist), angle:Math.atan2(dy, dx)});
  }
}

canvas.addEventListener('mousedown', (e)=>{
  const pos = pointerPos(e);
  if(layoutState.dragEnabled){
    const hit = hitLayoutTarget(pos);
    if(hit){
      layoutState.active = { target: hit.ref, type: hit.type, offsetX: pos.x - hit.ref.x, offsetY: pos.y - hit.ref.y };
      return;
    }
  }
  if(currentTool === 'select') return;
  drawingState = { start: pos };
});
canvas.addEventListener('mouseup', (e)=>{
  if(layoutState.active){ layoutState.active = null; return; }
  if(!drawingState || currentTool === 'select') return;
  const pos = pointerPos(e);
  addObstacleFromDrag(drawingState.start, pos);
  drawingState = null;
});

const btnUndo = Q('btnUndoManual');
if(btnUndo){
  btnUndo.addEventListener('click', ()=>{
    manualObstacles.pop();
  });
}
const btnClear = Q('btnClearManual');
if(btnClear){
  btnClear.addEventListener('click', ()=>{
    manualObstacles = manualObstacles.filter(o=>o.auto);
  });
}

const btnSaveObstacles = Q('btnSaveObstacles');
if(btnSaveObstacles){
  btnSaveObstacles.addEventListener('click', ()=>{
    const blob = new Blob([JSON.stringify(manualObstacles)], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'obstacles.json';
    a.click();
    URL.revokeObjectURL(url);
  });
}
const btnLoadObstacles = Q('btnLoadObstacles');
const inputLoadObstacles = Q('inputLoadObstacles');
if(btnLoadObstacles && inputLoadObstacles){
  btnLoadObstacles.addEventListener('click', ()=> inputLoadObstacles.click());
  inputLoadObstacles.addEventListener('change', (e)=>{
    const file = e.target.files?.[0];
    if(!file) return;
    const reader = new FileReader();
    reader.onload = ()=>{
      try{ manualObstacles = JSON.parse(reader.result); }
      catch(err){ console.error(err); }
    };
    reader.readAsText(file);
  });
}

const btnNextGen = Q('btnNextGen');
if(btnNextGen){
  btnNextGen.addEventListener('click', ()=>{
    if(replayMode){ replayMode = false; resetGeneration(); return; }
    commitGenerationFitness();
    population.evolve();
    resetGeneration();
  });
}

const btnResetTraining = Q('btnResetTraining');
if(btnResetTraining){
  btnResetTraining.addEventListener('click', ()=>{
    population = new Population(params.populationSize);
    population.generation = 1;
    population.bestFitness = 0;
    population.champion = null;
    generationHistory.length = 0;
    lastGenStats = {best:0, avg:0, acc:0};
    resetGeneration();
  });
}

const btnReplayChampion = Q('btnReplayChampion');
if(btnReplayChampion){
  btnReplayChampion.addEventListener('click', startChampionReplay);
}

const btnSaveTraining = Q('btnSaveTraining');
if(btnSaveTraining){
  btnSaveTraining.addEventListener('click', ()=>{
    const data = {
      generation: population.generation,
      params:{...params},
      learn:{...learn},
      genomes: population.genomes,
      champion: population.champion
    };
    const blob = new Blob([JSON.stringify(data)], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'data-sorting-training.json';
    a.click();
    URL.revokeObjectURL(url);
  });
}

const btnLoadTraining = Q('btnLoadTraining');
const inputLoadTraining = Q('inputLoadTraining');
if(btnLoadTraining && inputLoadTraining){
  btnLoadTraining.addEventListener('click', ()=> inputLoadTraining.click());
  inputLoadTraining.addEventListener('change', (e)=>{
    const file = e.target.files?.[0];
    if(!file) return;
    const reader = new FileReader();
    reader.onload = ()=>{
      try{
        const data = JSON.parse(reader.result);
        if(Array.isArray(data.genomes)){
          if(data.params) Object.assign(params, data.params);
          if(data.params?.learn) Object.assign(learn, data.params.learn);
          if(data.learn) Object.assign(learn, data.learn);
          readParams();
          readLearnParams();
          population = new Population(data.genomes.length);
          population.genomes = data.genomes.map(hydrateGenome);
          population.generation = data.generation || 1;
          population.bestFitness = data.bestFitness || 0;
          population.champion = data.champion ? cloneGenome(data.champion) : null;
          population.bestFitness = Math.max(population.bestFitness, ...population.genomes.map(g=> g.fitness||0));
          resetGeneration();
        }
      }catch(err){ console.error(err); }
    };
    reader.readAsText(file);
  });
}

const btnReset = Q('btnReset');
if(btnReset){
  btnReset.addEventListener('click', ()=>{
    refreshAutoObstacles();
    resetGeneration();
  });
}

</script>
</body>
</html>
