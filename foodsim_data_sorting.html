<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Evolve Data Sorting Simulation</title>
  <style>
    :root {
      --bg-dark: #050516;
      --panel-bg: rgba(14, 19, 48, 0.9);
      --accent: #38bdf8;
      --accent-ok: #7cf29d;
      --accent-bad: #f472b6;
      --text-main: #f5f7ff;
      --text-dim: #a0accf;
      --font-mono: 'Fira Code', Consolas, monospace;
      --font-ui: 'Inter', system-ui, sans-serif;
    }
    * { box-sizing: border-box; user-select: none; }
    body {
      margin: 0; overflow: hidden; background: radial-gradient(circle at 18% 10%, rgba(56,189,248,.18) 0%, transparent 46%), radial-gradient(circle at 82% 8%, rgba(244,114,182,.16) 0%, transparent 54%), radial-gradient(circle at 12% 78%, rgba(124,242,157,.12) 0%, transparent 55%), linear-gradient(160deg, var(--bg-dark) 0%, #0f1536 55%, #1a2344 100%); color: var(--text-main);
      font-family: var(--font-ui); display: flex; height: 100vh;
    }
    
    /* Layout */
    .sidebar {
      width: 360px; flex-shrink: 0; display: flex; flex-direction: column;
      background: linear-gradient(180deg, rgba(14, 19, 48, 0.95) 0%, rgba(10,14,35,0.9) 50%, rgba(12,17,40,0.85) 100%);
      border-right: 1px solid rgba(148,163,209,.28);
      box-shadow: 0 10px 40px rgba(0,0,0,0.35);
      backdrop-filter: blur(10px); z-index: 10; overflow-y: auto;
    }
    .main-view { 
        flex: 1; 
        position: relative; 
    }
    
    /* Viewport with improved background gradient */
    .viewport {
        width: 100%;
        height: 100%;
        position: relative;
        background: radial-gradient(circle at 50% 30%, #0b1525 0%, #04070f 80%);
        overflow: hidden;
    }
    .viewport::before {
        content: "";
        position: absolute;
        inset: 0;
        background: radial-gradient(circle at 20% 20%, rgba(56,189,248,0.1), transparent 35%),
                    radial-gradient(circle at 80% 10%, rgba(244,114,182,0.12), transparent 45%),
                    radial-gradient(circle at 50% 80%, rgba(124,242,157,0.12), transparent 40%),
                    linear-gradient(120deg, rgba(255,255,255,0.04) 0%, rgba(255,255,255,0) 20%, rgba(255,255,255,0.04) 40%, rgba(255,255,255,0) 60%, rgba(255,255,255,0.04) 80%);
        pointer-events: none;
        mix-blend-mode: screen;
    }
    .viewport::after {
        content: "";
        position: absolute;
        inset: 0;
        background-image: linear-gradient(rgba(255,255,255,0.04) 1px, transparent 1px),
                          linear-gradient(90deg, rgba(255,255,255,0.04) 1px, transparent 1px);
        background-size: 120px 120px;
        opacity: 0.18;
        pointer-events: none;
    }
    canvas#simCanvas { display: block; width: 100%; height: 100%; cursor: crosshair; }
    
    /* UI Elements */
    .panel-section { padding: 15px; border-bottom: 1px solid rgba(148,163,209,.28); }
    h1 { font-size: 18px; margin: 0 0 10px; color: var(--accent); text-transform: uppercase; letter-spacing: 1px; text-align: center; }
    h2 { font-size: 12px; margin: 15px 0 8px; color: var(--text-dim); text-transform: uppercase; letter-spacing: 0.5px; border-bottom: 1px solid rgba(148,163,209,.28); padding-bottom: 4px; }
    
    .stat-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; }
    .stat-box { background: rgba(0,0,0,0.3); padding: 8px; border-radius: 6px; border: 1px solid #334; display:flex; flex-direction:column; }
    .stat-label { font-size: 10px; color: var(--text-dim); margin-bottom: 2px; }
    .stat-val { font-size: 15px; font-weight: bold; font-family: var(--font-mono); color: #fff; }
    
    .control-group { margin-bottom: 12px; }
    label { display: flex; justify-content: space-between; font-size: 11px; margin-bottom: 4px; color: var(--text-dim); }
    label span { color: var(--accent); font-family: var(--font-mono); }
    input[type=range] { width: 100%; accent-color: var(--accent); height: 4px; border-radius: 2px; background: #334; cursor: pointer; }
    select {
      width: 100%;
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid rgba(148,163,209,.28);
      background: rgba(0,0,0,0.35);
      color: var(--text-main);
      font-size: 11px;
    }
    .control-stack { display: grid; gap: 14px; }
    .control-block {
      padding: 10px;
      border-radius: 10px;
      background: rgba(7, 10, 26, 0.7);
      border: 1px solid rgba(148,163,209,.22);
      box-shadow: inset 0 0 12px rgba(56,189,248,0.05);
    }
    .control-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.6px;
      color: var(--accent);
      margin-bottom: 8px;
    }

    .panel-image {
      border-radius: 10px;
      overflow: hidden;
      border: 1px solid rgba(148,163,209,.28);
      margin-bottom: 10px;
      background: rgba(0,0,0,0.25);
    }
    .panel-image img { display: block; width: 100%; height: auto; }
    
    .btn-group { display: flex; gap: 5px; margin-top: 5px; }
    .btn {
      flex: 1; padding: 10px; background: linear-gradient(90deg, rgba(0,234,255,0.1), rgba(0,234,255,0.2));
      border: 1px solid var(--accent); color: var(--accent); font-weight: bold; text-transform: uppercase; font-size: 11px;
      cursor: pointer; transition: all 0.2s; border-radius: 4px; letter-spacing: 1px;
    }
    .btn:hover { background: var(--accent); color: #000; box-shadow: 0 0 15px var(--accent); }
    .btn.danger { border-color: var(--accent-bad); color: var(--accent-bad); background: rgba(255,51,102,0.1); }
    .btn.danger:hover { background: var(--accent-bad); color: #fff; box-shadow: 0 0 15px var(--accent-bad); }
    .btn.alt { border-color: var(--accent-ok); color: var(--accent-ok); background: rgba(0,255,153,0.1); }
    .btn.alt:hover { background: var(--accent-ok); color: #000; box-shadow: 0 0 15px var(--accent-ok); }

    /* Legends & Pulse */
    .legend-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-bottom: 10px; }
    .legend-item { background: rgba(255,255,255,0.03); border:1px solid rgba(148,163,209,.28); border-radius: 8px; padding: 8px; text-align:center; }
    .legend-dot { width: 10px; height: 10px; border-radius: 50%; display:inline-block; margin-right: 4px; box-shadow: 0 0 8px currentColor; }

    .pulse-grid { display:grid; grid-template-columns:1fr; gap:8px; }
    .pulse-row { display:flex; align-items:center; gap:8px; }
    .pulse-label { font-size:11px; color:var(--text-dim); letter-spacing:0.5px; }
    .pulse-bar { flex:1; background: rgba(255,255,255,0.04); border:1px solid rgba(148,163,209,.28); border-radius:12px; height:10px; position:relative; overflow:hidden; }
    .pulse-bar span { position:absolute; inset:0; width:35%; background:linear-gradient(90deg, var(--accent), var(--accent-ok)); box-shadow:0 0 12px rgba(56,189,248,0.8); border-radius:12px; transition:width 0.3s ease; }
    .pulse-value { font-family: var(--font-mono); font-size:11px; color:var(--accent-ok); }
    .smart-list { list-style: none; margin: 0; padding: 0; display: grid; gap: 6px; }
    .smart-list li { font-size: 11px; color: var(--text-dim); padding: 6px 8px; border-radius: 6px; border: 1px solid rgba(148,163,209,.2); background: rgba(255,255,255,0.03); }
    .smart-list li strong { color: var(--accent-ok); }

    .episode-progress { position:absolute; top:38px; left:20px; right:20px; height:8px; border-radius:12px; background:rgba(255,255,255,0.08); overflow:hidden; box-shadow:0 0 12px rgba(0,0,0,0.4); }
    .episode-progress .fill { height:100%; background:linear-gradient(90deg, rgba(56,189,248,0.2), rgba(124,242,157,0.5), rgba(244,114,182,0.35)); width:0%; transition:width 0.2s ease; }

    .mini-callouts { display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-top:10px; }
    .callout { background:linear-gradient(135deg, rgba(56,189,248,0.08), rgba(244,114,182,0.06)); border:1px solid rgba(148,163,209,.28); border-radius:8px; padding:8px; font-size:11px; color:var(--text-dim); }
    .callout strong { color:var(--accent); }

    .info-panel {
        border-radius: 10px;
        border: 1px solid rgba(148,163,209,.28);
        background: rgba(7, 10, 26, 0.7);
        padding: 10px;
    }
    .info-panel summary {
        cursor: pointer;
        font-size: 12px;
        color: var(--accent);
        text-transform: uppercase;
        letter-spacing: 0.6px;
        list-style: none;
        display: flex;
        align-items: center;
        justify-content: space-between;
    }
    .info-panel summary::-webkit-details-marker { display: none; }
    .info-panel summary::after {
        content: "▾";
        font-size: 12px;
        color: var(--text-dim);
        transition: transform 0.2s ease;
    }
    .info-panel[open] summary::after { transform: rotate(-180deg); }
    .info-panel p {
        margin: 10px 0 0;
        font-size: 11px;
        color: var(--text-dim);
        line-height: 1.5;
    }
    .info-panel ul {
        margin: 8px 0 0 16px;
        padding: 0;
        font-size: 11px;
        color: var(--text-dim);
        line-height: 1.5;
    }

    
    /* HUD Overlay */
    .hud { position: absolute; pointer-events: none; padding: 20px; width: 100%; display: flex; justify-content: space-between; top: 0; }
    .generation-display { font-size: 40px; font-weight: 900; color: rgba(255,255,255,0.1); font-family: var(--font-mono); }
    .live-feed { position: absolute; bottom: 20px; left: 20px; max-width: 300px; display: flex; flex-direction: column-reverse; gap: 5px; pointer-events: none; }
    .feed-item { background: rgba(0,0,0,0.6); padding: 6px 10px; border-radius: 4px; font-size: 11px; border-left: 3px solid var(--text-dim); animation: fadeIn 0.3s ease-out; }
    .feed-item.good { border-color: var(--accent-ok); }
    .feed-item.warn { border-color: #ff9900; }
    .feed-item.bad { border-color: var(--accent-bad); }
    
    @keyframes fadeIn { from { opacity: 0; transform: translateX(-10px); } to { opacity: 1; transform: translateX(0); } }

    /* Brain & Graph */
    #brainCanvas { 
        width: 100%; 
        height: 150px; 
        background: #0a0a12; 
        border: 1px solid #334; 
        border-radius: 6px; 
        margin-top: 5px; 
    }
    #fitnessGraph { width: 100%; height: 70px; background: #0a0a12; border: 1px solid #334; border-radius: 6px; margin-top: 5px; }
    
    .checkbox-row { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; font-size: 12px; cursor: pointer; }
    .checkbox-row input { accent-color: var(--accent); }
    
    /* Agent Hover Tooltip */
    #hoverTip {
        position: absolute; background: rgba(0,0,0,0.85); padding: 8px; border-radius: 4px; border: 1px solid var(--accent);
        font-size: 10px; font-family: var(--font-mono); color: var(--text-main); pointer-events: none; z-index: 1000;
        transform: translate(15px, 15px); transition: opacity 0.1s; opacity: 0;
        line-height: 1.6;
    }

    /* Top Bar for Simulation View */
    .sim-top-bar {
        position: absolute; top: 0; left: 0; width: 100%;
        display: flex; justify-content: space-between; align-items: center;
        padding: 8px 20px; background: rgba(0,0,0,0.2);
        color: var(--text-dim); font-size: 11px;
    }
    .sim-top-bar .fps-counter { font-family: var(--font-mono); color: var(--accent-ok); }

    /* Glow overlays */
    .neon-pulse {
        position:absolute;
        inset:0;
        pointer-events:none;
        background:radial-gradient(circle at 50% 50%, rgba(56,189,248,0.05), transparent 45%),
                  radial-gradient(circle at 15% 70%, rgba(124,242,157,0.06), transparent 35%),
                  radial-gradient(circle at 80% 20%, rgba(244,114,182,0.05), transparent 40%);
        mix-blend-mode:screen;
        animation: pulse 6s ease-in-out infinite;
    }
    @keyframes pulse {
        0%,100%{opacity:0.4;}50%{opacity:0.8;}
    }
  </style>
</head>
<body>

<aside class="sidebar">
  <div class="panel-section">
    <h1>Evolve Control Console</h1>
    
    <div class="stat-grid">
      <div class="stat-box">
        <span class="stat-label">Episode</span>
        <span class="stat-val" id="dispGen">1</span>
      </div>
      <div class="stat-box">
        <span class="stat-label">Best Fitness</span>
        <span class="stat-val" id="dispFit" style="color:var(--accent-ok)">0.0</span>
      </div>
      <div class="stat-box">
        <span class="stat-label">Accuracy</span>
        <span class="stat-val" id="dispAcc">0%</span>
      </div>
      <div class="stat-box">
        <span class="stat-label">Rolling Accuracy</span>
        <span class="stat-val" id="dispAccRolling">0%</span>
      </div>
      <div class="stat-box">
        <span class="stat-label">Successes</span>
        <span class="stat-val" id="dispSolved" style="color:var(--accent-ok)">0</span>
      </div>
      <div class="stat-box">
        <span class="stat-label">Mistakes</span>
        <span class="stat-val" id="dispWrong" style="color:var(--accent-bad)">0</span>
      </div>
      <div class="stat-box">
        <span class="stat-label">Active Agents</span>
        <span class="stat-val" id="dispActive">10/10</span>
      </div>
    </div>
  </div>
  <div class="panel-section">
    <details class="info-panel" open>
      <summary>How to Use This Simulation</summary>
      <p>Guide the agents as they learn to sort tickets into the correct goal zones. Watch the rolling accuracy and best fitness to see learning progress.</p>
      <ul>
        <li>Use <strong>Simulation Pace</strong> and <strong>Episode Duration</strong> to speed up training.</li>
        <li>Adjust <strong>Population Size</strong> and <strong>Ticket Count</strong> to change difficulty.</li>
        <li>Drag agents, the nest, or goal zones to reposition the environment.</li>
      </ul>
    </details>
  </div>
   <div class="btn-group">
        <button class="btn alt" id="btnResetAI">Reset Policy Weights</button>
        <button class="btn" id="btnSkip">Restart Episode</button>
    </div>
    <button class="btn danger" id="btnReset">Hard Reset All</button>
  </div>

  <div class="panel-section">
    <h2>Performance History (Best Agent)</h2>
    <canvas id="fitnessGraph"></canvas>
  </div>

  <div class="panel-section">
      <h2>Active Policy Network (Best Agent)</h2>
      <canvas id="brainCanvas" width="300" height="150"></canvas>
      <div style="font-size:10px; color:#667; text-align:center">Live Neural Network Activity (Red=Negative, Green=Positive)</div>
  </div>

  <div class="panel-section">
    <h2>Simulation Controls</h2>
    <div class="control-stack">
      <div class="control-block">
        <div class="control-title">Simulation Pace</div>
        <div class="control-group">
          <label>Game Speed: <span id="valSpeed">3x</span></label>
          <input type="range" id="slSpeed" min="1" max="20" value="3">
        </div>
        <div class="control-group">
          <label title="Antal frames per episod">Episode Duration (Frames): <span id="valDuration">6000</span></label>
          <input type="range" id="slDuration" min="500" max="10000" step="100" value="6000">
        </div>
        <label class="checkbox-row"><input type="checkbox" id="chkManualEpisode"> Manual Episode (Ends on Restart)</label>
      </div>

      <div class="control-block">
        <div class="control-title">Agents & Tickets</div>
        <div class="control-group">
          <label>Population Size: <span id="valPop">10</span></label>
          <input type="range" id="slPop" min="1" max="100" value="10">
        </div>
        <div class="control-group">
          <label title="Number of tickets in the play area">Ticket Count: <span id="valTickets">50</span></label>
          <input type="range" id="slTicketCount" min="5" max="300" value="50">
        </div>
        <div class="control-group">
          <label title="Minimum distance from goals for ticket spawns">Ticket Goal Buffer: <span id="valTicketGoalBuffer">120px</span></label>
          <input type="range" id="slTicketGoalBuffer" min="0" max="700" value="120" step="10">
        </div>
        <div class="control-group">
          <label>Ticket Spawn Layout</label>
          <select id="slTicketLayout">
            <option value="random">Random (Full Map)</option>
            <option value="lanes">Three Lanes</option>
            <option value="corners">Corner Clusters</option>
            <option value="circle">Center Circle</option>
          </select>
        </div>
        <div class="control-group">
          <label>Ticket Category Grouping</label>
          <select id="slTicketGrouping">
            <option value="mixed">Mixed</option>
            <option value="grouped">Grouped by Category</option>
          </select>
        </div>
      </div>

      <div class="control-block">
        <div class="control-title">Goal Zones</div>
        <div class="control-group">
          <label>Goal Size: <span id="valGoalScale">100%</span></label>
          <input type="range" id="slGoalScale" min="70" max="130" value="100">
        </div>
        <div class="control-group">
          <label>Incident Goal Edge</label>
          <select id="slGoalPlacementIncident">
            <option value="top">Top</option>
            <option value="left">Left</option>
            <option value="bottom">Bottom</option>
            <option value="right">Right</option>
          </select>
        </div>
        <div class="control-group">
          <label>Service Req Goal Edge</label>
          <select id="slGoalPlacementRequest">
            <option value="top">Top</option>
            <option value="left">Left</option>
            <option value="bottom">Bottom</option>
            <option value="right">Right</option>
          </select>
        </div>
        <div class="control-group">
          <label>Problem Goal Edge</label>
          <select id="slGoalPlacementProblem">
            <option value="top">Top</option>
            <option value="left">Left</option>
            <option value="bottom">Bottom</option>
            <option value="right">Right</option>
          </select>
        </div>
      </div>
    </div>
    
   
  <div class="panel-section">
    <h2>Learning (NEAT-lite)</h2>
    <div class="control-group">
      <label title="Antal frames per generation">Steps / Gen: <span id="lbGenSteps">6000</span></label>
      <input type="range" id="slGenSteps" min="500" max="10000" step="100" value="6000">
    </div>
    <div class="control-group">
      <label title="Antal noder i dolda lagret.">Hidden Nodes: <span id="lbHidden">20</span></label>
      <input type="range" id="slHidden" min="8" max="40" step="4" value="20">
    </div>
    <div class="control-group">
      <label title="Andel av nästa generation som muteras">Mutation %: <span id="lbMut">22%</span></label>
      <input type="range" id="slMut" min="1" max="80" value="22">
    </div>
    <div class="control-group">
      <label title="Andel av bästa agenter som kopieras">Elite ratio: <span id="lbElite">20%</span></label>
      <input type="range" id="slElite" min="1" max="100" value="20">
    </div>
    <div class="control-group">
      <label title="Styrka på mutationer i vikter">Mutate weights: <span id="lbMutStrengthW">0.25</span></label>
      <input type="range" id="slMutStrengthW" min="5" max="100" value="25">
    </div>
    <div class="control-group">
      <label title="Styrka på mutationer i bias">Mutate biases: <span id="lbMutStrengthB">0.25</span></label>
      <input type="range" id="slMutStrengthB" min="5" max="100" value="25">
    </div>
    <div class="control-group">
      <label title="Hur ofta crossover väljer parent A">Crossover bias: <span id="lbCrossover">50% A</span></label>
      <input type="range" id="slCrossover" min="0" max="100" value="50">
    </div>
    <div class="control-group">
      <label title="Antal kandidater i turnering">Selection pool: <span id="lbTournament">×2.0</span></label>
      <input type="range" id="slTournament" min="10" max="60" value="20">
    </div>
    <div class="control-group">
      <label title="Andel helt nya nät varje generation">Fresh spawn %: <span id="lbFresh">6%</span></label>
      <input type="range" id="slFresh" min="0" max="40" value="6">
    </div>
    <label class="checkbox-row"><input type="checkbox" id="chkAuto" checked> Auto next gen <span id="lbAuto">on</span></label>
    <div class="btn-group">
      <button class="btn" id="btnNextGen">Advance Generation</button>
      <button class="btn alt" id="btnResetTraining">Reset Training</button>
    </div>
    <div class="btn-group">
      <button class="btn" id="btnSaveTraining">Save Training (.json)</button>
      <button class="btn" id="btnLoadTraining">Load Training…</button>
      <input type="file" id="inputLoadTraining" accept="application/json" style="display:none">
    </div>
  </div>

  <div class="panel-section">
    <h2>Penalties</h2>

    <div class="control-group">
      <label title="Penalty when agents hit the wall">Wall Penalty: <span id="valPenaltyWall">0</span></label>
      <input type="range" id="slPenaltyWall" min="0" max="50" value="0" step="1">
    </div>

    <div class="control-group">
      <label title="Penalty when agents are stalled">Stalled Penalty: <span id="valPenaltyStalled">0</span></label>
      <input type="range" id="slPenaltyStalled" min="0" max="50" value="0" step="1">
    </div>

    <div class="control-group">
      <label title="Penalty for dropping a ticket in the wrong zone">Wrong Zone Penalty: <span id="valPenaltyWrong">-1</span></label>
      <input type="range" id="slPenaltyWrong" min="0" max="100" value="1" step="1">
    </div>
  </div>

  <div class="panel-section">
    <h2>Reward Shaping</h2>

    <div class="control-group">
      <label title="Reward for movement (distance-based)">Movement Reward: <span id="valRewardMove">0.00</span></label>
      <input type="range" id="slRewardMove" min="0" max="50" value="0" step="1">
    </div>

    <div class="control-group">
      <label title="Reward for discovering new cells">Curiosity Reward: <span id="valRewardCuriosity">0.00</span></label>
      <input type="range" id="slRewardCuriosity" min="0" max="100" value="0" step="1">
    </div>

    <div class="control-group">
      <label title="Scales progress reward toward targets">Progress Scale: <span id="valRewardProgressScale">0.00</span></label>
      <input type="range" id="slRewardProgressScale" min="0" max="200" value="0" step="1">
    </div>

    <div class="control-group">
      <label title="Reward for sustained progress streaks">Progress Streak Reward: <span id="valRewardStreak">0.00</span></label>
      <input type="range" id="slRewardStreak" min="0" max="50" value="0" step="1">
    </div>

    <div class="control-group">
      <label title="Reward for picking up a ticket">Pickup Reward: <span id="valRewardPickup">0</span></label>
      <input type="range" id="slRewardPickup" min="0" max="30" value="0" step="1">
    </div>

    <div class="control-group">
      <label title="Base reward for correct delivery">Delivery Base Reward: <span id="valRewardDeliveryBase">1</span></label>
      <input type="range" id="slRewardDeliveryBase" min="0" max="120" value="1" step="1">
    </div>

    <div class="control-group">
      <label title="Bonus for energy left on delivery">Delivery Energy Bonus: <span id="valRewardDeliveryEnergy">0</span></label>
      <input type="range" id="slRewardDeliveryEnergy" min="0" max="40" value="0" step="1">
    </div>

    <div class="control-group">
      <label title="Reward for being close to the correct goal zone">Near Correct Goal Reward: <span id="valRewardNearCorrect">0.00</span></label>
      <input type="range" id="slRewardNearCorrect" min="0" max="100" value="0" step="1">
    </div>

    <div class="control-group">
      <label title="Penalty for being close to the wrong goal zones">Near Wrong Goal Penalty: <span id="valPenaltyNearWrong">-0.00</span></label>
      <input type="range" id="slPenaltyNearWrong" min="0" max="100" value="0" step="1">
    </div>

    <div class="control-group">
      <label title="Penalty when the agent switches targets too often">Target Switch Penalty: <span id="valPenaltyTargetSwitch">-0.00</span></label>
      <input type="range" id="slPenaltyTargetSwitch" min="0" max="50" value="0" step="1">
    </div>
  </div>

  <div class="panel-section">
    <h2>Game Physics / ACO</h2>
    
    <div class="control-group">
      <label title="How far the agents can see">Sensor Range: <span id="valSensor">180px</span></label>
      <input type="range" id="slSensor" min="50" max="400" value="180">
    </div>
    
    <div class="control-group">
      <label title="Higher = batteries drain faster">Battery Drain: <span id="valDrain">Normal</span></label>
      <input type="range" id="slDrain" min="1" max="20" value="8">
    </div>

    <div class="control-group">
      <label title="Evaporation rate for pheromones. 0.99 = slow">Pheromone Decay: <span id="valDecay">0.990</span></label>
      <input type="range" id="slDecay" min="980" max="999" value="990">
    </div>
  </div>
  
  <div class="panel-section">
    <h2>Visuals</h2>
      <label class="checkbox-row"><input type="checkbox" id="chkBrainViz" checked> Show Policy Network</label>
      <label class="checkbox-row"><input type="checkbox" id="chkSensors"> Show Sensors (Simplified)</label>
      <label class="checkbox-row"><input type="checkbox" id="chkPheromones" checked> Show Pheromone Heatmap</label>
      <label class="checkbox-row"><input type="checkbox" id="chkParticles" checked> Show Particles (Feedback)</label>
      <label class="checkbox-row"><input type="checkbox" id="chkTrail"> Show Best Agent Trail</label>
  </div>
</aside>

<main class="main-view">
  <div class="viewport">
    <div class="sim-top-bar">
        <span><strong style="color:var(--accent)">Evolve:</strong> Data Sorting Simulation</span>
        <span class="fps-counter" id="fpsDisplay">FPS: 0</span>
    </div>
    <div class="episode-progress"><div class="fill" id="episodeFill"></div></div>
    <canvas id="simCanvas"></canvas>
    <div class="hud">
      <div class="generation-display" id="hudGen">EPISODE 1</div>
      <div style="text-align:right; font-size:12px; color:rgba(255,255,255,0.4)">
        <p>[SPACE] Pause | [S] Restart Episode | Click & Drag Agent / NEST / Zone</p>
      </div>
    </div>
    <div class="live-feed" id="feed"></div>
    <div id="hoverTip"></div>
    <div class="neon-pulse"></div>
  </div>
</main>

<script>
// --- CONFIGURATION OBJECT (Mutable) ---
const CFG = {
  popSize: 10,
  evolve: {
    elite: 0.2,
    mutRate: 0.22,
    mutStrength: 0.25,
    fresh: 0.06
  },
  penalties: {
    wall: 0,
    stalled: 0,
    wrongSort: 1
  },
  
  ticketCount: 50,
  manualEpisode: false,
  ticketSpawn: {
    layout: 'random',
    grouping: 'mixed',
    minGoalDistance: 120
  },
  goalScale: 1,
  goalPlacements: {
    incident: 'top',
    request: 'top',
    problem: 'top'
  },
  sensorRange: 180, 
  maxSpeed: 4.0, 
  turnRate: 0.08, 
  episodeDuration: 6000, 
  energyDrain: 0.0008, 
  
  // Policy Network Architecture (Fixed)
  inputs: 15, 
  hiddens: 20, 
  outputs: 6, 
  // Outputs: [Steer_Bias, Speed_Factor, Brake_Factor, Goal_INC_WT, Goal_REQ_WT, Goal_PROB_WT]
  smart: {
    sensorBoostMax: 1.6,
    carrySensorScale: 0.85,
    stuckFrames: 45,
    leaderDeposit: 0.07,
    agentDeposit: 0.04,
    ticketDeposit: 0.08,
    zoneDeposit: 0.12,
    successDeposit: 0.2,
    separationRadius: 35,
    separationStrength: 0.6,
    deliveryAssist: 0.35,
    pheromoneAssist: 0.55,
    targetLockFrames: 160,
    targetSwitchMargin: 0.12,
    targetScoreDistance: 0.65,
    targetScorePheromone: 0.25,
    targetScoreUrgency: 0.3
  },
  rewards: {
    move: 0,
    curiosity: 0,
    progressScale: 0,
    progressStreak: 0,
    pickup: 0,
    deliveryBase: 1,
    deliveryEnergy: 0,
    nearCorrect: 0,
    nearWrong: 0,
    targetSwitchPenalty: 0
  },
  
  categories: [
    { id: 'incident', color: '#ff3366', label: 'Incident' }, /* Red */
    { id: 'request', color: '#00ff99', label: 'Service Req' }, /* Green */
    { id: 'problem', color: '#00eaff', label: 'Problem' } /* Cyan */
  ]
};

const params = {
  learn: {
    genSteps: 6000,
    hidden: 20,
    mut: 0.22,
    elite: 0.2,
    mutStrengthW: 0.25,
    mutStrengthB: 0.25,
    crossoverBias: 0.5,
    tournamentFactor: 2.0,
    fresh: 0.06,
    auto: true
  }
};

// --- GLOBALS ---
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
const brainCanvas = document.getElementById('brainCanvas');
const brainCtx = brainCanvas.getContext('2d');
const hoverTip = document.getElementById('hoverTip');
const fpsDisplay = document.getElementById('fpsDisplay');

let W, H;
let episode = 1;
let frame = 0;
let speedMult = 3;
let paused = false;
let agents = [];
let tickets = [];
let particles = [];
let bestAgent = null; // Agent with the highest accumulated fitness in the current episode
let history = [];
let nest = null; 
let goalZones = []; 
let mouse = { x:0, y:0, down:false, dragAgent:null, dragNest: false, dragZone: null }; 
let zoneHighlight = null; 
const ROLLING_ACCURACY_WINDOW = 500;
const rollingResults = [];

// FPS Counter Variables
let lastFrameTime = 0;
let fps = 0;

// Stats
let stats = {
    solved: 0,
    wrong: 0,
    activeCount: 0
};

function recordRollingResult(isCorrect) {
    rollingResults.push(isCorrect ? 1 : 0);
    if (rollingResults.length > ROLLING_ACCURACY_WINDOW) {
        rollingResults.splice(0, rollingResults.length - ROLLING_ACCURACY_WINDOW);
    }
}

// --- MATH UTILS ---
const dist = (x1,y1,x2,y2) => Math.hypot(x2-x1, y2-y1);
const clamp = (v,min,max) => Math.max(min, Math.min(max, v));
const rand = (min,max) => Math.random() * (max-min) + min;
const normDist = (d) => clamp(d / CFG.sensorRange, 0, 1); 
const normDistWithRange = (d, range) => clamp(d / range, 0, 1);
const normAngle = (a) => {
    while (a > Math.PI) a -= 2 * Math.PI;
    while (a < -Math.PI) a += 2 * Math.PI;
    return a / Math.PI;
}

// Sigmoid activation function (useful for policy outputs)
const sigmoid = (x) => 1 / (1 + Math.exp(-x));
const tanh = (x) => Math.tanh(x);

const NET_HIDDEN_MIN = 8;
const NET_HIDDEN_MAX = 40;
let NET_INPUTS = CFG.inputs;
let NET_OUTPUTS = CFG.outputs;
let NET_HIDDEN = CFG.hiddens;

function randn(){
    let u = 0, v = 0;
    while(u === 0) u = Math.random();
    while(v === 0) v = Math.random();
    return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
}
function matmulVec(W, x, out){
    const rows = W.length;
    const cols = W[0]?.length || 0;
    for(let i = 0; i < rows; i++){
        let s = 0;
        const Wi = W[i];
        for(let j = 0; j < cols; j++) s += Wi[j] * x[j];
        out[i] = s;
    }
    return out;
}
function tanhVec(v){
    for(let i = 0; i < v.length; i++) v[i] = Math.tanh(v[i]);
    return v;
}
function addBias(v, b){
    for(let i = 0; i < v.length; i++) v[i] += b[i];
    return v;
}
function ensureArraySize(arr, length){
    return (Array.isArray(arr) && arr.length === length) ? arr : new Array(length);
}
function ensureNetHiddenSize(net, desired = NET_HIDDEN){
    if(!net) return net;
    const target = Math.max(1, Math.round(Number.isFinite(desired) ? desired : NET_HIDDEN));
    if(!Array.isArray(net.W1)) net.W1 = [];
    if(!Array.isArray(net.b1)) net.b1 = [];
    const inputDim = Array.isArray(net.W1?.[0]) ? net.W1[0].length : (Array.isArray(net.W2?.[0]) ? net.W2[0].length : NET_INPUTS);
    while(net.W1.length < target){
        net.W1.push(Array.from({length: inputDim}, () => (Math.random() * 2 - 1) * 0.5));
    }
    while(net.b1.length < target){
        net.b1.push((Math.random() * 2 - 1) * 0.2);
    }
    if(net.W1.length > target) net.W1.length = target;
    if(net.b1.length > target) net.b1.length = target;
    return net;
}
function ensureNetInputSize(net, desired = NET_INPUTS){
    if(!net || !Array.isArray(net.W1)) return net;
    for(let i = 0; i < net.W1.length; i++){
        let row = Array.isArray(net.W1[i]) ? net.W1[i] : [];
        while(row.length < desired){
            row.push((Math.random() * 2 - 1) * 0.5);
        }
        if(row.length > desired){
            row.length = desired;
        }
        net.W1[i] = row;
    }
    return net;
}
function ensureNetOutputSize(net, desired = NET_OUTPUTS){
    if(!net) return net;
    ensureNetHiddenSize(net, NET_HIDDEN);
    ensureNetInputSize(net, NET_INPUTS);
    const hiddenDim = Array.isArray(net.W1) ? net.W1.length : NET_HIDDEN;
    if(!Array.isArray(net.W2)) net.W2 = [];
    if(!Array.isArray(net.b2)) net.b2 = [];
    for(let i = 0; i < net.W2.length; i++){
        const row = Array.isArray(net.W2[i]) ? net.W2[i].slice() : [];
        if(row.length !== hiddenDim){
            net.W2[i] = Array.from({length: hiddenDim}, (_v, idx)=> (idx < row.length && Number.isFinite(row[idx])) ? row[idx] : (Math.random() * 2 - 1) * 0.5);
        } else {
            net.W2[i] = row;
        }
    }
    while(net.W2.length < desired){
        net.W2.push(Array.from({length: hiddenDim}, ()=> (Math.random() * 2 - 1) * 0.5));
    }
    while(net.b2.length < desired){
        net.b2.push((Math.random() * 2 - 1) * 0.2);
    }
    if(net.W2.length > desired) net.W2.length = desired;
    if(net.b2.length > desired) net.b2.length = desired;
    return net;
}
function makeNet(inDim = NET_INPUTS, h = NET_HIDDEN, out = NET_OUTPUTS){
    const net = {
        W1: Array.from({length: h}, ()=> Array.from({length: inDim}, ()=> (Math.random() * 2 - 1) * 0.5)),
        b1: Array.from({length: h}, ()=> (Math.random() * 2 - 1) * 0.2),
        W2: Array.from({length: out}, ()=> Array.from({length: h}, ()=> (Math.random() * 2 - 1) * 0.5)),
        b2: Array.from({length: out}, ()=> (Math.random() * 2 - 1) * 0.2)
    };
    ensureNetHiddenSize(net, h);
    ensureNetInputSize(net, inDim);
    return ensureNetOutputSize(net, out);
}
function cloneNet(n){
    const cloned = {
        W1: n.W1.map(r => r.slice()),
        b1: n.b1.slice(),
        W2: n.W2.map(r => r.slice()),
        b2: n.b2.slice()
    };
    ensureNetHiddenSize(cloned, NET_HIDDEN);
    ensureNetInputSize(cloned, NET_INPUTS);
    return ensureNetOutputSize(cloned);
}
function mutateNet(n, rate){
    const sW = params.learn?.mutStrengthW ?? 0.25;
    const sB = params.learn?.mutStrengthB ?? 0.25;
    for(const r of n.W1){
        for(let i = 0; i < r.length; i++){
            if(Math.random() < rate) r[i] += randn() * sW;
        }
    }
    for(let i = 0; i < n.b1.length; i++){
        if(Math.random() < rate) n.b1[i] += randn() * sB;
    }
    for(const r of n.W2){
        for(let i = 0; i < r.length; i++){
            if(Math.random() < rate) r[i] += randn() * sW;
        }
    }
    for(let i = 0; i < n.b2.length; i++){
        if(Math.random() < rate) n.b2[i] += randn() * sB;
    }
}
function crossover(a, b){
    const bias = params.learn?.crossoverBias ?? 0.5;
    const c = cloneNet(a);
    const pick = () => (Math.random() < bias);
    for(let i = 0; i < c.W1.length; i++){
        for(let j = 0; j < c.W1[0].length; j++){
            c.W1[i][j] = pick() ? a.W1[i][j] : b.W1[i][j];
        }
    }
    for(let i = 0; i < c.b1.length; i++){
        c.b1[i] = pick() ? a.b1[i] : b.b1[i];
    }
    for(let i = 0; i < c.W2.length; i++){
        for(let j = 0; j < c.W2[0].length; j++){
            c.W2[i][j] = pick() ? a.W2[i][j] : b.W2[i][j];
        }
    }
    for(let i = 0; i < c.b2.length; i++){
        c.b2[i] = pick() ? a.b2[i] : b.b2[i];
    }
    return c;
}
function forward(net, x, capture = null){
    ensureNetInputSize(net, x.length);
    ensureNetHiddenSize(net, NET_HIDDEN);
    ensureNetOutputSize(net, NET_OUTPUTS);
    const hidden = capture ? ensureArraySize(capture.hidden, net.b1.length) : new Array(net.b1.length);
    const output = capture ? ensureArraySize(capture.output, net.b2.length) : new Array(net.b2.length);
    matmulVec(net.W1, x, hidden);
    addBias(hidden, net.b1);
    tanhVec(hidden);
    matmulVec(net.W2, hidden, output);
    addBias(output, net.b2);
    tanhVec(output);
    if(capture){
        capture.hidden = hidden;
        capture.output = output;
        const inputStore = ensureArraySize(capture.input, x.length);
        for(let i = 0; i < x.length; i++) inputStore[i] = x[i];
        capture.input = inputStore;
        capture.timestamp = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
    }
    return output;
}
function makePopulation(size){
    return Array.from({length: size}, ()=> ({ net: makeNet(), fitness: 0 }));
}
const evo = { gen: 1, population: [] };
const bestBrainState = {
    fitness: -Infinity,
    gen: 1,
    net: null,
    activations: { input: [], hidden: [], output: [], timestamp: 0 }
};

// --- FEROMON SYSTEM (ACO) ---
const PHEROMONE_CAP = 10;
const PHEROMONE_SPREAD = 0.4;
let PHEROMONE_DECAY = 0.990; 

let CS = 25; 
let GW = 0; 
let GH = 0; 
let grid = {
    food: null, 
    incident: null, 
    request: null, 
    problem: null, 
};
const GRID_FIELDS = ['food', 'incident', 'request', 'problem'];

const gi=(x,y)=> y*GW + x;
const clampi=(v,a,b)=> v<a?a:(v>b?b:v);

function makeGrid(){
    GW = Math.floor(W / CS);
    GH = Math.floor(H / CS);
    const size = GW * GH;
    
    for(const key of GRID_FIELDS){
        grid[key] = new Float32Array(size); 
    }
}

function deposit(type, x, y, amt, opts = {}){
    const field = grid?.[type];
    if(!field) return;
    const amount = Number(amt);
    if(!Number.isFinite(amount) || amount <= 0) return;
    
    const cx=clampi((x/CS)|0,0,GW-1), cy=clampi((y/CS)|0,0,GH-1);
    const idx = gi(cx,cy);
    const cap = Number.isFinite(opts.cap) ? opts.cap : PHEROMONE_CAP;
    
    const apply = (index, delta)=>{ 
        if(index<0 || index>=field.length) return;
        let next = field[index] + delta;
        field[index] = Math.min(next, cap);
    }; 
    
    apply(idx, amount);
    
    const spread = Math.max(0, Number(opts.spread)||0);
    if(spread > 0) {
         const dx = [-1, 0, 1, -1, 1, -1, 0, 1];
         const dy = [-1, -1, -1, 0, 0, 1, 1, 1];
         const spreadAmt = amount * spread * 0.1;
         for(let i=0; i<8; i++){
             const ncx = cx + dx[i];
             const ncy = cy + dy[i];
             const nidx = gi(clampi(ncx,0,GW-1), clampi(ncy,0,GH-1));
             apply(nidx, spreadAmt);
         }
    }
}

// Calculates the pheromone gradient (scent direction) at a position
function senseGrad(type, x, y){
    const field = grid?.[type];
    if(!field) return { gx: 0, gy: 0, mag: 0 };
    
    const cx=clampi((x/CS)|0,0,GW-1), cy=clampi((y/CS)|0,0,GH-1);
    
    let gx = 0;
    let gy = 0;
    let centerVal = field[gi(cx,cy)];

    if(centerVal > 0){
        const dx = [1, 1, 1, 0, 0, -1, -1, -1];
        const dy = [-1, 0, 1, -1, 1, -1, 0, 1];
        const scale = [0.5, 1, 0.5, 1, 1, 0.5, 1, 0.5]; 

        for(let i=0; i<8; i++){
            const ncx = cx + dx[i];
            const ncy = cy + dy[i];
            
            const nidx = gi(clampi(ncx,0,GW-1), clampi(ncy,0,GH-1));
            const neighborVal = field[nidx];
            
            const diff = neighborVal - centerVal; 

            gx += dx[i] * diff * scale[i];
            gy += dy[i] * diff * scale[i];
        }
    }

    const mag = Math.hypot(gx, gy);
    if(mag > 0){
        gx /= mag;
        gy /= mag;
    }

    return { gx, gy, mag: centerVal }; 
}

function pheromoneValue(type, x, y){
    const field = grid?.[type];
    if(!field) return 0;
    const cx = clampi((x/CS)|0, 0, GW-1);
    const cy = clampi((y/CS)|0, 0, GH-1);
    return field[gi(cx, cy)] || 0;
}

function evaporate(){
    const decay = PHEROMONE_DECAY;
    for(let i=0; i<grid.food.length; i++){
        for(const key of GRID_FIELDS){
            grid[key][i] *= decay;
        }
    }
}

// --- END FEROMON SYSTEM ---


// --- POLICY NETWORK ---

class PolicyNetwork {
    constructor(inputs, hiddens, outputs, weights = null) {
        this.I = inputs;
        this.H = hiddens;
        this.O = outputs;
        
        const size1 = this.I * this.H;
        const size2 = this.H * this.O;

        // Initialize or clone weights and biases
        this.w1 = weights ? new Float32Array(weights.w1) : new Float32Array(size1).map(() => rand(-0.5, 0.5));
        this.w2 = weights ? new Float32Array(weights.w2) : new Float32Array(size2).map(() => rand(-0.5, 0.5));
        this.bias1 = weights ? new Float32Array(weights.bias1) : new Float32Array(this.H).map(() => rand(-0.5, 0.5));
        this.bias2 = weights ? new Float32Array(weights.bias2) : new Float32Array(this.O).map(() => rand(-0.5, 0.5));

        // For backpropagation: Store activations and Z-values (pre-activation)
        this.hiddens = new Float32Array(this.H);
        this.outputs = new Float32Array(this.O);
        this.z1 = new Float32Array(this.H);
        this.z2 = new Float32Array(this.O);
    }

    clone() {
        return new PolicyNetwork(this.I, this.H, this.O, {
            w1: this.w1, w2: this.w2, bias1: this.bias1, bias2: this.bias2
        });
    }

    mutate(rate, strength) {
        for(let i=0; i<this.w1.length; i++) {
            if(Math.random() < rate) this.w1[i] += rand(-strength, strength);
        }
        for(let i=0; i<this.w2.length; i++) {
            if(Math.random() < rate) this.w2[i] += rand(-strength, strength);
        }
        for(let i=0; i<this.bias1.length; i++) {
            if(Math.random() < rate) this.bias1[i] += rand(-strength, strength);
        }
        for(let i=0; i<this.bias2.length; i++) {
            if(Math.random() < rate) this.bias2[i] += rand(-strength, strength);
        }
    }

    // Forward pass - Maps state (inputs) to action policy (outputs)
    predict(inputs) {
        const safeInputs = new Float32Array(this.I);
        for(let i=0; i<this.I; i++) safeInputs[i] = inputs[i] || 0;

        // Hidden Layer (Tanh activation)
        for(let i=0; i<this.H; i++) {
            let sum = this.bias1[i];
            for(let j=0; j<this.I; j++) sum += safeInputs[j] * this.w1[j*this.H + i];
            this.z1[i] = sum;
            this.hiddens[i] = tanh(sum);
        }

        // Output Layer (Tanh for Action Weights)
        for(let i=0; i<this.O; i++) {
            let sum = this.bias2[i];
            for(let j=0; j<this.H; j++) sum += this.hiddens[j] * this.w2[j*this.O + i];
            this.z2[i] = sum;
            this.outputs[i] = tanh(sum); // Policy is [-1, 1]
        }
        return { outputs: this.outputs, hiddens: this.hiddens };
    }

    // Simplified Policy Gradient/Online Learning Update
    // Reward (R) acts as the 'Advantage' estimate.
    backpropagate(inputs, outputs, reward, alpha) {
        if(reward === 0) return; // Skip learning if no reward

        const learningRate = alpha * Math.abs(reward); // Scale learning by reward magnitude
        
        // 1. Calculate Output Gradients (Policy update proportional to reward)
        let outputDeltas = new Float32Array(this.O);
        for(let i=0; i<this.O; i++) {
             // Derivative of tanh(x) is 1 - tanh(x)^2.
             const activation_derivative = 1 - outputs[i] * outputs[i];
             // Simple pseudo-gradient: (Reward Signal) * (Activation Derivative)
             outputDeltas[i] = reward * activation_derivative; 
        }

        // 2. Calculate Hidden Deltas
        let hiddenDeltas = new Float32Array(this.H);
        for(let i=0; i<this.H; i++) {
            let sum = 0;
            for(let j=0; j<this.O; j++) {
                sum += outputDeltas[j] * this.w2[i*this.O + j];
            }
            // Derivative of tanh(x) is 1 - tanh(x)^2.
            hiddenDeltas[i] = sum * (1 - this.hiddens[i] * this.hiddens[i]);
        }
        
        // 3. Update Weights (Hidden -> Output)
        for(let i=0; i<this.H; i++) {
            for(let j=0; j<this.O; j++) {
                const index = i*this.O + j;
                this.w2[index] += learningRate * outputDeltas[j] * this.hiddens[i];
            }
        }
        // Update Biases (Output)
        for(let i=0; i<this.O; i++) {
            this.bias2[i] += learningRate * outputDeltas[i];
        }

        // 4. Update Weights (Input -> Hidden)
        const safeInputs = new Float32Array(this.I);
        for(let i=0; i<this.I; i++) safeInputs[i] = inputs[i] || 0;
        
        for(let i=0; i<this.I; i++) {
            for(let j=0; j<this.H; j++) {
                const index = i*this.H + j;
                this.w1[index] += learningRate * hiddenDeltas[j] * safeInputs[i];
            }
        }
        // Update Biases (Hidden)
        for(let i=0; i<this.H; i++) {
            this.bias1[i] += learningRate * hiddenDeltas[i];
        }
    }
}


// --- ENTITIES ---
class Nest {
    // ... (Nest class remains the same) ...
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.r = 25;
    }
    draw() {
        const pulseR = this.r * (1 + Math.sin(frame * 0.1) * 0.1);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(this.x, this.y, pulseR + 5, 0, Math.PI * 2);
        ctx.stroke();

        ctx.fillStyle = 'rgba(255, 255, 255, 0.08)';
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';
        ctx.font = '12px ' + varStyles.fontUi;
        ctx.fillText('NEST', this.x, this.y + 4);
        
        if (mouse.dragNest) {
            ctx.strokeStyle = varStyles.accent;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.r + 5, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        // Feromon Deposition (Food/Nest Pheromone) at the Nest
        if(frame % 5 === 0) {
            deposit('food', this.x, this.y, PHEROMONE_CAP * 0.05, { cap: PHEROMONE_CAP, spread: 0.1 });
        }
    }
}

function getBalancedCategoryIndex(excludeTicket = null) {
    const counts = Array.from({ length: CFG.categories.length }, () => 0);
    for (const t of tickets) {
        if (!t || t === excludeTicket) continue;
        if (!Number.isInteger(t.typeIdx)) continue;
        counts[t.typeIdx] = (counts[t.typeIdx] || 0) + 1;
    }
    const minCount = Math.min(...counts);
    const candidates = counts
        .map((count, idx) => ({ count, idx }))
        .filter(entry => entry.count === minCount)
        .map(entry => entry.idx);
    if (!candidates.length) return Math.floor(Math.random() * CFG.categories.length);
    return candidates[Math.floor(Math.random() * candidates.length)];
}

class Ticket {
    // ... (Ticket class remains the same) ...
    constructor(spawnIndex = 0) {
        this.spawnIndex = spawnIndex;
        this.respawn();
    }

    update() {
        deposit('food', this.x, this.y, PHEROMONE_CAP * CFG.smart.ticketDeposit, { spread: PHEROMONE_SPREAD });
    }

    respawn() {
        this.id = Math.random();
        this.typeIdx = getBalancedCategoryIndex(this);
        this.def = CFG.categories[this.typeIdx];
        const spawn = getTicketSpawnPoint(this.typeIdx, this.spawnIndex, CFG.ticketCount);
        this.x = spawn.x;
        this.y = spawn.y;
        this.r = 8;
    }

    draw() {
        const w = 12, h = 16;
        ctx.save();
        ctx.translate(this.x, this.y);

        const badge = ctx.createLinearGradient(-w/2, -h/2, w/2, h/2);
        badge.addColorStop(0, this.def.color);
        badge.addColorStop(1, 'rgba(255,255,255,0.7)');
        ctx.fillStyle = badge;
        ctx.globalAlpha = 0.9;
        ctx.beginPath();
        ctx.roundRectPolyfill(-w/2, -h/2, w, h, 3);
        ctx.fill();
        ctx.globalAlpha = 1;

        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;
        ctx.stroke();

        ctx.restore();
    }
}


class Agent {
  constructor(netRef = null) {
    this.netRef = netRef || { net: makeNet(), fitness: 0 };
    this.x = nest ? nest.x : W/2; 
    this.y = nest ? nest.y : H/2; 
    this.angle = rand(0, Math.PI*2);
    this.vel = 0;
    this.r = 10;
    this.teamHue = 210; 
    this.carrying = null;
    this.energy = 1.0;
    this.fitness = 0;
    this.stalled = false;
    this.trail = []; 
    
    this.lastState = new Array(CFG.inputs).fill(0); 
    this.lastAction = new Array(CFG.outputs).fill(0);
    this.accumulatedReward = 0;
    this.stuckFrames = 0;
    this.searchFrames = 0;
    this.progressStreak = 0;
    this.visitedCells = new Set();
    this.lastSensorRange = CFG.sensorRange;
    this.targetTicketId = null;
    this.targetLockFrames = 0;
    this.currentTargetTicket = null;
    this.lastTargetChoice = null;
    this.lastTargetDistance = null;
    this.activationScratch = { input: [], hidden: [], output: [], timestamp: 0 };
  }

  getSensorRange() {
    const baseRange = CFG.sensorRange;
    let range = baseRange;
    if (this.carrying) {
        range *= CFG.smart.carrySensorScale;
    } else {
        const boost = clamp(this.searchFrames / 900, 0, CFG.smart.sensorBoostMax - 1);
        range *= 1 + boost;
    }
    return clamp(range, baseRange * 0.7, baseRange * CFG.smart.sensorBoostMax);
  }

  scoreTicket(ticket) {
    const distance = dist(this.x, this.y, ticket.x, ticket.y);
    const distanceScore = 1 - clamp(distance / (CFG.sensorRange * 2.2), 0, 1);
    const pheromoneScore = clamp(pheromoneValue('food', ticket.x, ticket.y) / PHEROMONE_CAP, 0, 1);
    return (distanceScore * CFG.smart.targetScoreDistance)
        + (pheromoneScore * CFG.smart.targetScorePheromone);
  }

  getTargetTicket() {
    if(this.carrying) return null;

    let lockedTicket = null;
    if (this.targetTicketId) {
      lockedTicket = tickets.find(t => t.id === this.targetTicketId && t.x > 0) || null;
      if (!lockedTicket) {
        this.targetTicketId = null;
        this.targetLockFrames = 0;
      }
    }

    if (lockedTicket && this.targetLockFrames > 0) {
      this.targetLockFrames -= 1;
      return lockedTicket;
    }

    let bestTicket = null;
    let bestScore = -Infinity;
    for (const t of tickets) {
      if (t.x < 0) continue;
      const score = this.scoreTicket(t);
      if (score > bestScore) {
        bestScore = score;
        bestTicket = t;
      }
    }

    if (lockedTicket && bestTicket && lockedTicket !== bestTicket) {
      const lockedScore = this.scoreTicket(lockedTicket);
      if (lockedScore + CFG.smart.targetSwitchMargin >= bestScore) {
        this.targetLockFrames = Math.max(this.targetLockFrames, 1);
        return lockedTicket;
      }
    }

    if (bestTicket) {
      this.targetTicketId = bestTicket.id;
      this.targetLockFrames = CFG.smart.targetLockFrames;
    }

    return bestTicket;
  }
  
  // Gets the current state (inputs) for the Policy Network
  getState() {
    let inputs = new Array(CFG.inputs).fill(0);
    let inputIndex = 0;
    const effectiveRange = this.getSensorRange();
    this.lastSensorRange = effectiveRange;

    const toVector = (target) => {
        if (!target) return { dx: 0, dy: 0, dist: 1 };
        const dx = clamp((target.x - this.x) / effectiveRange, -1, 1);
        const dy = clamp((target.y - this.y) / effectiveRange, -1, 1);
        const normalizedDist = clamp(dist(this.x, this.y, target.x, target.y) / effectiveRange, 0, 1);
        return { dx, dy, dist: normalizedDist };
    };

    const zones = getZones();
    const incidentZone = zones.find(z => z.id === 'incident');
    const requestZone = zones.find(z => z.id === 'request');
    const problemZone = zones.find(z => z.id === 'problem');

    // 1. Closest Ticket Vector (2 inputs)
    const ticketVector = toVector(this.currentTargetTicket);
    inputs[inputIndex++] = ticketVector.dx;
    inputs[inputIndex++] = ticketVector.dy;

    // 2. Goal Zone Vectors (6 inputs)
    const incidentVector = toVector(zoneTargetPoint(incidentZone));
    const requestVector = toVector(zoneTargetPoint(requestZone));
    const problemVector = toVector(zoneTargetPoint(problemZone));
    inputs[inputIndex++] = incidentVector.dx;
    inputs[inputIndex++] = incidentVector.dy;
    inputs[inputIndex++] = requestVector.dx;
    inputs[inputIndex++] = requestVector.dy;
    inputs[inputIndex++] = problemVector.dx;
    inputs[inputIndex++] = problemVector.dy;

    // 3. Wall Sensor (1 input)
    let minDistToWall = Infinity;
    const distToLeft = this.x;
    const distToRight = W - this.x;
    const distToTop = this.y;
    const distToBottom = H - this.y;
    minDistToWall = Math.min(distToLeft, distToRight, distToTop, distToBottom);

    inputs[inputIndex++] = normDistWithRange(minDistToWall, effectiveRange); 

    // 4. Carrying Info (3 inputs)
    if(this.carrying) {
      inputs[inputIndex++] = this.carrying.def.id === 'incident' ? 1:0; 
      inputs[inputIndex++] = this.carrying.def.id === 'request' ? 1:0; 
      inputs[inputIndex++] = this.carrying.def.id === 'problem' ? 1:0; 
    } else {
      inputs[inputIndex++] = 0;
      inputs[inputIndex++] = 0;
      inputs[inputIndex++] = 0;
    }
    
    // 5. Status (2 inputs)
    inputs[inputIndex++] = this.energy;                   
    inputs[inputIndex++] = this.vel / CFG.maxSpeed;       

    // 6. Ticket Distance (1 input)
    inputs[inputIndex++] = ticketVector.dist;
    
    return inputs;
  }
  
  // Core Policy/Action Execution
  executeAction(policyOutputs) {
    // outputs: [Steer_Bias, Speed_Factor, Brake_Factor, Goal_INC_WT, Goal_REQ_WT, Goal_PROB_WT]
    const steerBias = policyOutputs[0]; // [-1, 1] - Left/Right preference
    const speedFactor = (policyOutputs[1] + 1) / 2; // [0, 1]
    const brakeFactor = (policyOutputs[2] + 1) / 2; // [0, 1]
    const incidentWeight = (policyOutputs[3] + 1) / 2; // [0, 1]
    const requestWeight = (policyOutputs[4] + 1) / 2; // [0, 1]
    const problemWeight = (policyOutputs[5] + 1) / 2; // [0, 1]

    // 1. Calculate Desired Steering Angle (ACO + Policy)
    let desiredAngle = this.angle;
    let turnMag = 0;
    
    // Convert target vectors to an angle
    const zones = getZones();
    const incidentZone = zones.find(z => z.id === 'incident');
    const requestZone = zones.find(z => z.id === 'request');
    const problemZone = zones.find(z => z.id === 'problem');

    let targetVec = { x: 0, y: 0 };
    if (this.carrying) {
        const correctZone = zones.find(z => z.id === this.carrying.def.id);
        if (correctZone) {
            targetVec.x = correctZone.targetX - this.x;
            targetVec.y = correctZone.targetY - this.y;
        }
    } else if (this.currentTargetTicket) {
        targetVec.x = this.currentTargetTicket.x - this.x;
        targetVec.y = this.currentTargetTicket.y - this.y;
    }

    const pheromoneType = this.carrying ? this.carrying.def.id : 'food';
    const pheromoneGrad = senseGrad(pheromoneType, this.x, this.y);
    if (pheromoneGrad.mag > 0) {
        const assistScale = CFG.smart.pheromoneAssist * CFG.sensorRange;
        targetVec.x += pheromoneGrad.gx * assistScale;
        targetVec.y += pheromoneGrad.gy * assistScale;
    }

    const targetMag = Math.hypot(targetVec.x, targetVec.y);
    
    // Weighted steering combination
    if (targetMag > 0.05) {
        desiredAngle = Math.atan2(targetVec.y, targetVec.x);
        
        // Calculate the difference between current angle and desired angle
        let angleDiff = desiredAngle - this.angle;
        angleDiff = normAngle(angleDiff * Math.PI) * Math.PI; // Normalize to [-PI, PI]
        
        turnMag = angleDiff;
    } 

    // Add Policy Steering Bias
    turnMag += steerBias * 0.5; // Policy can push the steering left/right

    // Separation steering to spread agents out
    let separationTurn = 0;
    for (const other of agents) {
        if (other === this) continue;
        const d = dist(this.x, this.y, other.x, other.y);
        if (d > 0 && d < CFG.smart.separationRadius) {
            const awayAngle = Math.atan2(this.y - other.y, this.x - other.x);
            const diff = normAngle(awayAngle - this.angle) * Math.PI;
            separationTurn += diff * ((CFG.smart.separationRadius - d) / CFG.smart.separationRadius);
        }
    }
    turnMag += separationTurn * CFG.smart.separationStrength;
    
    // Apply Turning
    this.angle += clamp(turnMag, -CFG.turnRate, CFG.turnRate);
    
    // 2. Propulsion
    let netThrust = speedFactor; // Always try to move forward based on policy output
    if (this.carrying && targetMag > 15) {
        netThrust = clamp(netThrust + 0.15, 0, 1);
    }

    if(this.energy > 0) {
        this.vel += netThrust * 0.3;
        this.energy -= CFG.energyDrain * (1 + netThrust * 2); 
    } else {
        this.stalled = true;
    }

    // 3. Braking / Friction
    if (brakeFactor > 0.1) {
        this.vel *= (1 - brakeFactor * 0.2); 
        this.energy -= CFG.energyDrain * 0.5; 
    } else {
        this.vel *= 0.92; 
    }

    this.vel = clamp(this.vel, -CFG.maxSpeed, CFG.maxSpeed);
    
    if(Math.abs(this.vel) < 0.1) {
        this.vel = 0;
        this.energy = Math.min(1, this.energy + 0.02); 
    }

    this.x += Math.cos(this.angle) * this.vel;
    this.y += Math.sin(this.angle) * this.vel;
  }

  update() {
    if(mouse.dragAgent === this || mouse.dragNest || mouse.dragZone) return; 

    if (this.carrying) {
        this.searchFrames = 0;
        this.currentTargetTicket = null;
    } else {
        this.searchFrames += 1;
        this.currentTargetTicket = this.getTargetTicket();
    }

    const prevTargetChoice = this.lastTargetChoice;
    const prevState = this.getState();
    
    // --- Policy Prediction ---
    let policyOutputs;
    let hiddens;
    let reward = 0;

    const outputs = forward(this.netRef.net, prevState, this.activationScratch);
    policyOutputs = Array.from(outputs);
    hiddens = this.activationScratch.hidden;
    
    this.lastState = prevState;
    this.lastAction = policyOutputs;
    this.lastHiddens = hiddens;
    this.lastOutputs = policyOutputs; 

    // --- Execute Action ---
    const prevX = this.x, prevY = this.y;
    const targetZone = this.carrying
        ? getZones().find(z => z.id === this.carrying?.def?.id) || null
        : null;
    const targetPoint = this.carrying
        ? (targetZone ? zoneTargetPoint(targetZone) : null)
        : (this.currentTargetTicket ? { x: this.currentTargetTicket.x, y: this.currentTargetTicket.y } : null);
    const prevTargetDistance = targetPoint ? dist(prevX, prevY, targetPoint.x, targetPoint.y) : null;
    this.executeAction(policyOutputs);
    const postX = this.x, postY = this.y;
    const postTargetDistance = targetPoint ? dist(postX, postY, targetPoint.x, targetPoint.y) : null;
    
    // --- Calculate Reward ($R_t$) ---

    const movedDist = dist(prevX, prevY, postX, postY);
    if (movedDist < 0.2) {
        this.stuckFrames += 1;
    } else {
        this.stuckFrames = 0;
    }

    if (!this.carrying) {
        this.lastTargetChoice = this.currentTargetTicket?.id ?? null;
    } else {
        this.lastTargetChoice = null;
    }

    if (!this.carrying && prevTargetChoice && this.lastTargetChoice && prevTargetChoice !== this.lastTargetChoice) {
        reward -= CFG.rewards.targetSwitchPenalty;
    }
    
    // Bounds (Wall Bounce)
    if(this.x < this.r || this.x > W-this.r || this.y < this.r || this.y > H-this.r) {
      this.x = clamp(this.x, this.r, W-this.r);
      this.y = clamp(this.y, this.r, H-this.r);
      this.vel *= -0.5;
      reward -= CFG.penalties.wall;
    }

    if(this.stalled) {
        reward -= CFG.penalties.stalled;
    }

    if (targetPoint && prevTargetDistance !== null && postTargetDistance !== null) {
        const progressDelta = prevTargetDistance - postTargetDistance;
        const normalizedProgress = clamp(progressDelta / this.getSensorRange(), -1, 1);
        reward += normalizedProgress * CFG.rewards.progressScale;
        if (progressDelta > 0.001) {
            this.progressStreak = clamp(this.progressStreak + 1, 0, 50);
            reward += this.progressStreak * CFG.rewards.progressStreak;
        } else {
            this.progressStreak = 0;
        }
    } else {
        this.progressStreak = 0;
    }

    if (this.carrying && targetZone) {
        const distToCorrect = dist(postX, postY, targetZone.targetX, targetZone.targetY);
        const correctProximity = 1 - clamp(distToCorrect / this.getSensorRange(), 0, 1);
        reward += correctProximity * CFG.rewards.nearCorrect;

        const wrongZones = getZones().filter(z => z.id !== targetZone.id);
        let nearestWrong = Infinity;
        for (const z of wrongZones) {
            const d = dist(postX, postY, z.targetX, z.targetY);
            if (d < nearestWrong) nearestWrong = d;
        }
        if (Number.isFinite(nearestWrong)) {
            const wrongProximity = 1 - clamp(nearestWrong / this.getSensorRange(), 0, 1);
            reward -= wrongProximity * CFG.rewards.nearWrong;
        }
    }
    
    // --- Interactions (Source of Major Rewards/Penalties) ---
    if(!this.carrying) {
      // Try to pick up ticket
      for(let t of tickets) {
        if(dist(this.x, this.y, t.x, t.y) < this.r + 5 && t.x > 0) {
          this.carrying = t;
          t.x = -1000;
          this.searchFrames = 0;
          this.targetTicketId = null;
          this.targetLockFrames = 0;
          this.currentTargetTicket = null;
          pushFeed(`Picked up ${t.def.label}`, 'good');
          zoneHighlight = { id: t.def.id, frame: frame }; 
          break;
        }
      }
    } else {
      // Try to drop off ticket
      const zones = getZones();
      for(let z of zones) {
        if(pointInZone(z, this.x, this.y)) {
          if(z.id === this.carrying.def.id) {
            reward += CFG.rewards.deliveryBase;
            this.energy = clamp(this.energy + 0.2, 0, 1);

            stats.solved++;
            recordRollingResult(true);
            spawnParticles(this.x, this.y, z.color, 15);
            deposit(z.id, z.targetX, z.targetY, PHEROMONE_CAP * CFG.smart.successDeposit, { spread: PHEROMONE_SPREAD });
            pushFeed(`Sorted: ${this.carrying.def.label}`, 'good');
          } else {
            reward -= CFG.penalties.wrongSort;
            stats.wrong++;
            recordRollingResult(false);
            spawnParticles(this.x, this.y, varStyles.accentBad, 8);
            pushFeed(`Wrong Zone!`, 'bad');
          }
          this.carrying.respawn();
          this.carrying = null;
          break;
        }
      }
    }

    if (this.stuckFrames > CFG.smart.stuckFrames) {
        this.angle += rand(-1.5, 1.5);
        this.vel = clamp(this.vel + 1.2, -CFG.maxSpeed, CFG.maxSpeed);
        this.energy = clamp(this.energy + 0.1, 0, 1);
        this.stuckFrames = 0;
    }
    
    this.accumulatedReward = reward; // Store for display/debugging
    this.fitness += reward; // Overall episode fitness (for finding best agent)
    

    // Trail update
    if(this === bestAgent && document.getElementById('chkTrail')?.checked) {
        this.trail.push({ x: this.x, y: this.y, alpha: 1.0 });
        if(this.trail.length > 50) this.trail.shift(); 
    } else if (this !== bestAgent) {
        this.trail = [];
    }
  }

  // Draw simplified sensor line to closest wall/ticket if enabled
  drawSensors() {
      if(!document.getElementById('chkSensors')?.checked) return;
      
      const inputs = this.lastState;
      const wallInput = inputs[13]; 
      const ticketDistInput = inputs[14]; 
      const sensorRange = this.lastSensorRange || CFG.sensorRange;

      ctx.globalAlpha = 0.5;
      ctx.lineWidth = 1;

      if (wallInput < 1) {
        const wallRange = wallInput * sensorRange;
        ctx.strokeStyle = varStyles.accentBad;
        ctx.beginPath();
        ctx.arc(this.x, this.y, wallRange, 0, Math.PI * 2);
        ctx.stroke();
      }
      
      if (ticketDistInput < 1 && ticketDistInput > 0) {
        const ticketRange = ticketDistInput * sensorRange;
        ctx.strokeStyle = varStyles.accentOk;
        ctx.beginPath();
        ctx.arc(this.x, this.y, ticketRange, 0, Math.PI * 2);
        ctx.stroke();
      }
      
      ctx.globalAlpha = 1;
  }


  draw() {
    this.drawSensors();
    if(this.carrying) this.drawCarryingLink();

    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.angle);

    // Thruster trail
    ctx.globalAlpha = 0.5;
    const flame = ctx.createLinearGradient(-this.r*2, 0, 0, 0);
    flame.addColorStop(0, 'rgba(56,189,248,0)');
    flame.addColorStop(1, 'rgba(56,189,248,0.7)');
    ctx.fillStyle = flame;
    ctx.beginPath();
    ctx.moveTo(-this.r*2.2, -2);
    ctx.lineTo(-this.r*0.8, 0);
    ctx.lineTo(-this.r*2.2, 2);
    ctx.fill();
    ctx.globalAlpha = 1;

    if(this === bestAgent) {
        ctx.save();
        ctx.rotate(-this.angle);
        ctx.globalAlpha = 0.5 + Math.sin(frame*0.15)*0.25;
        ctx.strokeStyle = '#ffd700';
        ctx.lineWidth = 2.5;
        ctx.beginPath();
        ctx.arc(0, 0, this.r + 6, 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();
    }

    let ringColor = this.energy > 0.3 ? varStyles.accentOk : (this.stalled ? varStyles.accentBad : '#ff9900');
    if(this.energy < 0.3) {
        ctx.globalAlpha = 0.5 + Math.sin(frame * 0.2) * 0.5;
        ctx.lineWidth = 3;
    } else {
        ctx.lineWidth = 1.5;
        ctx.globalAlpha = 1;
    }
    ctx.beginPath();
    ctx.arc(0, 0, this.r + 3, 0, Math.PI * 2 * this.energy);
    ctx.strokeStyle = ringColor;
    ctx.stroke();
    
    ctx.globalAlpha = 1;
    
    let agentFillColor;
    if (this.carrying) {
        agentFillColor = this.carrying.def.color;
    } else {
        const memSaturation = 50 + clamp(this.fitness / 100, 0, 100); 
        agentFillColor = `hsl(${this.teamHue}, ${memSaturation}%, 50%)`;
    }

    ctx.fillStyle = this.stalled ? '#552222' : agentFillColor;
    
    if(this === bestAgent) {
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#ffffaa';
        ctx.fillStyle = '#fff';
    }

    ctx.beginPath();
    ctx.moveTo(this.r * 1.5, 0); 
    ctx.lineTo(-this.r, this.r * 0.8); 
    ctx.lineTo(-this.r * 0.5, 0); 
    ctx.lineTo(-this.r, -this.r * 0.8); 
    ctx.closePath();
    ctx.fill();

    ctx.shadowBlur = 0;

    ctx.restore();
  }

  drawCarryingLink() {
      if(!this.carrying || this.carrying.x > -100) return; 
      
      const zones = getZones();
      const targetZone = zones.find(z => z.id === this.carrying.def.id);
      if(!targetZone) return;

      const gradient = ctx.createLinearGradient(this.x, this.y, targetZone.targetX, targetZone.targetY);
      gradient.addColorStop(0, this.carrying.def.color);
      gradient.addColorStop(1, 'rgba(255,255,255,0.05)');
      
      ctx.strokeStyle = gradient;
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]); 
      ctx.lineDashOffset = -frame * 0.5; 
      ctx.globalAlpha = 0.5;

      ctx.beginPath();
      ctx.moveTo(this.x, this.y);
      ctx.lineTo(targetZone.targetX, targetZone.targetY);
      ctx.stroke();

      ctx.setLineDash([]);
      ctx.lineDashOffset = 0;
      ctx.globalAlpha = 1;
  }
}

// --- SYSTEM ---

// Utility for roundRect (Compatibility for older browsers/environments)
if (!CanvasRenderingContext2D.prototype.roundRectPolyfill) {
    CanvasRenderingContext2D.prototype.roundRectPolyfill = function(x, y, w, h, r) {
        if (typeof r === 'number') r = { tl: r, tr: r, br: r, bl: r };
        else r = { ...{ tl: 0, tr: 0, br: 0, bl: 0 }, ...r };
        this.moveTo(x + r.tl, y);
        this.lineTo(x + w - r.tr, y);
        this.arcTo(x + w, y, x + w, y + r.tr, r.tr);
        this.lineTo(x + w, y + h - r.br);
        this.arcTo(x + w, y + h, x + w - r.br, y + h, r.br);
        this.lineTo(x + r.bl, y + h);
        this.arcTo(x, y + h, x, y + h - r.bl, r.bl);
        this.lineTo(x, y + r.tl);
        this.arcTo(x, y, x + r.tl, y, r.tl);
        this.closePath();
    };
}

const varStyles = {
    fontUi: getComputedStyle(document.documentElement).getPropertyValue('--font-ui').trim(),
    accent: getComputedStyle(document.documentElement).getPropertyValue('--accent').trim(),
    accentOk: getComputedStyle(document.documentElement).getPropertyValue('--accent-ok').trim(),
    accentBad: getComputedStyle(document.documentElement).getPropertyValue('--accent-bad').trim(),
    textDim: getComputedStyle(document.documentElement).getPropertyValue('--text-dim').trim(),
};


function getZones() {
  return goalZones;
}

function zoneTargetPoint(zone) {
  if (!zone) return null;
  return { x: zone.targetX, y: zone.targetY };
}

function getZoneBandBounds() {
  if (!goalZones.length) return { top: 140, bottom: 220 };
  const top = Math.min(...goalZones.map(z => z.y));
  const bottom = Math.max(...goalZones.map(z => z.y + z.h));
  return { top, bottom };
}

function pointInZone(zone, x, y) {
  return x >= zone.x && x <= zone.x + zone.w && y >= zone.y && y <= zone.y + zone.h;
}

function drawZones() {
  getZones().forEach(z => {
    const highlight = zoneHighlight && z.id === zoneHighlight.id && frame < zoneHighlight.frame + 30;
    const glowAlpha = highlight ? (Math.sin(frame * 0.2) + 1.5) * 0.35 : 0.25;

    ctx.save();
    ctx.beginPath();
    ctx.roundRectPolyfill(z.x, z.y, z.w, z.h, 16);
    ctx.closePath();

    const grad = ctx.createLinearGradient(z.x, z.y, z.x + z.w, z.y + z.h);
    grad.addColorStop(0, z.color + '77');
    grad.addColorStop(1, 'transparent');
    ctx.fillStyle = grad;
    ctx.globalAlpha = glowAlpha;
    ctx.fill();

    ctx.globalAlpha = 1;
    ctx.strokeStyle = z.color;
    ctx.lineWidth = highlight ? 5 : 2;
    ctx.stroke();

    if (highlight) {
      ctx.strokeStyle = '#fff';
      ctx.globalAlpha = 0.55;
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    ctx.globalAlpha = 1;
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.font = '14px ' + varStyles.fontUi;
    ctx.fillText(z.label, z.labelX, z.labelY);
    ctx.restore();
  });
  ctx.globalAlpha = 1;
}

function drawAgentTrail() {
    if(!bestAgent || !document.getElementById('chkTrail')?.checked) return;
    
    ctx.lineWidth = 2;
    ctx.beginPath();
    
    bestAgent.trail.forEach((p, i) => {
        const alpha = (i / bestAgent.trail.length) * 0.5;
        ctx.strokeStyle = `rgba(255, 215, 0, ${alpha})`;
        
        if(i === 0) ctx.moveTo(p.x, p.y);
        else {
            const prev = bestAgent.trail[i-1];
            ctx.beginPath();
            ctx.moveTo(prev.x, prev.y);
            ctx.lineTo(p.x, p.y);
            ctx.stroke();
        }
    });
    ctx.globalAlpha = 1;
}

function spawnParticles(x, y, color, count) {
    // ... (spawnParticles remains the same) ...
  if(!document.getElementById('chkParticles')?.checked) return;
  for(let i=0; i<count; i++) {
    particles.push({ 
        x, y, 
        vx: rand(-2, 2), 
        vy: rand(-2, 2), 
        life: 1.0, 
        color, 
        size: rand(2, 5) 
    });
  }
}

function updateParticles() {
    // ... (updateParticles remains the same) ...
  for(let i=particles.length-1; i>=0; i--) {
    let p = particles[i];
    p.x += p.vx * p.life; 
    p.y += p.vy * p.life;
    p.life -= 0.03; 
    if(p.life <= 0) particles.splice(i, 1);
  }
}

function drawParticles() {
    // ... (drawParticles remains the same) ...
  particles.forEach(p => {
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x, p.y, p.size, p.size);
  });
  ctx.globalAlpha = 1;
}

function drawPheromones() {
    // ... (drawPheromones remains the same) ...
  if(!document.getElementById('chkPheromones')?.checked) return;

  const maxPh = PHEROMONE_CAP;
  ctx.globalCompositeOperation = 'screen';

  for(let y=0; y<GH; y++) {
      for(let x=0; x<GW; x++) {
          const idx = gi(x,y);
          const fx = x * CS;
          const fy = y * CS;
          
          let r=0, g=0, b=0, a=0;
          let trailFound = false;

          CFG.categories.forEach(cat => {
              const val = grid[cat.id][idx];
              if(val > 0) {
                  const factor = val / maxPh * 0.6;
                  if(cat.id === 'incident') r = Math.max(r, factor * 255); 
                  if(cat.id === 'request') g = Math.max(g, factor * 255); 
                  if(cat.id === 'problem') b = Math.max(b, factor * 255); 
                  a = Math.max(a, val / maxPh * 0.4);
                  trailFound = true;
              }
          });
          
          const foodVal = grid.food[idx];
          if (foodVal > 0) {
              const factor = foodVal / maxPh * 0.4;
              r = Math.max(r, factor * 100); 
              g = Math.max(g, factor * 200); 
              b = Math.max(b, factor * 255); 
              a = Math.max(a, foodVal / maxPh * 0.3);
              trailFound = true;
          }

          if(trailFound) {
              ctx.fillStyle = `rgba(${Math.min(255, r)}, ${Math.min(255, g)}, ${Math.min(255, b)}, ${a})`;
              ctx.fillRect(fx, fy, CS, CS);
          }
      }
  }

  ctx.globalCompositeOperation = 'source-over';
}


function updateFPS(now) {
    // ... (updateFPS remains the same) ...
    if (lastFrameTime) {
        fps = 1000 / (now - lastFrameTime);
        fpsDisplay.innerText = `FPS: ${fps.toFixed(0)}`;
    }
    lastFrameTime = now;
}

function updateUI() {
  document.getElementById('hudGen').innerText = `GEN ${evo.gen}`;
  document.getElementById('dispGen').innerText = evo.gen;
  document.getElementById('dispSolved').innerText = stats.solved;
  document.getElementById('dispWrong').innerText = stats.wrong;
  
  let total = stats.solved + stats.wrong;
  let acc = total === 0 ? 0 : (stats.solved / total) * 100;
  document.getElementById('dispAcc').innerText = acc.toFixed(1) + '%';
  document.getElementById('dispAcc').style.color = acc > 80 ? varStyles.accentOk : (acc > 50 ? '#fff' : varStyles.accentBad);

  const rollingTotal = rollingResults.length;
  const rollingAcc = rollingTotal === 0
      ? 0
      : (rollingResults.reduce((sum, val) => sum + val, 0) / rollingTotal) * 100;
  document.getElementById('dispAccRolling').innerText = rollingAcc.toFixed(1) + '%';
  document.getElementById('dispAccRolling').style.color = rollingAcc > 80 ? varStyles.accentOk : (rollingAcc > 50 ? '#fff' : varStyles.accentBad);

  let stalledCount = agents.filter(a => a.stalled).length;
  stats.activeCount = agents.length - stalledCount;

  document.getElementById('dispActive').innerText = `${stats.activeCount}/${agents.length}`;
  if(bestAgent) {
      document.getElementById('dispFit').innerText = bestAgent.fitness.toFixed(2);
  }

  const progress = clamp(frame / CFG.episodeDuration, 0, 1);
  const progressFill = document.getElementById('episodeFill');
  if(progressFill) progressFill.style.width = `${(CFG.manualEpisode ? 100 : progress * 100).toFixed(1)}%`;

  // Toggle Policy Visualization visibility based on checkbox
  brainCanvas.style.display = document.getElementById('chkBrainViz').checked ? 'block' : 'none';
}

function drawBrain(agent) {
    // ... (drawBrain adapted for Policy Network) ...
    if(!document.getElementById('chkBrainViz').checked || !agent) return;
  
    const W_B = brainCanvas.width;
    const H_B = brainCanvas.height;
    brainCtx.clearRect(0, 0, W_B, H_B);
    
    const net = agent.netRef?.net;
    if(!net) return;
    const nodeR = 4; 
    
    const layerX = [W_B*0.15, W_B*0.5, W_B*0.85];
    const getY = (idx, total) => (H_B / (total + 1)) * (idx + 1);
    
    // --- DRAW CONNECTIONS ---
    brainCtx.lineWidth = 0.5; 
    
    const getLineColor = (weight, inputVal) => {
        const activation = weight * inputVal;
        const alpha = clamp(Math.abs(activation) * 0.8, 0.1, 0.6);
        return activation > 0 ? `rgba(0,255,150,${alpha})` : `rgba(255,50,50,${alpha})`;
    }

    // Input to Hidden
    for(let i=0; i<CFG.inputs; i++) {
        for(let h=0; h<CFG.hiddens; h++) {
            const w = net?.W1?.[h]?.[i];
            if(!Number.isFinite(w)) continue;
            brainCtx.strokeStyle = getLineColor(w, agent.lastState[i] || 0);
            brainCtx.beginPath(); brainCtx.moveTo(layerX[0], getY(i, CFG.inputs)); brainCtx.lineTo(layerX[1], getY(h, CFG.hiddens)); brainCtx.stroke();
        }
    }
    
    // Hidden to Output
    for(let h=0; h<CFG.hiddens; h++) {
        for(let o=0; o<CFG.outputs; o++) {
            const w = net?.W2?.[o]?.[h];
            if(!Number.isFinite(w)) continue;
            const hVal = agent.lastHiddens ? agent.lastHiddens[h] : 0;
            brainCtx.strokeStyle = getLineColor(w, hVal);
            brainCtx.beginPath(); brainCtx.moveTo(layerX[1], getY(h, CFG.hiddens)); brainCtx.lineTo(layerX[2], getY(o, CFG.outputs)); brainCtx.stroke();
        }
    }

    // --- DRAW NODES & LABELS ---
    brainCtx.globalAlpha = 1;
    brainCtx.font = '8px monospace'; 
    
    // Input Nodes (State)
    brainCtx.textAlign = 'right';
    const inputLabels = [
        'Ticket_X', 'Ticket_Y',
        'Inc_X', 'Inc_Y', 'Req_X', 'Req_Y', 'Prob_X', 'Prob_Y',
        'Carry_INC', 'Carry_REQ', 'Carry_PROB',
        'Energy', 'Speed',
        'Wall_Dist', 'Ticket_Dist'
    ];
    for(let i=0; i<CFG.inputs; i++) {
        const val = agent.lastState[i] || 0;
        const c = Math.round(clamp(val, 0, 1) * 255);
        let color = `rgb(${c}, ${c}, ${c})`;
        if (i < 4) { 
            const intensity = clamp(Math.abs(val) * 255, 0, 255);
            color = val > 0 ? `rgb(0, ${intensity}, 150)` : `rgb(${intensity}, 0, 50)`;
        }

        brainCtx.fillStyle = color;
        brainCtx.beginPath(); brainCtx.arc(layerX[0], getY(i, CFG.inputs), nodeR, 0, Math.PI*2); brainCtx.fill();
        brainCtx.fillStyle = '#94a3b8';
        brainCtx.fillText(inputLabels[i], layerX[0] - nodeR - 2, getY(i, CFG.inputs) + 2);
    }

    // Hidden Nodes
    for(let i=0; i<CFG.hiddens; i++) {
        const val = agent.lastHiddens ? agent.lastHiddens[i] : 0;
        let color = 'rgb(68, 68, 85)'; 
        if (Math.abs(val) > 0.01) {
            const intensity = clamp(Math.abs(val) * 255, 50, 255);
            color = val > 0 ? `rgb(0, ${intensity}, 150)` : `rgb(${intensity}, 0, 50)`;
        }
        brainCtx.fillStyle = color;
        brainCtx.beginPath(); brainCtx.arc(layerX[1], getY(i, CFG.hiddens), nodeR-1, 0, Math.PI*2); brainCtx.fill();
    }
    
    // Output Nodes (Action Policy)
    brainCtx.textAlign = 'left';
    const outputLabels = ['STEER_BIAS', 'SPEED_FACT', 'BRAKE_FACT', 'GOAL_INC_WT', 'GOAL_REQ_WT', 'GOAL_PROB_WT']; 
    for(let i=0; i<CFG.outputs; i++) {
        const val = agent.lastOutputs ? agent.lastOutputs[i] : 0;
        
        let color = '#fff';
        if (Math.abs(val) > 0.01) {
            const intensity = clamp(Math.abs(val) * 255, 50, 255);
            color = val > 0 ? `rgb(0, ${intensity}, 150)` : `rgb(${intensity}, 0, 50)`;
        }

        brainCtx.fillStyle = color;
        brainCtx.beginPath(); brainCtx.arc(layerX[2], getY(i, CFG.outputs), nodeR, 0, Math.PI*2); brainCtx.fill();
        
        brainCtx.fillStyle = '#94a3b8';
        brainCtx.fillText(outputLabels[i], layerX[2] + nodeR + 2, getY(i, CFG.outputs) + 2);
    }
}

function drawFitnessGraph() {
    // ... (drawFitnessGraph adapted to track best fitness) ...
  const W_G = 360, H_G = 70;
  const fitCtx = document.getElementById('fitnessGraph').getContext('2d');
  
  const canvasElement = document.getElementById('fitnessGraph');
  canvasElement.width = W_G;
  canvasElement.height = H_G;

  if(history.length < 2) { fitCtx.clearRect(0,0,W_G,H_G); return; }
  
  fitCtx.clearRect(0,0,W_G,H_G);
  const maxFit = Math.max(...history.map(h=>h.best), 1); 
  const stepX = W_G / (history.length - 1);
  
  fitCtx.strokeStyle = varStyles.accentOk;
  fitCtx.lineWidth = 2;
  fitCtx.beginPath();
  
  history.forEach((h, i) => {
    // Clamp to 1.0 to avoid graph jumping too high initially
    const y = H_G - (h.best / maxFit * H_G * 0.9 + 5); 
    if(i===0) fitCtx.moveTo(0, y); else fitCtx.lineTo(i*stepX, y);
  });
  fitCtx.stroke();
}


function pushFeed(msg, type='normal') {
    // ... (pushFeed remains the same) ...
  const el = document.getElementById('feed');
  const div = document.createElement('div');
  div.className = `feed-item ${type}`;
  div.innerText = msg;
  el.prepend(div);
  if(el.children.length > 6) el.lastChild.remove();
}

function updateHoverTip(e) {
    // ... (updateHoverTip adapted for fitness) ...
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    let hoveredAgent = null;
    for(let a of agents) {
        if(dist(a.x, a.y, x, y) < a.r * 2) {
            hoveredAgent = a;
            break;
        }
    }
    
    if (hoveredAgent) {
        hoverTip.style.opacity = 1;
        hoverTip.style.left = `${e.clientX}px`;
        hoverTip.style.top = `${e.clientY}px`;
        hoverTip.innerHTML = `
            <strong>Status:</strong><br>
            Episode Fitness: <span style="color:var(--accent-ok)">${hoveredAgent.fitness.toFixed(2)}</span><br>
            Energy: <span style="color:${hoveredAgent.energy > 0.3 ? '#0f0' : '#ff9900'}">${(hoveredAgent.energy * 100).toFixed(0)}%</span><br>
            Speed: ${hoveredAgent.vel.toFixed(1)} / ${CFG.maxSpeed}<br>
            Carrying: ${hoveredAgent.carrying ? hoveredAgent.carrying.def.label : 'None'}
        `;
    } else {
        hoverTip.style.opacity = 0;
    }
}

function buildGoalZones() {
  const zoneMargin = 40;
  const zoneGap = 24;
  const placements = CFG.goalPlacements || {};
  const scale = CFG.goalScale || 1;
  const groups = { top: [], bottom: [], left: [], right: [] };

  CFG.categories.forEach(cat => {
      const placement = placements[cat.id] || 'top';
      if (!groups[placement]) groups[placement] = [];
      groups[placement].push(cat);
  });

  const buildZonesForEdge = (placement, cats) => {
      if (!cats.length) return [];

      if (placement === 'left' || placement === 'right') {
          const zoneCount = cats.length;
          const availableHeight = H - zoneMargin * 2 - zoneGap * (zoneCount - 1);
          const baseHeight = Math.max(110, availableHeight / zoneCount);
          const baseWidth = Math.max(140, Math.min(200, W * 0.22));
          const zoneHeight = Math.max(80, baseHeight * scale);
          const zoneWidth = Math.max(110, baseWidth * scale);
          const totalHeight = zoneHeight * zoneCount + zoneGap * (zoneCount - 1);
          const startY = Math.max(zoneMargin, (H - totalHeight) / 2);
          const x = placement === 'left' ? zoneMargin : W - zoneMargin - zoneWidth;

          return cats.map((cat, idx) => {
              const y = startY + idx * (zoneHeight + zoneGap);
              return {
                  id: cat.id,
                  color: cat.color,
                  label: cat.label.replace(' Req', ''),
                  x,
                  y,
                  w: zoneWidth,
                  h: zoneHeight,
                  labelX: x + zoneWidth / 2,
                  labelY: y + zoneHeight / 2 + 4,
                  targetX: x + zoneWidth / 2,
                  targetY: y + zoneHeight / 2
              };
          });
      }

      const zoneCount = cats.length;
      const baseHeight = Math.max(110, Math.min(150, H * 0.18));
      const availableWidth = W - zoneMargin * 2 - zoneGap * (zoneCount - 1);
      const baseWidth = Math.max(140, availableWidth / zoneCount);
      const zoneHeight = Math.max(80, baseHeight * scale);
      const zoneWidth = Math.max(110, baseWidth * scale);
      const totalWidth = zoneWidth * zoneCount + zoneGap * (zoneCount - 1);
      const startX = Math.max(zoneMargin, (W - totalWidth) / 2);
      const y = placement === 'bottom' ? H - zoneMargin - zoneHeight : zoneMargin + 20;

      return cats.map((cat, idx) => {
          const x = startX + idx * (zoneWidth + zoneGap);
          return {
              id: cat.id,
              color: cat.color,
              label: cat.label.replace(' Req', ''),
              x,
              y,
              w: zoneWidth,
              h: zoneHeight,
              labelX: x + zoneWidth / 2,
              labelY: y + zoneHeight / 2 + 4,
              targetX: x + zoneWidth / 2,
              targetY: y + zoneHeight / 2
          };
      });
  };

  return [
      ...buildZonesForEdge('top', groups.top),
      ...buildZonesForEdge('bottom', groups.bottom),
      ...buildZonesForEdge('left', groups.left),
      ...buildZonesForEdge('right', groups.right)
  ];
}

function updateLearnReadouts() {
  document.getElementById('lbGenSteps').innerText = params.learn.genSteps;
  document.getElementById('lbHidden').innerText = params.learn.hidden;
  document.getElementById('lbMut').innerText = `${Math.round(params.learn.mut * 100)}%`;
  document.getElementById('lbElite').innerText = `${Math.round(params.learn.elite * 100)}%`;
  document.getElementById('lbMutStrengthW').innerText = params.learn.mutStrengthW.toFixed(2);
  document.getElementById('lbMutStrengthB').innerText = params.learn.mutStrengthB.toFixed(2);
  document.getElementById('lbCrossover').innerText = `${Math.round(params.learn.crossoverBias * 100)}% A`;
  document.getElementById('lbTournament').innerText = `×${params.learn.tournamentFactor.toFixed(1)}`;
  document.getElementById('lbFresh').innerText = `${Math.round(params.learn.fresh * 100)}%`;
  document.getElementById('lbAuto').innerText = params.learn.auto ? 'on' : 'off';
}

function syncLearnParams() {
  params.learn.genSteps = parseInt(document.getElementById('slGenSteps').value);
  params.learn.mut = parseInt(document.getElementById('slMut').value) / 100;
  params.learn.elite = parseInt(document.getElementById('slElite').value) / 100;
  params.learn.mutStrengthW = parseInt(document.getElementById('slMutStrengthW').value) / 100;
  params.learn.mutStrengthB = parseInt(document.getElementById('slMutStrengthB').value) / 100;
  params.learn.crossoverBias = parseInt(document.getElementById('slCrossover').value) / 100;
  params.learn.tournamentFactor = parseInt(document.getElementById('slTournament').value) / 10;
  params.learn.fresh = parseInt(document.getElementById('slFresh').value) / 100;
  params.learn.auto = document.getElementById('chkAuto').checked;

  CFG.episodeDuration = params.learn.genSteps;
  document.getElementById('slDuration').value = params.learn.genSteps;
  document.getElementById('valDuration').innerText = params.learn.genSteps;

  const newHiddens = parseInt(document.getElementById('slHidden').value);
  const clampedHidden = clamp(newHiddens, NET_HIDDEN_MIN, NET_HIDDEN_MAX);
  const topologyChanged = clampedHidden !== NET_HIDDEN;
  NET_HIDDEN = clampedHidden;
  CFG.hiddens = clampedHidden;
  params.learn.hidden = clampedHidden;

  updateLearnReadouts();
  return topologyChanged;
}

function rebuildAgentsFromPopulation() {
  agents = evo.population.map((member)=> new Agent(member));
  bestAgent = agents[0] || null;
}


// --- MAIN LOOP ---
function init(resetPolicyWeights = true) {
  W = canvas.width = canvas.parentElement.offsetWidth;
  H = canvas.height = canvas.parentElement.offsetHeight;
  
  brainCanvas.width = 300;
  brainCanvas.height = 150;
  
  const nestY = H * 0.62;
  if (!nest) { 
      nest = new Nest(W / 2, nestY);
  } else {
       nest.x = W / 2; nest.y = nestY;
  }
  
  // Set CFG from Sliders
  speedMult = parseInt(document.getElementById('slSpeed').value);
  document.getElementById('valSpeed').innerText = `${speedMult}x`;
  CFG.popSize = parseInt(document.getElementById('slPop').value); 
  CFG.ticketCount = parseInt(document.getElementById('slTicketCount').value); 
  CFG.ticketSpawn.layout = document.getElementById('slTicketLayout').value;
  CFG.ticketSpawn.grouping = document.getElementById('slTicketGrouping').value;
  CFG.ticketSpawn.minGoalDistance = parseInt(document.getElementById('slTicketGoalBuffer').value);
  CFG.goalScale = parseInt(document.getElementById('slGoalScale').value) / 100;
  CFG.goalPlacements = {
      incident: document.getElementById('slGoalPlacementIncident').value,
      request: document.getElementById('slGoalPlacementRequest').value,
      problem: document.getElementById('slGoalPlacementProblem').value
  };
  CFG.manualEpisode = document.getElementById('chkManualEpisode').checked;
  CFG.penalties.wall = parseInt(document.getElementById('slPenaltyWall').value);
  CFG.penalties.stalled = parseInt(document.getElementById('slPenaltyStalled').value) / 10;
  CFG.penalties.wrongSort = parseInt(document.getElementById('slPenaltyWrong').value);
  CFG.rewards.move = parseInt(document.getElementById('slRewardMove').value) / 100;
  CFG.rewards.curiosity = parseInt(document.getElementById('slRewardCuriosity').value) / 100;
  CFG.rewards.progressScale = parseInt(document.getElementById('slRewardProgressScale').value) / 100;
  CFG.rewards.progressStreak = parseInt(document.getElementById('slRewardStreak').value) / 100;
  CFG.rewards.pickup = parseInt(document.getElementById('slRewardPickup').value);
  CFG.rewards.deliveryBase = parseInt(document.getElementById('slRewardDeliveryBase').value);
  CFG.rewards.deliveryEnergy = parseInt(document.getElementById('slRewardDeliveryEnergy').value);
  CFG.rewards.nearCorrect = parseInt(document.getElementById('slRewardNearCorrect').value) / 100;
  CFG.rewards.nearWrong = parseInt(document.getElementById('slPenaltyNearWrong').value) / 100;
  CFG.rewards.targetSwitchPenalty = parseInt(document.getElementById('slPenaltyTargetSwitch').value) / 100;

  document.getElementById('valPenaltyWall').innerText = `-${CFG.penalties.wall}`;
  document.getElementById('valPenaltyStalled').innerText = `-${CFG.penalties.stalled.toFixed(1)}`;
  document.getElementById('valPenaltyWrong').innerText = `-${CFG.penalties.wrongSort}`;
  document.getElementById('valRewardMove').innerText = CFG.rewards.move.toFixed(2);
  document.getElementById('valRewardCuriosity').innerText = CFG.rewards.curiosity.toFixed(2);
  document.getElementById('valRewardProgressScale').innerText = CFG.rewards.progressScale.toFixed(2);
  document.getElementById('valRewardStreak').innerText = CFG.rewards.progressStreak.toFixed(2);
  document.getElementById('valRewardPickup').innerText = CFG.rewards.pickup;
  document.getElementById('valRewardDeliveryBase').innerText = CFG.rewards.deliveryBase;
  document.getElementById('valRewardDeliveryEnergy').innerText = CFG.rewards.deliveryEnergy;
  document.getElementById('valRewardNearCorrect').innerText = CFG.rewards.nearCorrect.toFixed(2);
  document.getElementById('valPenaltyNearWrong').innerText = `-${CFG.rewards.nearWrong.toFixed(2)}`;
  document.getElementById('valPenaltyTargetSwitch').innerText = `-${CFG.rewards.targetSwitchPenalty.toFixed(2)}`;
  document.getElementById('valGoalScale').innerText = `${Math.round(CFG.goalScale * 100)}%`;
  document.getElementById('valTicketGoalBuffer').innerText = `${CFG.ticketSpawn.minGoalDistance}px`;

  const topologyChanged = syncLearnParams();
  if (topologyChanged) {
      pushFeed(`Topology updated. Rebuilding Policy Networks...`, 'warn');
      resetPolicyWeights = true; // Force weight reset on topology change
  }

  PHEROMONE_DECAY = parseInt(document.getElementById('slDecay').value) / 1000;

  goalZones = buildGoalZones();
  makeGrid(); 

  // Agent Initialization Logic
  const sizeChanged = evo.population.length !== CFG.popSize;
  if(sizeChanged || topologyChanged || resetPolicyWeights) {
      if(resetPolicyWeights || topologyChanged || sizeChanged) {
          evo.gen = 1;
          evo.population = makePopulation(CFG.popSize);
          bestBrainState.fitness = -Infinity;
          bestBrainState.net = null;
      }
      rebuildAgentsFromPopulation();
  } else {
      // Keep weights, just reset episode state
      resetEpisode({ evolve: false });
  }

  if(resetPolicyWeights) {
      episode = 1; 
      history = []; 
  }
  
  tickets = [];
  for(let i=0; i<CFG.ticketCount; i++) tickets.push(new Ticket(i));
  
  if(!requestAnimationFrame.isLooping) {
      requestAnimationFrame.isLooping = true;
      requestAnimationFrame(loop);
  }
}

function resetAgentState(agent){
  agent.x = nest.x;
  agent.y = nest.y;
  agent.angle = rand(0, Math.PI*2);
  agent.vel = 0;
  agent.carrying = null;
  agent.energy = 1.0;
  agent.fitness = 0;
  agent.stalled = false;
  agent.trail = [];
  agent.stuckFrames = 0;
  agent.searchFrames = 0;
  agent.progressStreak = 0;
  agent.visitedCells = new Set();
  agent.lastTargetChoice = null;
  agent.lastTargetDistance = null;
  agent.activationScratch = { input: [], hidden: [], output: [], timestamp: 0 };
}

function getAdaptiveMutationRate() {
  const baseMut = params.learn.mut;
  const rollingTotal = rollingResults.length;
  if (rollingTotal < 50) return baseMut;
  const rollingAcc = rollingResults.reduce((sum, val) => sum + val, 0) / rollingTotal;
  if (rollingAcc >= 0.98) return clamp(baseMut * 0.4, 0.02, 0.25);
  if (rollingAcc <= 0.8) return clamp(baseMut * 1.5, 0.05, 0.6);
  return baseMut;
}

function evolvePopulation() {
  const pop = evo.population;
  if(!pop.length) return;
  pop.sort((a, b) => b.fitness - a.fitness);
  const eliteN = Math.max(1, Math.floor(pop.length * params.learn.elite));
  const elites = pop.slice(0, eliteN).map((e)=> cloneNet(e.net));
  const tournamentFactor = Math.max(1, params.learn.tournamentFactor || 1);
  const freshRatio = clamp(params.learn.fresh || 0, 0, 1);
  const newPop = [];
  for(let i = 0; i < eliteN; i++) newPop.push({ net: cloneNet(elites[i]), fitness: 0 });
  const adaptiveMut = getAdaptiveMutationRate();

  function pick(){
    const k = Math.min(pop.length, Math.max(2, Math.round(eliteN * tournamentFactor)));
    const a = pop[Math.floor(Math.random() * k)];
    const b = pop[Math.floor(Math.random() * k)];
    return (a.fitness > b.fitness ? a : b).net;
  }

  while(newPop.length < pop.length){
    const pa = pick();
    const pb = pick();
    let child = crossover(pa, pb);
    mutateNet(child, adaptiveMut);
    newPop.push({ net: child, fitness: 0 });
  }

  const freshCount = Math.min(pop.length - eliteN, Math.max(0, Math.round(pop.length * freshRatio)));
  for(let i = 0; i < freshCount; i++){
    newPop[newPop.length - 1 - i] = { net: makeNet(), fitness: 0 };
  }

  for(let i = 0; i < pop.length; i++){
    pop[i].net = newPop[i].net;
    pop[i].fitness = 0;
  }
}

function resetEpisode({ evolve = true } = {}) {
  const pop = evo.population;
  pop.forEach((member, idx)=>{
    member.fitness = agents[idx]?.fitness ?? 0;
  });
  pop.sort((a, b) => b.fitness - a.fitness);
  const bestFitness = pop[0]?.fitness || 0;

  if(bestFitness > 0) {
    history.push({
      episode: evo.gen,
      best: bestFitness
    });
  }

  if(evolve) {
    evolvePopulation();
    evo.gen++;
    bestBrainState.fitness = -Infinity;
    bestBrainState.net = null;
  }

  agents.forEach((agent, idx)=>{
    agent.netRef = pop[idx];
    resetAgentState(agent);
  });

  bestAgent = agents[0] || null;
  episode = evo.gen;
  frame = 0;
  stats.solved = 0;
  stats.wrong = 0;

  makeGrid();
  tickets.forEach(t => t.respawn());
  pushFeed(`--- NEW GENERATION (${evo.gen}) ---`);
}

function serializeNet(net){
  return {
    W1: net.W1.map(r => r.slice()),
    b1: net.b1.slice(),
    W2: net.W2.map(r => r.slice()),
    b2: net.b2.slice()
  };
}

function exportTrainingSnapshot(){
  return {
    learn: { ...params.learn },
    evo: {
      gen: evo.gen,
      population: evo.population.map((member)=>({
        net: serializeNet(member.net),
        fitness: member.fitness
      }))
    }
  };
}

function applyTrainingSnapshot(snapshot){
  if(!snapshot || typeof snapshot !== 'object') return;
  const learn = snapshot.learn || {};
  if(learn.genSteps != null) params.learn.genSteps = Number(learn.genSteps);
  if(learn.hidden != null) params.learn.hidden = Number(learn.hidden);
  if(learn.mut != null) params.learn.mut = Number(learn.mut);
  if(learn.elite != null) params.learn.elite = Number(learn.elite);
  if(learn.mutStrengthW != null) params.learn.mutStrengthW = Number(learn.mutStrengthW);
  if(learn.mutStrengthB != null) params.learn.mutStrengthB = Number(learn.mutStrengthB);
  if(learn.crossoverBias != null) params.learn.crossoverBias = Number(learn.crossoverBias);
  if(learn.tournamentFactor != null) params.learn.tournamentFactor = Number(learn.tournamentFactor);
  if(learn.fresh != null) params.learn.fresh = Number(learn.fresh);
  if(learn.auto !== undefined) params.learn.auto = !!learn.auto;

  NET_HIDDEN = clamp(params.learn.hidden || NET_HIDDEN, NET_HIDDEN_MIN, NET_HIDDEN_MAX);
  params.learn.hidden = NET_HIDDEN;
  CFG.hiddens = NET_HIDDEN;
  CFG.episodeDuration = params.learn.genSteps;
  document.getElementById('slGenSteps').value = params.learn.genSteps;
  document.getElementById('slHidden').value = NET_HIDDEN;
  document.getElementById('slMut').value = Math.round(params.learn.mut * 100);
  document.getElementById('slElite').value = Math.round(params.learn.elite * 100);
  document.getElementById('slMutStrengthW').value = Math.round(params.learn.mutStrengthW * 100);
  document.getElementById('slMutStrengthB').value = Math.round(params.learn.mutStrengthB * 100);
  document.getElementById('slCrossover').value = Math.round(params.learn.crossoverBias * 100);
  document.getElementById('slTournament').value = Math.round(params.learn.tournamentFactor * 10);
  document.getElementById('slFresh').value = Math.round(params.learn.fresh * 100);
  document.getElementById('chkAuto').checked = params.learn.auto;
  document.getElementById('slDuration').value = params.learn.genSteps;
  document.getElementById('valDuration').innerText = params.learn.genSteps;
  updateLearnReadouts();

  const evoData = snapshot.evo || snapshot;
  if(Array.isArray(evoData.population)){
    evo.population = evoData.population.map((member)=>{
      const netData = member.net || {};
      const net = {
        W1: Array.isArray(netData.W1) ? netData.W1.map(r => r.slice()) : [],
        b1: Array.isArray(netData.b1) ? netData.b1.slice() : [],
        W2: Array.isArray(netData.W2) ? netData.W2.map(r => r.slice()) : [],
        b2: Array.isArray(netData.b2) ? netData.b2.slice() : []
      };
      ensureNetHiddenSize(net, NET_HIDDEN);
      ensureNetInputSize(net, NET_INPUTS);
      ensureNetOutputSize(net, NET_OUTPUTS);
      return { net, fitness: Number(member.fitness) || 0 };
    });
    evo.gen = Number(evoData.gen) || 1;
  }

  CFG.popSize = evo.population.length;
  document.getElementById('slPop').value = CFG.popSize;
  document.getElementById('valPop').innerText = CFG.popSize;
  bestBrainState.fitness = -Infinity;
  bestBrainState.net = null;
  history = [];
  rebuildAgentsFromPopulation();
  resetEpisode({ evolve: false });
}

function getTicketSpawnAreas() {
    const margin = 60;
    const zoneBand = getZoneBandBounds();
    const top = Math.min(zoneBand.bottom + 40, H * 0.55);
    const bottom = H - 80;
    const left = margin;
    const right = W - margin;

    if (CFG.ticketSpawn.layout === 'lanes') {
        const laneWidth = (right - left) / 3;
        return [
            { xMin: left, xMax: left + laneWidth, yMin: top, yMax: bottom },
            { xMin: left + laneWidth, xMax: left + laneWidth * 2, yMin: top, yMax: bottom },
            { xMin: left + laneWidth * 2, xMax: right, yMin: top, yMax: bottom }
        ];
    }

    if (CFG.ticketSpawn.layout === 'corners') {
        const clusterW = (right - left) * 0.32;
        const clusterH = (bottom - top) * 0.28;
        return [
            { xMin: left, xMax: left + clusterW, yMin: top, yMax: top + clusterH },
            { xMin: right - clusterW, xMax: right, yMin: top, yMax: top + clusterH },
            { xMin: left, xMax: left + clusterW, yMin: bottom - clusterH, yMax: bottom },
            { xMin: right - clusterW, xMax: right, yMin: bottom - clusterH, yMax: bottom }
        ];
    }

    return [{ xMin: left, xMax: right, yMin: top, yMax: bottom }];
}

function getTicketSpawnPoint(typeIdx, spawnIndex = 0, totalCount = CFG.ticketCount) {
    const minGoalDistance = CFG.ticketSpawn.minGoalDistance || 0;
    const spawnInCircle = () => {
        const count = Math.max(1, totalCount);
        const angle = (Math.PI * 2 / count) * spawnIndex;
        const radius = Math.min(W, H) * 0.18;
        const jitter = Math.min(12, radius * 0.08);
        const centerX = W / 2;
        const centerY = H / 2;
        return {
            x: centerX + Math.cos(angle) * (radius + rand(-jitter, jitter)),
            y: centerY + Math.sin(angle) * (radius + rand(-jitter, jitter))
        };
    };

    const spawnInArea = () => {
        const areas = getTicketSpawnAreas();
        let areaIndex = Math.floor(Math.random() * areas.length);

        if (CFG.ticketSpawn.grouping === 'grouped') {
            areaIndex = typeIdx % areas.length;
        }

        const area = areas[areaIndex];
        return {
            x: rand(area.xMin, area.xMax),
            y: rand(area.yMin, area.yMax)
        };
    };

    const isFarFromGoals = (point) => {
        if (minGoalDistance <= 0 || !goalZones.length) return true;
        return goalZones.every((zone) => dist(point.x, point.y, zone.targetX, zone.targetY) >= minGoalDistance);
    };

    const spawnCandidate = () => {
        if (CFG.ticketSpawn.layout === 'circle') {
            return spawnInCircle();
        }
        return spawnInArea();
    };

    let candidate = spawnCandidate();
    if (minGoalDistance <= 0) {
        return candidate;
    }

    for (let attempt = 0; attempt < 40; attempt++) {
        candidate = spawnCandidate();
        if (isFarFromGoals(candidate)) {
            return candidate;
        }
    }

    return candidate;
}

function loop(now) {
  updateFPS(now);

  if(!paused) {
    // 1. Global Pheromone Update
    evaporate();
    
    for(let n=0; n<speedMult; n++) {
      frame++;
      
      if(!CFG.manualEpisode && frame > CFG.episodeDuration) { resetEpisode({ evolve: params.learn.auto }); break; }
      
      tickets.forEach(t => { t.update(); });
      
      let currentBest = bestAgent;
      let maxFitness = bestAgent ? bestAgent.fitness : -Infinity;

      agents.forEach(a => {
        a.update();
        if(a.fitness > maxFitness) { maxFitness = a.fitness; currentBest = a; }
      });
      
      goalZones.forEach(z => {
        deposit(z.id, z.targetX, z.targetY, PHEROMONE_CAP * CFG.smart.zoneDeposit, { spread: PHEROMONE_SPREAD });
      });

      agents.forEach(a => {
        const leadType = a.carrying ? a.carrying.def.id : 'food';
        deposit(leadType, a.x, a.y, PHEROMONE_CAP * CFG.smart.agentDeposit, { spread: PHEROMONE_SPREAD });
      });

      // Update bestAgent continuously based on fitness
      bestAgent = currentBest;
      if (bestAgent) {
          const leadType = bestAgent.carrying ? bestAgent.carrying.def.id : 'food';
          deposit(leadType, bestAgent.x, bestAgent.y, PHEROMONE_CAP * CFG.smart.leaderDeposit, { spread: PHEROMONE_SPREAD });
          if(bestAgent.netRef?.net) {
              if(bestAgent.fitness > bestBrainState.fitness) {
                  bestBrainState.fitness = bestAgent.fitness;
                  bestBrainState.gen = evo.gen;
                  bestBrainState.net = cloneNet(bestAgent.netRef.net);
              }
              bestBrainState.activations = bestAgent.activationScratch;
          }
      }
      updateParticles();
      
      // Drag logic
      if(mouse.dragAgent) {
        mouse.dragAgent.x = mouse.x; mouse.dragAgent.y = mouse.y; mouse.dragAgent.vel = 0;
      }
    }
    
    // --- DRAWING ---
    ctx.clearRect(0, 0, W, H);
    
    drawAgentTrail(); 
    drawPheromones(); 
    drawZones();
    nest.draw(); 
    tickets.forEach(t => { t.draw(); });
    agents.forEach(a => { a.draw(); });
    drawParticles();
  }
  
  drawBrain(bestAgent);
  drawFitnessGraph();
  updateUI();
  requestAnimationFrame(loop);
}

// --- EVENT LISTENERS ---
window.addEventListener('resize', () => { 
    W = canvas.width = canvas.parentElement.offsetWidth; 
    H = canvas.height = canvas.parentElement.offsetHeight; 
    if(nest) {
        nest.x = W / 2; nest.y = H * 0.62;
    } 
    init(false); 
});

canvas.addEventListener('mousedown', e => {
    // ... (Mouse listeners remain the same) ...
  const rect = canvas.getBoundingClientRect();
  mouse.x = e.clientX - rect.left; mouse.y = e.clientY - rect.top;
  mouse.down = true;
  
  if (dist(nest.x, nest.y, mouse.x, mouse.y) < nest.r) {
    mouse.dragNest = true;
  } else {
    const hit = agents.find(a => dist(a.x, a.y, mouse.x, mouse.y) < 20);
    if(hit) mouse.dragAgent = hit;
  }
});

canvas.addEventListener('mousemove', e => { 
    // ... (Mouse listeners remain the same) ...
  const rect = canvas.getBoundingClientRect(); 
  mouse.x = e.clientX - rect.left; mouse.y = e.clientY - rect.top; 
  
  if(mouse.dragNest) {
      nest.x = clamp(mouse.x, nest.r, W - nest.r);
      nest.y = clamp(mouse.y, nest.r, H - nest.r);
      makeGrid(); 
  }
  updateHoverTip(e);
});

canvas.addEventListener('mouseup', () => { 
    // ... (Mouse listeners remain the same) ...
  mouse.down = false; 
  mouse.dragAgent = null; 
  mouse.dragNest = false; 
  mouse.dragZone = null; 
  hoverTip.style.opacity = 0; 
});

// Buttons & Keyboard
document.getElementById('btnSkip').onclick = () => { 
    if(paused) paused = false; 
    resetEpisode({ evolve: params.learn.auto });
};

document.getElementById('btnResetAI').onclick = () => { 
    evo.gen = 1;
    evo.population = makePopulation(CFG.popSize);
    bestBrainState.fitness = -Infinity;
    bestBrainState.net = null;
    history = [];
    rebuildAgentsFromPopulation();
    resetEpisode({ evolve: false });
    pushFeed('Training Reset: Agents must learn from scratch.', 'bad'); 
};
document.getElementById('btnReset').onclick = () => { 
    init(true); 
    pushFeed('Hard Reset: All settings and AI reset', 'danger'); 
};

document.getElementById('btnNextGen').onclick = () => {
    if(paused) paused = false;
    resetEpisode({ evolve: true });
};

document.getElementById('btnResetTraining').onclick = () => {
    evo.gen = 1;
    evo.population = makePopulation(CFG.popSize);
    bestBrainState.fitness = -Infinity;
    bestBrainState.net = null;
    history = [];
    rebuildAgentsFromPopulation();
    resetEpisode({ evolve: false });
    pushFeed('Training Reset: Generation reset to 1.', 'warn');
};

document.getElementById('btnSaveTraining').onclick = () => {
    const data = exportTrainingSnapshot();
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `data-sorting-training-gen-${String(evo.gen).padStart(3, '0')}.json`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
    pushFeed('Training snapshot saved.', 'good');
};

document.getElementById('btnLoadTraining').onclick = () => {
    document.getElementById('inputLoadTraining').click();
};

document.getElementById('inputLoadTraining').onchange = (e) => {
    const file = e.target.files?.[0];
    if(!file) return;
    const reader = new FileReader();
    reader.onload = () => {
        const data = JSON.parse(reader.result);
        applyTrainingSnapshot(data);
        pushFeed('Training snapshot loaded.', 'good');
    };
    reader.readAsText(file);
    e.target.value = '';
};

document.addEventListener('keydown', e => { 
    if(e.code === 'Space') { 
        paused = !paused; 
        pushFeed(paused ? 'Paused' : 'Unpaused', 'warn'); 
    }
    if(e.code === 'KeyS') document.getElementById('btnSkip').click(); 
});

// Sliders Logic
document.getElementById('slSpeed').oninput = (e) => { speedMult = parseInt(e.target.value); document.getElementById('valSpeed').innerText = speedMult + 'x'; };

document.getElementById('slPop').oninput = (e) => { 
    document.getElementById('valPop').innerText = e.target.value; 
    CFG.popSize = parseInt(e.target.value);
    init(false); 
};

document.getElementById('slTicketCount').oninput = (e) => { 
    CFG.ticketCount = parseInt(e.target.value); 
    document.getElementById('valTickets').innerText = CFG.ticketCount; 
    tickets = [];
    for(let i=0; i<CFG.ticketCount; i++) tickets.push(new Ticket(i));
};

document.getElementById('slTicketGoalBuffer').oninput = (e) => {
    CFG.ticketSpawn.minGoalDistance = parseInt(e.target.value);
    document.getElementById('valTicketGoalBuffer').innerText = `${CFG.ticketSpawn.minGoalDistance}px`;
    tickets.forEach(t => t.respawn());
};

document.getElementById('slTicketLayout').onchange = (e) => {
    CFG.ticketSpawn.layout = e.target.value;
    tickets.forEach(t => t.respawn());
};

document.getElementById('slTicketGrouping').onchange = (e) => {
    CFG.ticketSpawn.grouping = e.target.value;
    tickets.forEach(t => t.respawn());
};

document.getElementById('slGoalScale').oninput = (e) => {
    CFG.goalScale = parseInt(e.target.value) / 100;
    document.getElementById('valGoalScale').innerText = `${Math.round(CFG.goalScale * 100)}%`;
    goalZones = buildGoalZones();
    tickets.forEach(t => t.respawn());
};

const goalPlacementInputs = {
    incident: document.getElementById('slGoalPlacementIncident'),
    request: document.getElementById('slGoalPlacementRequest'),
    problem: document.getElementById('slGoalPlacementProblem')
};

Object.entries(goalPlacementInputs).forEach(([key, input]) => {
    input.onchange = (e) => {
        CFG.goalPlacements[key] = e.target.value;
        goalZones = buildGoalZones();
        tickets.forEach(t => t.respawn());
    };
});

document.getElementById('slDuration').oninput = (e) => { 
    const val = parseInt(e.target.value);
    document.getElementById('slGenSteps').value = val;
    params.learn.genSteps = val;
    CFG.episodeDuration = val;
    document.getElementById('valDuration').innerText = val;
    document.getElementById('lbGenSteps').innerText = val;
};

document.getElementById('chkManualEpisode').onchange = (e) => {
    CFG.manualEpisode = e.target.checked;
};

document.getElementById('slSensor').oninput = (e) => { 
    CFG.sensorRange = parseInt(e.target.value); 
    document.getElementById('valSensor').innerText = CFG.sensorRange + 'px'; 
};

document.getElementById('slDrain').oninput = (e) => { 
    let val = parseInt(e.target.value);
    CFG.energyDrain = val * 0.0001; 
    let label = val < 5 ? 'Low' : (val > 15 ? 'Extreme' : 'Normal');
    document.getElementById('valDrain').innerText = label; 
};

document.getElementById('slDecay').oninput = (e) => { 
    let val = parseInt(e.target.value);
    PHEROMONE_DECAY = val / 1000; 
    document.getElementById('valDecay').innerText = PHEROMONE_DECAY.toFixed(3); 
};

document.getElementById('slHidden').oninput = (e) => { 
    const val = parseInt(e.target.value);
    document.getElementById('lbHidden').innerText = val;
    params.learn.hidden = val;
    pushFeed('Hidden Nodes changed. Reset training to rebuild networks.', 'warn');
};

document.getElementById('slGenSteps').oninput = (e) => {
    const val = parseInt(e.target.value);
    params.learn.genSteps = val;
    CFG.episodeDuration = val;
    document.getElementById('lbGenSteps').innerText = val;
    document.getElementById('valDuration').innerText = val;
    document.getElementById('slDuration').value = val;
};

document.getElementById('slMut').oninput = (e) => {
    params.learn.mut = parseInt(e.target.value) / 100;
    document.getElementById('lbMut').innerText = `${Math.round(params.learn.mut * 100)}%`;
};

document.getElementById('slElite').oninput = (e) => {
    params.learn.elite = parseInt(e.target.value) / 100;
    document.getElementById('lbElite').innerText = `${Math.round(params.learn.elite * 100)}%`;
};

document.getElementById('slMutStrengthW').oninput = (e) => {
    params.learn.mutStrengthW = parseInt(e.target.value) / 100;
    document.getElementById('lbMutStrengthW').innerText = params.learn.mutStrengthW.toFixed(2);
};

document.getElementById('slMutStrengthB').oninput = (e) => {
    params.learn.mutStrengthB = parseInt(e.target.value) / 100;
    document.getElementById('lbMutStrengthB').innerText = params.learn.mutStrengthB.toFixed(2);
};

document.getElementById('slCrossover').oninput = (e) => {
    params.learn.crossoverBias = parseInt(e.target.value) / 100;
    document.getElementById('lbCrossover').innerText = `${Math.round(params.learn.crossoverBias * 100)}% A`;
};

document.getElementById('slTournament').oninput = (e) => {
    params.learn.tournamentFactor = parseInt(e.target.value) / 10;
    document.getElementById('lbTournament').innerText = `×${params.learn.tournamentFactor.toFixed(1)}`;
};

document.getElementById('slFresh').oninput = (e) => {
    params.learn.fresh = parseInt(e.target.value) / 100;
    document.getElementById('lbFresh').innerText = `${Math.round(params.learn.fresh * 100)}%`;
};

document.getElementById('chkAuto').onchange = (e) => {
    params.learn.auto = e.target.checked;
    document.getElementById('lbAuto').innerText = params.learn.auto ? 'on' : 'off';
};

document.getElementById('slPenaltyWall').oninput = (e) => {
    CFG.penalties.wall = parseInt(e.target.value);
    document.getElementById('valPenaltyWall').innerText = `-${CFG.penalties.wall}`;
};

document.getElementById('slPenaltyStalled').oninput = (e) => {
    CFG.penalties.stalled = parseInt(e.target.value) / 10;
    document.getElementById('valPenaltyStalled').innerText = `-${CFG.penalties.stalled.toFixed(1)}`;
};

document.getElementById('slPenaltyWrong').oninput = (e) => {
    CFG.penalties.wrongSort = parseInt(e.target.value);
    document.getElementById('valPenaltyWrong').innerText = `-${CFG.penalties.wrongSort}`;
};

document.getElementById('slRewardMove').oninput = (e) => {
    CFG.rewards.move = parseInt(e.target.value) / 100;
    document.getElementById('valRewardMove').innerText = CFG.rewards.move.toFixed(2);
};

document.getElementById('slRewardCuriosity').oninput = (e) => {
    CFG.rewards.curiosity = parseInt(e.target.value) / 100;
    document.getElementById('valRewardCuriosity').innerText = CFG.rewards.curiosity.toFixed(2);
};

document.getElementById('slRewardProgressScale').oninput = (e) => {
    CFG.rewards.progressScale = parseInt(e.target.value) / 100;
    document.getElementById('valRewardProgressScale').innerText = CFG.rewards.progressScale.toFixed(2);
};

document.getElementById('slRewardStreak').oninput = (e) => {
    CFG.rewards.progressStreak = parseInt(e.target.value) / 100;
    document.getElementById('valRewardStreak').innerText = CFG.rewards.progressStreak.toFixed(2);
};

document.getElementById('slRewardPickup').oninput = (e) => {
    CFG.rewards.pickup = parseInt(e.target.value);
    document.getElementById('valRewardPickup').innerText = CFG.rewards.pickup;
};

document.getElementById('slRewardDeliveryBase').oninput = (e) => {
    CFG.rewards.deliveryBase = parseInt(e.target.value);
    document.getElementById('valRewardDeliveryBase').innerText = CFG.rewards.deliveryBase;
};

document.getElementById('slRewardDeliveryEnergy').oninput = (e) => {
    CFG.rewards.deliveryEnergy = parseInt(e.target.value);
    document.getElementById('valRewardDeliveryEnergy').innerText = CFG.rewards.deliveryEnergy;
};

document.getElementById('slRewardNearCorrect').oninput = (e) => {
    CFG.rewards.nearCorrect = parseInt(e.target.value) / 100;
    document.getElementById('valRewardNearCorrect').innerText = CFG.rewards.nearCorrect.toFixed(2);
};

document.getElementById('slPenaltyNearWrong').oninput = (e) => {
    CFG.rewards.nearWrong = parseInt(e.target.value) / 100;
    document.getElementById('valPenaltyNearWrong').innerText = `-${CFG.rewards.nearWrong.toFixed(2)}`;
};

document.getElementById('slPenaltyTargetSwitch').oninput = (e) => {
    CFG.rewards.targetSwitchPenalty = parseInt(e.target.value) / 100;
    document.getElementById('valPenaltyTargetSwitch').innerText = `-${CFG.rewards.targetSwitchPenalty.toFixed(2)}`;
};


init();
</script>
</body>
</html>
