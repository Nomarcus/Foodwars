<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>VolleySim â€“ Cooperative NEAT Training</title>
  <style>
    :root {
      --bg1:#050516;
      --panel:rgba(18,24,56,.82);
      --ink:#f1f5ff;
      --muted:#a1a9d8;
      --accent:#f472b6;
      --accent-cyan:#38bdf8;
      --silver:rgba(222,231,255,.55);
      --ok:#34d399;
      --warn:#f59e0b;
    }
    *{box-sizing:border-box}
    body{margin:0; min-height:100vh; display:flex; flex-direction:column; background:radial-gradient(circle at 42% 18%, rgba(87,51,183,.55) 0%, rgba(39,56,121,.78) 40%, var(--bg1) 100%); color:var(--ink); font-family:"Inter",system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;}

    .main-nav{position:sticky; top:0; z-index:100; padding:22px 48px; display:flex; align-items:center; justify-content:space-between; background:linear-gradient(120deg, rgba(15,20,48,.92) 0%, rgba(10,14,34,.75) 60%, rgba(10,14,34,.35) 100%); backdrop-filter:blur(14px); border-bottom:1px solid var(--silver); box-shadow:0 22px 45px rgba(5,9,25,.55)}
    .brand{display:flex; align-items:center; gap:12px; font-size:22px; font-weight:700; letter-spacing:.02em; color:var(--ink)}
    .brand-dot{width:14px; height:14px; border-radius:50%; background:linear-gradient(135deg, var(--accent) 0%, #8b5cf6 100%); box-shadow:0 0 18px rgba(244,114,182,.6)}
    .nav-links{display:flex; align-items:center; gap:12px; flex-wrap:wrap}
    .pill-link,.pill-button{display:inline-flex; align-items:center; justify-content:center; padding:10px 20px; border-radius:999px; border:1px solid rgba(56,189,248,.45); background:linear-gradient(120deg, rgba(56,189,248,.18), rgba(139,92,246,.18)); color:var(--ink); text-decoration:none; font-size:14px; font-weight:600; letter-spacing:.03em; transition:transform .2s ease, box-shadow .2s ease, filter .2s ease}
    .pill-link.secondary{border-color:rgba(139,92,246,.45); background:linear-gradient(120deg, rgba(139,92,246,.18), rgba(244,114,182,.18))}
    .pill-link:hover,.pill-button:hover{transform:translateY(-1px); filter:brightness(1.05); box-shadow:0 16px 32px rgba(56,189,248,.25)}
    .pill-link:focus-visible,.pill-button:focus-visible{outline:2px solid rgba(56,189,248,.65); outline-offset:3px}
    .pill-button{cursor:pointer; border-color:rgba(244,114,182,.45); background:linear-gradient(120deg, rgba(244,114,182,.25), rgba(59,130,246,.22))}

    main{flex:1; display:flex; justify-content:center; align-items:flex-start; padding:40px 48px 64px}
    .wrap{display:flex; width:100%; max-width:2000px; gap:40px; align-items:flex-start; justify-content:center}
    .field-area{flex:1 1 auto; display:flex; flex-direction:column; align-items:stretch; gap:18px; min-width:0}
    .playfield-frame{position:relative; padding:18px; border-radius:30px; background:rgba(4,8,26,.85); box-shadow:0 18px 36px rgba(9,14,36,.55); border:1px solid rgba(148,163,209,.22)}
    canvas{width:100%; height:auto; max-width:1100px; border-radius:24px; background:#04091f; box-shadow:0 0 45px rgba(15,23,61,.65), inset 0 0 22px rgba(118,133,255,.12); border:1px solid var(--silver)}

    .stats-bar{display:grid; grid-template-columns:repeat(auto-fit,minmax(160px,1fr)); gap:16px; padding:18px 22px; border-radius:18px; background:rgba(11,16,44,.78); border:1px solid var(--silver); box-shadow:0 18px 32px rgba(5,9,25,.45)}
    .stat-card{display:flex; flex-direction:column; gap:6px}
    .stat-label{font-size:12px; text-transform:uppercase; letter-spacing:.12em; color:var(--muted)}
    .stat-value{font-size:26px; font-weight:700; letter-spacing:.02em; color:var(--ink)}

    .side{width:360px; flex:0 1 360px; display:flex; flex-direction:column; gap:20px}
    .panel{background:var(--panel); border:1px solid var(--silver); padding:22px; border-radius:20px; backdrop-filter:blur(16px); box-shadow:0 18px 45px rgba(5,7,24,.55)}
    .panel h2{margin:0 0 12px; font-size:18px; letter-spacing:.02em}
    .panel p{margin:0 0 14px; font-size:13px; line-height:1.6; color:var(--muted)}
    .control-grid{display:grid; grid-template-columns:repeat(auto-fit,minmax(220px,1fr)); gap:16px}
    .control{display:flex; flex-direction:column; gap:10px; padding:12px 14px; border-radius:14px; border:1px solid rgba(148,163,209,.24); background:rgba(10,16,46,.55); box-shadow:inset 0 0 12px rgba(56,189,248,.08)}
    .control-header{display:flex; align-items:center; justify-content:space-between; gap:12px}
    .label{font-size:13px; color:var(--muted); letter-spacing:.02em}
    .val{font-family:ui-monospace,Menlo,Consolas,monospace; font-size:12px; padding:4px 8px; border-radius:8px; background:rgba(10,16,46,.7); border:1px solid var(--silver); color:var(--accent-cyan); box-shadow:inset 0 0 12px rgba(56,189,248,.12)}
    input[type=range]{width:100%; accent-color:var(--accent-cyan)}
    .btn{display:block; width:100%; padding:12px 14px; border-radius:12px; border:1px solid rgba(45,212,191,.45); background:linear-gradient(120deg, rgba(45,212,191,.18), rgba(59,130,246,.18)); color:var(--ink); cursor:pointer; text-align:center; margin-top:14px; font-weight:600; letter-spacing:.02em; transition:transform .2s ease, box-shadow .2s ease, filter .2s ease}
    .btn:hover{filter:brightness(1.08); transform:translateY(-1px); box-shadow:0 20px 36px rgba(45,212,191,.28)}

    .legend{border-radius:18px; border:1px solid rgba(148,163,209,.28); background:rgba(11,16,44,.72); padding:18px; display:grid; gap:10px; font-size:12px; color:var(--muted)}
    .legend strong{color:var(--ink)}

    @media (max-width:1200px){
      .wrap{flex-direction:column; align-items:center}
      .side{width:100%; max-width:720px}
    }
    @media (max-width:900px){
      main{padding:32px 28px 56px}
    }
    @media (max-width:768px){
      .main-nav{flex-direction:column; align-items:flex-start; gap:16px; padding:18px 24px}
      main{padding:28px 20px 52px}
      .wrap{gap:28px}
      .stats-bar{grid-template-columns:repeat(auto-fit,minmax(130px,1fr)); gap:12px; padding:16px 18px}
      .stat-value{font-size:22px}
      canvas{width:100%; height:auto}
    }
  </style>
</head>
<body>
  <header class="main-nav">
    <div class="brand"><span class="brand-dot"></span>VolleySim NEAT Lab</div>
    <nav class="nav-links" aria-label="Primary navigation">
      <a class="pill-link" href="index.html">Food arena</a>
      <a class="pill-link secondary" href="volleyball.html" aria-current="page">Volley lab</a>
      <a class="pill-link" href="learn-neat.html">How NEAT works</a>
    </nav>
  </header>
  <main>
    <div class="wrap">
      <aside class="side">
        <section class="panel" aria-labelledby="controls-heading">
          <h2 id="controls-heading">Training controls</h2>
          <p>Adjust parameters and restart to explore different cooperative behaviours. Mutation auto-decays slightly every generation.</p>
          <div class="control-grid">
            <div class="control">
              <div class="control-header">
                <label class="label" for="slPopulation">Population size</label>
                <span class="val" id="lbPopulation">30 genomes</span>
              </div>
              <input id="slPopulation" type="range" min="10" max="80" value="30" title="How many genomes evolve each generation. Larger populations explore more behaviours at once.">
            </div>

            <div class="control">
              <div class="control-header">
                <label class="label" for="slHidden">Initial hidden neurons</label>
                <span class="val" id="lbHidden">4 nodes</span>
              </div>
              <input id="slHidden" type="range" min="0" max="16" value="4" title="Number of hidden neurons seeded at the start of training.">
            </div>

            <div class="control">
              <div class="control-header">
                <label class="label" for="slMutRate">Mutation % (base)</label>
                <span class="val" id="lbMutRate">22%</span>
              </div>
              <input id="slMutRate" type="range" min="5" max="80" value="22" title="Base probability of mutating weights or structure each generation.">
            </div>

            <div class="control">
              <div class="control-header">
                <label class="label" for="slAddConn">Add-connection %</label>
                <span class="val" id="lbAddConn">8%</span>
              </div>
              <input id="slAddConn" type="range" min="1" max="40" value="8" title="Chance of inserting a brand-new synapse during mutation.">
            </div>

            <div class="control">
              <div class="control-header">
                <label class="label" for="slAddNode">Add-node %</label>
                <span class="val" id="lbAddNode">3%</span>
              </div>
              <input id="slAddNode" type="range" min="0" max="20" value="3" title="Chance of splitting a connection with a new hidden neuron.">
            </div>

            <div class="control">
              <div class="control-header">
                <label class="label" for="slSimSpeed">Sim speed</label>
                <span class="val" id="lbSimSpeed">2Ã—</span>
              </div>
              <input id="slSimSpeed" type="range" min="1" max="12" value="2" title="How many physics steps run per animation frame.">
            </div>

            <div class="control">
              <div class="control-header">
                <label class="label" for="slBallCount">Ball count</label>
                <span class="val" id="lbBallCount">1 ball</span>
              </div>
              <input id="slBallCount" type="range" min="1" max="6" value="1" title="Number of balls spawned for the cooperative drill.">
            </div>

            <div class="control">
              <div class="control-header">
                <label class="label" for="slBallRadius">Ball size</label>
                <span class="val" id="lbBallRadius">18px</span>
              </div>
              <input id="slBallRadius" type="range" min="12" max="32" value="18" title="Radius of each ball. Larger balls are easier targets but heavier.">
            </div>

            <div class="control">
              <div class="control-header">
                <label class="label" for="slArmBonus">Arm reward boost</label>
                <span class="val" id="lbArmBonus">6.0</span>
              </div>
              <input id="slArmBonus" type="range" min="2" max="12" value="6" step="0.5" title="Extra fitness granted when a player strikes the ball with a hand.">
            </div>

            <div class="control">
              <div class="control-header">
                <label class="label" for="slKickBonus">Kick reward boost</label>
                <span class="val" id="lbKickBonus">4.0</span>
              </div>
              <input id="slKickBonus" type="range" min="1" max="10" value="4" step="0.5" title="Bonus fitness for controlled kicks using the new leg joints.">
            </div>

            <div class="control">
              <div class="control-header">
                <label class="label" for="slHeadPenalty">Head touch penalty</label>
                <span class="val" id="lbHeadPenalty">1.5</span>
              </div>
              <input id="slHeadPenalty" type="range" min="0" max="5" value="1.5" step="0.1" title="How much fitness to subtract when agents rely on body bumps instead of precise hand or foot control.">
            </div>
          </div>
          <!-- Additional training controls for sensors, mode and save/load -->
          <div class="control">
            <div class="control-header">
              <label class="label" for="cbShowSensors">Show sensors</label>
            </div>
            <input id="cbShowSensors" type="checkbox">
          </div>

          <div class="control">
            <div class="control-header">
              <label class="label" for="selMode">Mode</label>
            </div>
            <select id="selMode">
              <option value="cooperation">Cooperation</option>
              <option value="competition">Competition</option>
            </select>
          </div>

          <div class="control">
            <div class="control-header">
              <span class="label">Progress</span>
            </div>
            <div style="display:flex; gap:8px;">
              <button id="btnSave" class="btn" style="flex:1;">ðŸ’¾ Save</button>
              <button id="btnLoad" class="btn" style="flex:1;">ðŸ“‚ Load</button>
            </div>
          </div>

          <button id="btnRestart" class="btn">Restart training</button>
        </section>
        <section class="legend">
          <strong>Objective</strong>
          <p>Four cooperative agents (two per side) learn to keep a glowing ball alive by volleying it over the central net. The ball now <span style="color:var(--ok);font-weight:700">bounces off side walls</span> (damped) for longer rallies.</p>
          <p>Fitness rewards long rallies, clean upward hits, coordinated multi-player touches, and safe net clears. Minor penalties apply for net clips and stalling.</p>
          <p>Use the sliders to launch <span style="color:var(--accent-cyan);font-weight:600">multiple balls</span> at once or change the <span style="color:var(--accent);font-weight:600">ball size</span> for different challenge levels.</p>
        </section>
      </aside>
      <div class="field-area">
        <div class="playfield-frame">
          <canvas id="court" width="1280" height="700" aria-label="Volley simulation field"></canvas>
        </div>
        <section class="stats-bar" aria-live="polite" aria-label="Simulation statistics">
          <div class="stat-card"><span class="stat-label">Generation</span><span class="stat-value" id="stat-generation">1</span></div>
          <div class="stat-card"><span class="stat-label">Genome</span><span class="stat-value" id="stat-genome">1 / 1</span></div>
          <div class="stat-card"><span class="stat-label">Best fitness</span><span class="stat-value" id="stat-best">0</span></div>
          <div class="stat-card"><span class="stat-label">Longest rally</span><span class="stat-value" id="stat-longest">0.0 s</span></div>
          <div class="stat-card"><span class="stat-label">Crossings</span><span class="stat-value" id="stat-crossings">0</span></div>
          <div class="stat-card"><span class="stat-label">Species</span><span class="stat-value" id="stat-species">1</span></div>
          <div class="stat-card"><span class="stat-label">Mut (active)</span><span class="stat-value" id="stat-mutation">0%</span></div>
        </section>
      </div>
    </div>
  </main>

  <script>
  // ===== Utility helpers =====
  const randRange = (min, max)=> Math.random() * (max - min) + min;
  const clamp = (value, min, max)=> Math.max(min, Math.min(max, value));
  const TAU = Math.PI * 2;

  const wrapAngle = (angle)=> {
    if(!Number.isFinite(angle)) return 0;
    while(angle <= -Math.PI) angle += TAU;
    while(angle > Math.PI) angle -= TAU;
    return angle;
  };

  const moveTowardAngle = (current, target, maxDelta)=> {
    const diff = wrapAngle(target - current);
    const delta = clamp(diff, -maxDelta, maxDelta);
    return current + delta;
  };

  const Q = (id)=> document.getElementById(id);

  function bindRange(id, labelId, format){
    const range = Q(id);
    const label = Q(labelId);
    if(!range || !label) return;
    const fmt = typeof format === 'function' ? format : (v)=> v;
    const update = ()=>{
      label.textContent = fmt(Number(range.value));
      scheduleConfigRefresh();
    };
    range.addEventListener('input', update);
    update();
  }

  // ===== NEAT-lite implementation (with improvements) =====
  class NodeGene {
    constructor(id, type, layer){
      this.id = id;
      this.type = type;
      this.layer = layer;
    }
    clone(){
      return new NodeGene(this.id, this.type, this.layer);
    }
  }

  class ConnectionGene {
    constructor(from, to, weight, enabled, innovation){
      this.from = from;
      this.to = to;
      this.weight = weight;
      this.enabled = enabled !== false;
      this.innovation = innovation;
    }
    clone(){
      return new ConnectionGene(this.from, this.to, this.weight, this.enabled, this.innovation);
    }
  }

  class InnovationTracker {
    constructor(){
      this.next = 1;
      this.lookup = new Map();
    }
    get(from, to){
      const key = from < to ? `${from}-${to}` : `${to}-${from}`;
      if(!this.lookup.has(key)){
        this.lookup.set(key, this.next++);
      }
      return this.lookup.get(key);
    }
  }

  class Genome {
    constructor(population, source){
      this.population = population;
      this.nodes = new Map();
      this.connections = [];
      this.connectionKeys = new Set();
      this.connectionByInnovation = new Map();
      this.sortedNodesCache = null;
      this.incomingCache = null;
      this.cacheDirty = true;
      this.fitness = 0;
      this.adjustedFitness = 0;
      if(source){
        source.nodes.forEach((node)=>{
          this.nodes.set(node.id, node.clone());
        });
        source.connections.forEach((conn)=> this._addConnectionGene(conn.clone()));
      } else {
        population.baseNodes.forEach((node)=>{
          this.nodes.set(node.id, node.clone());
        });
      }
    }

    clone(){
      return new Genome(this.population, this);
    }

    get outputNodes(){
      if(!this._outputNodes){
        this._outputNodes = Array.from(this.nodes.values()).filter((n)=> n.type === 'output').sort((a,b)=> a.layer === b.layer ? a.id - b.id : a.layer - b.layer);
      }
      return this._outputNodes;
    }

    _markDirty(){
      this.sortedNodesCache = null;
      this.incomingCache = null;
      this.cacheDirty = true;
      this._outputNodes = null;
    }

    _addConnectionGene(conn){
      this.connections.push(conn);
      this.connectionKeys.add(`${conn.from}->${conn.to}`);
      this.connectionByInnovation.set(conn.innovation, conn);
      this.cacheDirty = true;
    }

    addInitialConnections(){
      const outputs = this.outputNodes;
      const inputs = Array.from(this.nodes.values()).filter((n)=> n.type === 'input' || n.type === 'bias');
      for(const inp of inputs){
        for(const out of outputs){
          const innovation = this.population.innovationTracker.get(inp.id, out.id);
          const conn = new ConnectionGene(inp.id, out.id, randRange(-1, 1), true, innovation);
          this._addConnectionGene(conn);
        }
      }
      this.primeOutputBias(); // (8) vertical control bias & sensible starts
    }

    // (8) Give useful initial priors to vertical outputs
    primeOutputBias(){
      const outStart = this.population.outputStart;
      const players = [
        {outX: outStart + OutputIndex.LEFT1_X, outY: outStart + OutputIndex.LEFT1_Y, dx: InputIndex.LEFT1_DX, dy: InputIndex.LEFT1_DY},
        {outX: outStart + OutputIndex.LEFT2_X, outY: outStart + OutputIndex.LEFT2_Y, dx: InputIndex.LEFT2_DX, dy: InputIndex.LEFT2_DY},
        {outX: outStart + OutputIndex.RIGHT1_X, outY: outStart + OutputIndex.RIGHT1_Y, dx: InputIndex.RIGHT1_DX, dy: InputIndex.RIGHT1_DY},
        {outX: outStart + OutputIndex.RIGHT2_X, outY: outStart + OutputIndex.RIGHT2_Y, dx: InputIndex.RIGHT2_DX, dy: InputIndex.RIGHT2_DY}
      ];

      for(const c of this.connections){
        for(const player of players){
          if(c.to === player.outY && (c.from === player.dy || c.from === InputIndex.BALL_VY || c.from === InputIndex.BALL_Y)){
            c.weight += Math.abs(c.weight) + randRange(0.6, 1.2);
          }
          if(c.to === player.outX && (c.from === player.dx || c.from === InputIndex.BALL_X || c.from === InputIndex.BALL_VX)){
            c.weight += Math.abs(c.weight) + randRange(0.3, 0.8);
          }
        }
      }
      this._markDirty();
    }

    getSortedNodes(){
      if(this.sortedNodesCache){
        return this.sortedNodesCache;
      }
      this.sortedNodesCache = Array.from(this.nodes.values()).sort((a,b)=>{
        if(a.layer === b.layer) return a.id - b.id;
        return a.layer - b.layer;
      });
      return this.sortedNodesCache;
    }

    buildIncoming(){
      if(!this.cacheDirty && this.incomingCache){
        return this.incomingCache;
      }
      const incoming = new Map();
      for(const conn of this.connections){
        if(!conn.enabled) continue;
        if(!incoming.has(conn.to)) incoming.set(conn.to, []);
        incoming.get(conn.to).push(conn);
      }
      this.incomingCache = incoming;
      this.cacheDirty = false;
      return incoming;
    }

    feedForward(inputs){
      const sorted = this.getSortedNodes();
      const incoming = this.buildIncoming();
      const values = new Map();
      let inputIndex = 0;
      for(const node of sorted){
        if(node.type === 'input'){
          values.set(node.id, inputs[inputIndex++] ?? 0);
        } else if(node.type === 'bias'){
          values.set(node.id, 1);
        } else {
          const inbound = incoming.get(node.id);
          let sum = 0;
          if(inbound){
            for(const conn of inbound){
              sum += (values.get(conn.from) ?? 0) * conn.weight;
            }
          }
          const activated = Math.tanh(sum);
          values.set(node.id, activated);
        }
      }
      const outputs = [];
      for(const node of this.outputNodes){
        outputs.push(values.get(node.id) ?? 0);
      }
      return outputs;
    }

    mutateWeights(rate, strength){
      for(const conn of this.connections){
        if(Math.random() < rate){
          conn.weight += randRange(-strength, strength);
        }
      }
      this.cacheDirty = true;
    }

    hasConnection(from, to){
      return this.connectionKeys.has(`${from}->${to}`);
    }

    mutateAddConnection(){
      const nodes = this.getSortedNodes();
      let attempts = 0;
      while(attempts < 32){
        attempts++;
        const from = nodes[Math.floor(Math.random() * nodes.length)];
        const to = nodes[Math.floor(Math.random() * nodes.length)];
        if(!from || !to) continue;
        if(from.layer >= to.layer) continue;
        if(from.type === 'output' && to.type === 'output') continue;
        if(to.type === 'input' || to.type === 'bias') continue;
        if(this.hasConnection(from.id, to.id)) continue;
        const innovation = this.population.innovationTracker.get(from.id, to.id);
        const conn = new ConnectionGene(from.id, to.id, randRange(-1, 1), true, innovation);
        this._addConnectionGene(conn);
        this._markDirty();
        return true;
      }
      return false;
    }

    mutateAddNode(){
      const candidates = this.connections.filter((conn)=> conn.enabled);
      if(!candidates.length) return false;
      const conn = candidates[Math.floor(Math.random()*candidates.length)];
      conn.enabled = false;
      const fromNode = this.nodes.get(conn.from);
      const toNode = this.nodes.get(conn.to);
      const newNodeId = this.population.allocateNodeId();
      const newNode = new NodeGene(newNodeId, 'hidden', (fromNode.layer + toNode.layer) / 2);
      this.nodes.set(newNodeId, newNode);
      const innovation1 = this.population.innovationTracker.get(conn.from, newNodeId);
      const innovation2 = this.population.innovationTracker.get(newNodeId, conn.to);
      const conn1 = new ConnectionGene(conn.from, newNodeId, 1, true, innovation1);
      const conn2 = new ConnectionGene(newNodeId, conn.to, conn.weight, true, innovation2);
      this._addConnectionGene(conn1);
      this._addConnectionGene(conn2);
      this._markDirty();
      return true;
    }

    // (10) Stabilized crossover: average matching weights
    crossover(partner){
      const child = new Genome(this.population);
      child.nodes.clear();
      this.nodes.forEach((node)=> child.nodes.set(node.id, node.clone()));
      partner.nodes.forEach((node)=>{
        if(!child.nodes.has(node.id)){
          child.nodes.set(node.id, node.clone());
        }
      });
      const better = this.fitness >= partner.fitness ? this : partner;
      const other = better === this ? partner : this;
      const betterConns = better.connections.slice().sort((a,b)=> a.innovation - b.innovation);
      for(const conn of betterConns){
        const match = other.connectionByInnovation.get(conn.innovation);
        let gene;
        if(match){
          gene = conn.clone();
          gene.weight = (conn.weight + match.weight) / 2; // averaged
          gene.enabled = conn.enabled || match.enabled;
        } else {
          gene = conn.clone();
        }
        child._addConnectionGene(gene);
      }
      child._markDirty();
      return child;
    }

    compatibilityDistance(other){
      const c1 = 1.0, c2 = 1.0, c3 = 0.4;
      const thisGenes = this.connections.slice().sort((a,b)=> a.innovation - b.innovation);
      const otherGenes = other.connections.slice().sort((a,b)=> a.innovation - b.innovation);
      let i=0, j=0;
      let matching = 0;
      let weightDiff = 0;
      let disjoint = 0;
      let excess = 0;
      while(i < thisGenes.length && j < otherGenes.length){
        const a = thisGenes[i];
        const b = otherGenes[j];
        if(a.innovation === b.innovation){
          matching++;
          weightDiff += Math.abs(a.weight - b.weight);
          i++; j++;
        } else if(a.innovation < b.innovation){
          disjoint++;
          i++;
        } else {
          disjoint++;
          j++;
        }
      }
      excess += (thisGenes.length - i) + (otherGenes.length - j);
      const n = Math.max(thisGenes.length, otherGenes.length, 1);
      const avgWeight = matching > 0 ? weightDiff / matching : 0;
      return (c1 * excess) / n + (c2 * disjoint) / n + c3 * avgWeight;
    }

    mutate(config){
      this.mutateWeights(config.mutationRate / 100, 0.8);
      if(Math.random() < config.addConnectionRate / 100){
        this.mutateAddConnection();
      }
      if(Math.random() < config.addNodeRate / 100){
        this.mutateAddNode();
      }
    }
  }

  class Species {
    constructor(representative){
      this.representative = representative.clone();
      this.members = [];
      this.bestFitness = -Infinity;
      this.staleness = 0;
      this.adjustedSum = 0;
    }
  }

  class Population {
    constructor(config){
      this.size = config.populationSize;
      this.inputCount = config.inputCount;
      this.outputCount = config.outputCount;
      this.biasCount = 1;
      this.innovationTracker = new InnovationTracker();
      this.baseNodes = [];
      for(let i=0;i<this.inputCount;i++){
        this.baseNodes.push(new NodeGene(i, 'input', 0));
      }
      this.biasNodeId = this.inputCount;
      this.baseNodes.push(new NodeGene(this.biasNodeId, 'bias', 0));
      this.outputStart = this.inputCount + this.biasCount;
      for(let i=0;i<this.outputCount;i++){
        this.baseNodes.push(new NodeGene(this.outputStart + i, 'output', 1));
      }
      this.nextNodeId = this.outputStart + this.outputCount;
      this.genomes = [];
      this.species = [];
      this.compatibilityThreshold = 3.0;
      for(let i=0;i<this.size;i++){
        const genome = new Genome(this);
        genome.addInitialConnections();
        this.genomes.push(genome);
      }
    }

    allocateNodeId(){
      return this.nextNodeId++;
    }

    injectHiddenNodes(count){
      if(count <= 0) return;
      const inputs = this.baseNodes.filter((node)=> node.type === 'input' || node.type === 'bias');
      const outputs = this.baseNodes.filter((node)=> node.type === 'output');
      for(let i=0;i<count;i++){
        const newNodeId = this.allocateNodeId();
        const layer = 0.5 + 0.05 * i;
        const template = new NodeGene(newNodeId, 'hidden', layer);
        for(const genome of this.genomes){
          genome.nodes.set(newNodeId, template.clone());
          genome._markDirty();
        }
        for(const genome of this.genomes){
          for(const inp of inputs){
            if(genome.hasConnection(inp.id, newNodeId)) continue;
            const innovation = this.innovationTracker.get(inp.id, newNodeId);
            genome._addConnectionGene(new ConnectionGene(inp.id, newNodeId, randRange(-1,1), true, innovation));
          }
          for(const out of outputs){
            if(genome.hasConnection(newNodeId, out.id)) continue;
            const innovation = this.innovationTracker.get(newNodeId, out.id);
            genome._addConnectionGene(new ConnectionGene(newNodeId, out.id, randRange(-1,1), true, innovation));
          }
          genome._markDirty();
        }
      }
    }

    speciate(){
      for(const species of this.species){
        species.members.length = 0;
      }
      for(const genome of this.genomes){
        let placed = false;
        for(const species of this.species){
          const distance = genome.compatibilityDistance(species.representative);
          if(distance < this.compatibilityThreshold){
            species.members.push(genome);
            placed = true;
            break;
          }
        }
        if(!placed){
          const fresh = new Species(genome);
          fresh.members.push(genome);
          this.species.push(fresh);
        }
      }
      this.species = this.species.filter((species)=> species.members.length > 0);
      for(const species of this.species){
        species.representative = species.members[0].clone();
      }
    }

    prepareFitness(){
      let totalAdjusted = 0;
      for(const species of this.species){
        species.members.sort((a,b)=> b.fitness - a.fitness);
        if(species.members[0].fitness > species.bestFitness){
          species.bestFitness = species.members[0].fitness;
          species.staleness = 0;
        } else {
          species.staleness++;
        }
        let sum = 0;
        for(const genome of species.members){
          genome.adjustedFitness = genome.fitness / species.members.length;
          sum += genome.adjustedFitness;
        }
        species.adjustedSum = sum;
        totalAdjusted += sum;
      }
      return totalAdjusted;
    }

    pickSpeciesByAdjusted(totalAdjusted){
      if(!this.species.length){
        return null;
      }
      if(totalAdjusted <= 0){
        return this.species[Math.floor(Math.random()*this.species.length)];
      }
      let running = 0;
      const target = Math.random() * totalAdjusted;
      for(const species of this.species){
        running += species.adjustedSum;
        if(target <= running){
          return species;
        }
      }
      return this.species[this.species.length-1];
    }

    pickParent(species){
      const total = species.members.reduce((acc,g)=> acc + g.fitness, 0);
      if(total <= 0){
        return species.members[Math.floor(Math.random()*species.members.length)];
      }
      const r = Math.random() * total;
      let running = 0;
      for(const genome of species.members){
        running += genome.fitness;
        if(r <= running){
          return genome;
        }
      }
      return species.members[0];
    }

    evolve(config){
      this.speciate();
      const totalAdjusted = this.prepareFitness();
      const nextGen = [];
      if(!this.species.length){
        return;
      }
      // Keep best
      const bestOverall = this.genomes.slice().sort((a,b)=> b.fitness - a.fitness)[0];
      nextGen.push(bestOverall.clone());
      while(nextGen.length < this.size){
        const species = this.pickSpeciesByAdjusted(totalAdjusted || this.species.length);
        const parentA = this.pickParent(species);
        const parentB = this.pickParent(species);
        let child;
        if(parentA === parentB || Math.random() < 0.25){
          child = parentA.clone();
        } else {
          child = parentA.crossover(parentB);
        }
        child.mutate(config);
        nextGen.push(child);
      }
      this.genomes = nextGen.slice(0, this.size);
      this.species.forEach((species)=> species.members.length = 0);
      this.species.length && this.speciate();
    }
  }

  // ===== Simulation (with improvements) =====
  const canvas = Q('court');
  const ctx = canvas.getContext('2d');

 // --- Fysik & plan ---
const FIELD_WIDTH = canvas.width;
const FIELD_HEIGHT = canvas.height;
const BORDER_PAD = 20;
const CEILING_Y = 40 + BORDER_PAD;
const FLOOR_Y = FIELD_HEIGHT - 20;
const NET_X = FIELD_WIDTH / 2;
const NET_WIDTH = 14;
const NET_HEIGHT = 260;
const NET_TOP = FIELD_HEIGHT - NET_HEIGHT;

const PLAYER_RADIUS = 32;
let ballRadius = 18;

const MAX_MOVE_SPEED = 380;     // â†‘ var 320 â€“ snabbare sidled
const MAX_BALL_SPEED = 520;

const GRAVITY = 450;
const PLAYER_GROUND_Y = FIELD_HEIGHT - PLAYER_RADIUS - 30;

// --- Fysiska grÃ¤nser m.m. (ofÃ¶rÃ¤ndrat) ---
const FIELD_WIDTH = canvas.width;
const FIELD_HEIGHT = canvas.height;
const BORDER_PAD = 20;
const CEILING_Y = 40 + BORDER_PAD;
const FLOOR_Y = FIELD_HEIGHT - 20;
const NET_X = FIELD_WIDTH / 2;
const NET_WIDTH = 14;
const NET_HEIGHT = 260;
const NET_TOP = FIELD_HEIGHT - NET_HEIGHT;

const PLAYER_RADIUS = 32;
let ballRadius = 18;

// --- RÃ¶relse & hopp: halvjusterat ---
const MAX_MOVE_SPEED = 350;        // mellan 320 och 380
const MAX_BALL_SPEED = 520;

const GRAVITY = 450;
const PLAYER_GROUND_Y = FIELD_HEIGHT - PLAYER_RADIUS - 30;

const PLAYER_GRAVITY = 1550;       // mellan 1500 och 1600
const PLAYER_JUMP_IMPULSE = 390;   // mellan 420 (orig) och 360 â€“ tillÃ¥ter block
const PLAYER_FAST_FALL = 1100;     // mellan 1200 och 1000
const PLAYER_MAX_FALL_SPEED = 900;
const PLAYER_MAX_RISE_SPEED = 660; // mellan 720 och 600

const NET_BOUNCE_DAMPING = 0.75;
const WALL_BOUNCE_DAMPING = 0.82;
const WALL_BOUNCE_REWARD = 1.2;
const NET_CLIP_PENALTY = 1.5;

const SIM_DT = 1/60;
const MAX_STEPS_BASE = 2200;
const CROSS_REWARD = 30;
const TOUCH_REWARD = 4;
const SURVIVAL_REWARD = 0.06;
const COMPETITION_VICTORY_BONUS = 50;

// --- Team ---
const TEAM_SIZE = 2;

// --- Armar: lÃ¶sare men inte fÃ¶r fladdrigt (halvvÃ¤gs) ---
const SHOULDER_SPREAD = 22;
const SHOULDER_HEIGHT = -18;
const UPPER_ARM_LENGTH = 34;
const LOWER_ARM_LENGTH = 38;
const ARM_TOTAL_REACH = UPPER_ARM_LENGTH + LOWER_ARM_LENGTH;
const HAND_HIT_RADIUS = 13;                // mellan 14 och 12
const ARM_SWING_RATE = Math.PI * 3.9;      // mellan 4.2Ï€ och 3.6Ï€
const ARM_FACING_LIMIT = Math.PI * 0.81;   // mellan 0.72Ï€ och 0.9Ï€
const ARM_DRAW_WIDTH = 8.5;

// --- Ben: nÃ¥got lugnare ---
const HIP_SPREAD = 18;
const HIP_HEIGHT = 24;
const THIGH_LENGTH = 36;
const SHIN_LENGTH = 44;
const LEG_TOTAL_REACH = THIGH_LENGTH + SHIN_LENGTH;
const FOOT_HIT_RADIUS = 18;
const LEG_SWING_RATE = Math.PI * 2.9;      // mellan 3.2Ï€ och 2.6Ï€
const LEG_FACING_LIMIT = Math.PI * 0.275;  // mellan 0.3Ï€ och 0.25Ï€
const LEG_DRAW_WIDTH = 9.5;

// --- Anti-hop cooldown: halverad intensitet ---
const MIN_GROUNDED_TIME_BEFORE_JUMP = 0.09; // tidigare 0.18
const JUMP_ENERGY_COST = 0.10;              // tidigare 0.20

// --- Mitt-bias: halverad effekt ---
const CENTER_BAND_WIDTH = 160;    // behÃ¥ll bandet
const CENTER_STEP_REWARD = 0.0075;// halva 0.015
const EDGE_PENALTY = 0.004;       // halva 0.008


  const ARM_STRIKE_BONUS_DEFAULT = 6;
  const LEG_KICK_BONUS_DEFAULT = 4;
  const HEAD_TOUCH_PENALTY_DEFAULT = 1.5;
  let armStrikeBonus = ARM_STRIKE_BONUS_DEFAULT;
  let legKickBonus = LEG_KICK_BONUS_DEFAULT;
  let headTouchPenalty = HEAD_TOUCH_PENALTY_DEFAULT;
  // default settings for training mode and sensor visibility
  const DEFAULT_MODE = 'cooperation';
  const DEFAULT_SHOW_SENSORS = false;

  // Increase input count to accommodate additional environment sensors (ceiling, floor, net, wall distances for each player)
  // plus sensors from both hands and both feet to ceiling, floor, net, back wall and ball (dx, dy). 4 players Ã— 4 limbs Ã— 6 features = 96 additional inputs.
  // Total base inputs (37) + 96 = 133.
  const INPUT_COUNT = 133;
  const OUTPUT_COUNT = 8;

  const InputIndex = Object.freeze({
    BALL_X: 0,
    BALL_Y: 1,
    BALL_VX: 2,
    BALL_VY: 3,
    LEFT1_X: 4,
    LEFT1_Y: 5,
    LEFT2_X: 6,
    LEFT2_Y: 7,
    RIGHT1_X: 8,
    RIGHT1_Y: 9,
    RIGHT2_X: 10,
    RIGHT2_Y: 11,
    LEFT1_DX: 12,
    LEFT1_DY: 13,
    LEFT2_DX: 14,
    LEFT2_DY: 15,
    RIGHT1_DX: 16,
    RIGHT1_DY: 17,
    RIGHT2_DX: 18,
    RIGHT2_DY: 19,
    TOUCH: 20,
    // Environment sensors per player:
    // Distances normalized to field dimensions: (y - CEILING_Y)/FIELD_HEIGHT, (FLOOR_Y - y)/FIELD_HEIGHT,
    // |x - NET_X|/FIELD_WIDTH, and distance to back wall depending on side.
    LEFT1_CEIL: 21,
    LEFT1_FLOOR: 22,
    LEFT1_NET: 23,
    LEFT1_WALL: 24,
    LEFT2_CEIL: 25,
    LEFT2_FLOOR: 26,
    LEFT2_NET: 27,
    LEFT2_WALL: 28,
    RIGHT1_CEIL: 29,
    RIGHT1_FLOOR: 30,
    RIGHT1_NET: 31,
    RIGHT1_WALL: 32,
    RIGHT2_CEIL: 33,
    RIGHT2_FLOOR: 34,
    RIGHT2_NET: 35,
    RIGHT2_WALL: 36
  });

  const OutputIndex = Object.freeze({
    LEFT1_X: 0,
    LEFT1_Y: 1,
    LEFT2_X: 2,
    LEFT2_Y: 3,
    RIGHT1_X: 4,
    RIGHT1_Y: 5,
    RIGHT2_X: 6,
    RIGHT2_Y: 7
  });

  const config = {
    populationSize: 30,
    mutationRate: 22,
    addConnectionRate: 8,
    addNodeRate: 3,
    initialHidden: 4,
    simSpeed: 2,
    ballCount: 1,
    ballRadius: 18,
    armReward: ARM_STRIKE_BONUS_DEFAULT,
    kickReward: LEG_KICK_BONUS_DEFAULT,
    headPenalty: HEAD_TOUCH_PENALTY_DEFAULT
    ,
    // additional options for rendering sensors and selecting training mode
    mode: DEFAULT_MODE,
    showSensors: DEFAULT_SHOW_SENSORS
  };

  // Track cumulative points across generations in competition mode.
  // These values persist across rallies and genomes and are incremented
  // whenever a point is awarded to the opposing team when the ball hits the floor.
  let cumulativeScores = {left: 0, right: 0};

  let population = null;
  let generation = 1;
  let genomeIndex = 0;
  let bestFitness = 0;
  let totalSpecies = 1;
  let evaluationOrder = [];
  let currentSession = null;
  let needsConfigRefresh = false;
  let baseMutationAtStart = config.mutationRate;

  class Player {
    constructor(x, y, side, slot){
      this.side = side; // 'left' or 'right'
      this.slot = slot;
      this.shoulderOffsets = side === 'left'
        ? [{x: -SHOULDER_SPREAD, y: SHOULDER_HEIGHT}, {x: SHOULDER_SPREAD, y: SHOULDER_HEIGHT}]
        : [{x: SHOULDER_SPREAD, y: SHOULDER_HEIGHT}, {x: -SHOULDER_SPREAD, y: SHOULDER_HEIGHT}];
      this.armAngles = [0, 0];
      this.armSegments = [{}, {}];
      this.hipOffsets = side === 'left'
        ? [{x: -HIP_SPREAD, y: HIP_HEIGHT}, {x: HIP_SPREAD, y: HIP_HEIGHT}]
        : [{x: HIP_SPREAD, y: HIP_HEIGHT}, {x: -HIP_SPREAD, y: HIP_HEIGHT}];
      this.legAngles = [Math.PI/2, Math.PI/2];
      this.legSegments = [{}, {}];
      this.reset(x, y);
    }

    resetArmAngles(){
      const baseFacing = this.side === 'left' ? 0 : Math.PI;
      const spread = 0.45;
      if(this.side === 'left'){
        this.armAngles = [baseFacing - spread, baseFacing + spread];
      } else {
        this.armAngles = [baseFacing + spread, baseFacing - spread];
      }
    }

    resetLegAngles(){
      // Orient legs straight down with a slight outward spread for stability on spawn
      const base = Math.PI / 2;
      const spread = 0.05;
      this.legAngles = [base - spread, base + spread];
    }

    reset(x, y){
      const topLimit = NET_TOP - 40;
      if(this.side === 'left'){
        this.x = clamp(x, PLAYER_RADIUS + 20, NET_X - NET_WIDTH/2 - PLAYER_RADIUS - 20);
      } else {
        this.x = clamp(x, NET_X + NET_WIDTH/2 + PLAYER_RADIUS + 20, FIELD_WIDTH - PLAYER_RADIUS - 20);
      }
      this.y = clamp(y, topLimit, PLAYER_GROUND_Y);
      this.vx = 0;
      this.vy = 0;
      this.grounded = this.y >= PLAYER_GROUND_Y - 1;
      this.resetArmAngles();
      this.resetLegAngles();
      this.updateArms(null, 0);
      this.updateLegs(null, 0);
    }

    update(dxInput, jumpInput, dt, ball){
      const horizontal = clamp(dxInput ?? 0, -1, 1);
      const prevX = this.x;
      this.x += horizontal * MAX_MOVE_SPEED * dt;
      if(this.side === 'left'){
        this.x = clamp(this.x, PLAYER_RADIUS + 20, NET_X - NET_WIDTH/2 - PLAYER_RADIUS - 20);
      } else {
        this.x = clamp(this.x, NET_X + NET_WIDTH/2 + PLAYER_RADIUS + 20, FIELD_WIDTH - PLAYER_RADIUS - 20);
      }

      const topLimit = NET_TOP - 40;
      const ground = PLAYER_GROUND_Y;
      const jump = clamp(jumpInput ?? 0, -1, 1);
      const wasGrounded = this.grounded || (this.y >= ground - 1 && this.vy >= -40);
      if(wasGrounded){
        this.y = ground;
        if(this.vy > 0) this.vy = 0;
      }

      if(jump > 0.55 && wasGrounded){
        this.vy = -PLAYER_JUMP_IMPULSE * jump;
      }
      if(jump > 0.2 && !wasGrounded){
        this.vy -= PLAYER_JUMP_IMPULSE * 0.35 * jump * dt;
      }
      if(jump < -0.55){
        this.vy += PLAYER_FAST_FALL * dt * (-jump);
      }

      this.vy += PLAYER_GRAVITY * dt;
      this.vy = clamp(this.vy, -PLAYER_MAX_RISE_SPEED, PLAYER_MAX_FALL_SPEED);
      this.y += this.vy * dt;

      if(this.y < topLimit){
        this.y = topLimit;
        if(this.vy < 0) this.vy = 0;
      }
      if(this.y > ground){
        this.y = ground;
        if(this.vy > 0) this.vy = 0;
      }
      this.grounded = this.y >= ground - 1;
      this.vx = (this.x - prevX) / dt;
      this.updateArms(ball, dt);
      this.updateLegs(ball, dt);
    }

    updateArms(ball, dt){
      const baseFacing = this.side === 'left' ? 0 : Math.PI;
      const offsets = this.side === 'left' ? [-0.35, 0.35] : [0.35, -0.35];
      const targetAngle = ball ? Math.atan2(ball.y - this.y, ball.x - this.x) : baseFacing;
      const aim = wrapAngle(targetAngle);
      for(let i=0;i<2;i++){
        const desired = baseFacing + clamp(wrapAngle(aim + offsets[i] - baseFacing), -ARM_FACING_LIMIT, ARM_FACING_LIMIT);
        const current = this.armAngles[i] ?? desired;
        const maxDelta = ARM_SWING_RATE * dt;
        this.armAngles[i] = moveTowardAngle(current, desired, maxDelta);
        const shoulderOffset = this.shoulderOffsets[i];
        const shoulderX = this.x + shoulderOffset.x;
        const shoulderY = this.y + shoulderOffset.y;
        let targetX = shoulderX;
        let targetY = shoulderY + 40;
        if(ball){
          targetX = ball.x;
          targetY = ball.y;
        }
        const dx = targetX - shoulderX;
        const dy = targetY - shoulderY;
        const dist = Math.hypot(dx, dy);
        const reach = Math.min(ARM_TOTAL_REACH, dist + 18);
        const elbowLen = Math.min(UPPER_ARM_LENGTH, Math.max(UPPER_ARM_LENGTH * 0.4, reach * 0.55));
        const handLen = Math.min(LOWER_ARM_LENGTH, Math.max(LOWER_ARM_LENGTH * 0.35, reach - elbowLen));
        const elbowX = shoulderX + Math.cos(this.armAngles[i]) * elbowLen;
        const elbowY = shoulderY + Math.sin(this.armAngles[i]) * elbowLen;
        const handX = elbowX + Math.cos(this.armAngles[i]) * handLen;
        const handY = elbowY + Math.sin(this.armAngles[i]) * handLen;
        this.armSegments[i] = {shoulderX, shoulderY, elbowX, elbowY, handX, handY, handRadius: HAND_HIT_RADIUS};
      }
    }

    updateLegs(ball, dt){
      const baseFacing = Math.PI / 2;
      const offsets = [-0.28, 0.28];
      const targetAngle = ball ? Math.atan2(ball.y - this.y, ball.x - this.x) : baseFacing;
      const aim = wrapAngle(targetAngle);
      const gait = clamp(this.vx / MAX_MOVE_SPEED, -1, 1) * 0.25;
      for(let i=0;i<2;i++){
        const desired = baseFacing + clamp(wrapAngle(aim + offsets[i] - baseFacing), -LEG_FACING_LIMIT, LEG_FACING_LIMIT) + (i === 0 ? gait : -gait);
        const current = this.legAngles[i] ?? desired;
        const maxDelta = LEG_SWING_RATE * dt + Math.abs(gait) * 0.35 * dt;
        this.legAngles[i] = moveTowardAngle(current, desired, maxDelta);
        const hipOffset = this.hipOffsets[i];
        const hipX = this.x + hipOffset.x;
        const hipY = this.y + hipOffset.y;
        let targetX = hipX;
        let targetY = hipY + LEG_TOTAL_REACH * 0.7;
        if(ball){
          targetX = ball.x;
          targetY = ball.y;
        }
        const dx = targetX - hipX;
        const dy = targetY - hipY;
        const dist = Math.hypot(dx, dy);
        const reach = Math.min(LEG_TOTAL_REACH, dist + 16);
        const thighLen = Math.min(THIGH_LENGTH, Math.max(THIGH_LENGTH * 0.45, reach * 0.52));
        const shinLen = Math.min(SHIN_LENGTH, Math.max(SHIN_LENGTH * 0.45, reach - thighLen));
        const kneeX = hipX + Math.cos(this.legAngles[i]) * thighLen;
        const kneeY = hipY + Math.sin(this.legAngles[i]) * thighLen;
        const footX = kneeX + Math.cos(this.legAngles[i]) * shinLen;
        const footY = kneeY + Math.sin(this.legAngles[i]) * shinLen;
        this.legSegments[i] = {hipX, hipY, kneeX, kneeY, footX, footY, footRadius: FOOT_HIT_RADIUS};
      }
    }

    tryHitBall(ball){
      if(!ball) return null;
      if(!this.armSegments || this.armSegments.length < 2){
        this.updateArms(ball, 0);
      }
      for(const arm of this.armSegments){
        if(!arm) continue;
        const dx = ball.x - arm.handX;
        const dy = ball.y - arm.handY;
        const dist = Math.hypot(dx, dy);
        const minDist = ballRadius + (arm.handRadius ?? HAND_HIT_RADIUS);
        if(dist < minDist){
          const nx = dist > 0 ? dx / dist : 0;
          const ny = dist > 0 ? dy / dist : -1;
          const speed = Math.max(360, Math.min(MAX_BALL_SPEED, Math.hypot(ball.vx, ball.vy) * 0.85 + 220));
          ball.vx = nx * speed + this.vx * 0.45;
          ball.vy = ny * speed - 140 + this.vy * 0.25;
          ball.x = arm.handX + nx * (minDist + 0.5);
          ball.y = arm.handY + ny * (minDist + 0.5);
          return {type: 'arm', normalX: nx, normalY: ny};
        }
      }

      if(!this.legSegments || this.legSegments.length < 2){
        this.updateLegs(ball, 0);
      }
      for(const leg of this.legSegments){
        if(!leg) continue;
        const dx = ball.x - leg.footX;
        const dy = ball.y - leg.footY;
        const dist = Math.hypot(dx, dy);
        const minDist = ballRadius + (leg.footRadius ?? FOOT_HIT_RADIUS);
        if(dist < minDist){
          const nx = dist > 0 ? dx / dist : 0;
          const ny = dist > 0 ? dy / dist : -1;
          const speed = Math.max(320, Math.min(MAX_BALL_SPEED, Math.hypot(ball.vx, ball.vy) * 0.9 + 200));
          const walkInfluence = clamp(this.vx / MAX_MOVE_SPEED, -1, 1);
          ball.vx = nx * speed + this.vx * 0.65 + walkInfluence * 60;
          ball.vy = ny * speed - 90 + this.vy * 0.35;
          ball.x = leg.footX + nx * (minDist + 0.5);
          ball.y = leg.footY + ny * (minDist + 0.5);
          return {type: 'leg', normalX: nx, normalY: ny};
        }
      }

      const dx = ball.x - this.x;
      const dy = ball.y - this.y;
      const distSq = dx*dx + dy*dy;
      const minDist = PLAYER_RADIUS + ballRadius - 2;
      if(distSq >= minDist*minDist) return null;
      const dist = Math.sqrt(distSq) || 0.0001;
      const nx = dx / dist;
      const ny = dy / dist;
      const speed = Math.max(280, Math.min(MAX_BALL_SPEED, Math.hypot(ball.vx, ball.vy) * 0.95 + 40));
      ball.vx = nx * speed;
      ball.vy = ny * speed - 80 + this.vy * 0.25;
      ball.x = this.x + nx * (minDist + 1);
      ball.y = this.y + ny * (minDist + 1);
      return {type: 'head', normalX: nx, normalY: ny};
    }
  }

  class Ball {
    constructor(){
      this.reset('left');
    }
    reset(side){
      if(side === 'right'){
        this.x = NET_X + 170;
        this.vx = randRange(-240, -150);
      } else {
        this.x = NET_X - 170;
        this.vx = randRange(150, 240);
      }
      this.y = NET_TOP - randRange(40, 110);
      this.vy = randRange(-180, -90);
      this.lastSide = side;
    }
    update(dt){
      this.vy += GRAVITY * dt;
      this.x += this.vx * dt;
      this.y += this.vy * dt;
      // Ceiling bounce (kept)
      if(this.y - ballRadius <= CEILING_Y){
        this.y = CEILING_Y + ballRadius;
        this.vy = Math.abs(this.vy) * 0.85;
      }
      // Clamp speeds
      if(this.vy > MAX_BALL_SPEED) this.vy = MAX_BALL_SPEED;
      if(this.vy < -MAX_BALL_SPEED) this.vy = -MAX_BALL_SPEED;
      if(this.vx > MAX_BALL_SPEED) this.vx = MAX_BALL_SPEED;
      if(this.vx < -MAX_BALL_SPEED) this.vx = -MAX_BALL_SPEED;
    }
  }

  class VolleyballSession {
    constructor(genome){
      this.genome = genome;
      this.leftTeam = [
        new Player(NET_X - 260, PLAYER_GROUND_Y, 'left', 0),
        new Player(NET_X - 150, PLAYER_GROUND_Y, 'left', 1)
      ];
      this.rightTeam = [
        new Player(NET_X + 260, PLAYER_GROUND_Y, 'right', 0),
        new Player(NET_X + 150, PLAYER_GROUND_Y, 'right', 1)
      ];
      this.players = [...this.leftTeam, ...this.rightTeam];
      this.done = false;
      this.steps = 0;
      this.crossings = 0;
      this.touches = 0;
      this.fitness = 0;
      this.spawnSide = Math.random() < 0.5 ? 'left' : 'right';
      this.ralliesRemaining = 2;
      this.mirrored = Math.random() < 0.5; // (9) mirror randomization
      this.coordinationTouched = {left: new Set(), right: new Set()};
      this.idleTicks = 0;
      this.currentRallyDuration = 0;
      this.longestRallyDuration = 0;
      this.balls = [];
      this.resetPlayers();
      this.resetBalls(this.spawnSide);
      this.lastTouchSide = this.spawnSide;
      this.lastBallX = this.primaryBall ? this.primaryBall.x : NET_X;
      // initialize per-team score tracking for competition mode
      this.teamScores = {left: 0, right: 0};
    }

    get primaryBall(){
      return this.balls[0];
    }

    resetPlayers(){
      const leftStarts = [NET_X - 260, NET_X - 150];
      const rightStarts = [NET_X + 260, NET_X + 150];
      this.leftTeam.forEach((player, idx)=> player.reset(leftStarts[idx], PLAYER_GROUND_Y));
      this.rightTeam.forEach((player, idx)=> player.reset(rightStarts[idx], PLAYER_GROUND_Y));
    }

    createBallForIndex(index, baseSide){
      const ball = new Ball();
      const spawn = index % 2 === 0 ? baseSide : (baseSide === 'left' ? 'right' : 'left');
      ball.reset(spawn);
      ball.x = clamp(ball.x + randRange(-35, 35), BORDER_PAD + ballRadius, FIELD_WIDTH - BORDER_PAD - ballRadius);
      ball.y = clamp(ball.y + randRange(-20, 20), CEILING_Y + ballRadius, FLOOR_Y - ballRadius);
      return ball;
    }

    resetBalls(baseSide){
      const desired = Math.max(1, Math.floor(config.ballCount));
      this.balls = [];
      for(let i=0;i<desired;i++){
        this.balls.push(this.createBallForIndex(i, baseSide));
      }
      if(this.primaryBall){
        this.lastBallX = this.primaryBall.x;
      }
    }

    onBallRadiusChanged(){
      this.balls.forEach((ball)=>{
        ball.x = clamp(ball.x, BORDER_PAD + ballRadius, FIELD_WIDTH - BORDER_PAD - ballRadius);
        ball.y = clamp(ball.y, CEILING_Y + ballRadius, FLOOR_Y - ballRadius);
      });
      if(this.primaryBall){
        this.lastBallX = this.primaryBall.x;
      }
    }

    onBallCountChanged(){
      this.endCurrentRally();
      this.resetBalls(this.spawnSide);
      this.currentRallyDuration = 0;
      this.lastTouchSide = this.spawnSide;
      this.done = false;
      this.steps = 0;
      this.idleTicks = 0;
      this.coordinationTouched.left.clear();
      this.coordinationTouched.right.clear();
    }

    endCurrentRally(){
      // in competition mode, finalize team scores and award bonus before resetting rally
      if(config.mode === 'competition'){
        this.finalizeCompetition();
        // reset team scores for next rally
        this.teamScores.left = 0;
        this.teamScores.right = 0;
      }
      if(this.currentRallyDuration > this.longestRallyDuration){
        this.longestRallyDuration = this.currentRallyDuration;
      }
      this.currentRallyDuration = 0;
    }

    // apply competition victory bonus based on team scores
    finalizeCompetition(){
      if(config.mode !== 'competition') return;
      const leftScore = this.teamScores.left ?? 0;
      const rightScore = this.teamScores.right ?? 0;
      if(leftScore > rightScore){
        this.fitness += COMPETITION_VICTORY_BONUS;
      } else if(rightScore > leftScore){
        this.fitness += COMPETITION_VICTORY_BONUS;
      }
    }

    getInputs(){
      const ball = this.primaryBall;
      if(!ball){
        return new Array(INPUT_COUNT).fill(0);
      }
      const bx = ball.x / FIELD_WIDTH;
      const by = ball.y / FIELD_HEIGHT;
      const bvx = ball.vx / MAX_BALL_SPEED;
      const bvy = ball.vy / MAX_BALL_SPEED;
      const players = [...this.leftTeam, ...this.rightTeam];
      const positions = players.map((p)=> [p.x / FIELD_WIDTH, p.y / FIELD_HEIGHT]);
      const relatives = players.map((p)=> [(ball.x - p.x) / FIELD_WIDTH, (ball.y - p.y) / FIELD_HEIGHT]);
      // compute environment sensors for each player: distances to ceiling, floor, net and back wall
      const env = players.map((p)=> {
        // distance from player to ceiling normalized (0 at ceiling, increases downward)
        const ceilDist = Math.max(0, (p.y - CEILING_Y)) / FIELD_HEIGHT;
        // distance from player to floor normalized (0 at floor, increases upward)
        const floorDist = Math.max(0, (FLOOR_Y - p.y)) / FIELD_HEIGHT;
        // horizontal distance to net normalized
        const netDist = Math.abs(NET_X - p.x) / FIELD_WIDTH;
        // horizontal distance to the back wall depending on side normalized
        let wallDist;
        if(p.side === 'left'){
          wallDist = Math.max(0, p.x - BORDER_PAD) / FIELD_WIDTH;
        } else {
          wallDist = Math.max(0, (FIELD_WIDTH - BORDER_PAD) - p.x) / FIELD_WIDTH;
        }
        return [ceilDist, floorDist, netDist, wallDist];
      });
      const touch = this.lastTouchSide === 'left' ? -1 : this.lastTouchSide === 'right' ? 1 : 0;
      // Compute additional sensors from each limb (both hands and both feet) to the environment and ball
      const limbSensors = [];
      players.forEach((p)=>{
        // ensure limb segments exist for arms and legs
        if(!p.armSegments || p.armSegments.length < 2){
          p.updateArms(ball, 0);
        }
        if(!p.legSegments || p.legSegments.length < 2){
          p.updateLegs(ball, 0);
        }
        const segs = [p.armSegments[0], p.armSegments[1], p.legSegments[0], p.legSegments[1]];
        segs.forEach((seg)=>{
          const lx = seg.handX !== undefined ? seg.handX : seg.footX;
          const ly = seg.handY !== undefined ? seg.handY : seg.footY;
          // distance from limb to ceiling and floor
          const ceilDistL = Math.max(0, (ly - CEILING_Y)) / FIELD_HEIGHT;
          const floorDistL = Math.max(0, (FLOOR_Y - ly)) / FIELD_HEIGHT;
          // horizontal distance to net
          const netDistL = Math.abs(NET_X - lx) / FIELD_WIDTH;
          // horizontal distance to back wall depending on player side
          let wallDistL;
          if(p.side === 'left'){
            wallDistL = Math.max(0, lx - BORDER_PAD) / FIELD_WIDTH;
          } else {
            wallDistL = Math.max(0, (FIELD_WIDTH - BORDER_PAD) - lx) / FIELD_WIDTH;
          }
          // relative position to ball for each limb
          const ballDxL = (ball.x - lx) / FIELD_WIDTH;
          const ballDyL = (ball.y - ly) / FIELD_HEIGHT;
          limbSensors.push(
            ceilDistL,
            floorDistL,
            netDistL,
            wallDistL,
            ballDxL,
            ballDyL
          );
        });
      });
      return [
        bx, by, bvx, bvy,
        positions[0][0], positions[0][1],
        positions[1][0], positions[1][1],
        positions[2][0], positions[2][1],
        positions[3][0], positions[3][1],
        relatives[0][0], relatives[0][1],
        relatives[1][0], relatives[1][1],
        relatives[2][0], relatives[2][1],
        relatives[3][0], relatives[3][1],
        // add environment sensor readings for each player
        env[0][0], env[0][1], env[0][2], env[0][3],
        env[1][0], env[1][1], env[1][2], env[1][3],
        env[2][0], env[2][1], env[2][2], env[2][3],
        env[3][0], env[3][1], env[3][2], env[3][3],
        touch,
        // append limb-specific sensor values
        ...limbSensors
      ];
    }

    getClosestBall(player){
      if(!this.balls.length) return null;
      let closest = this.balls[0];
      let bestDist = Infinity;
      for(const ball of this.balls){
        const dist = Math.hypot(ball.x - player.x, ball.y - player.y);
        if(dist < bestDist){
          bestDist = dist;
          closest = ball;
        }
      }
      return closest;
    }

    applyOutputs(outputs, dt){
      const commands = [
        {dx: outputs[OutputIndex.LEFT1_X] ?? 0, jump: outputs[OutputIndex.LEFT1_Y] ?? 0},
        {dx: outputs[OutputIndex.LEFT2_X] ?? 0, jump: outputs[OutputIndex.LEFT2_Y] ?? 0},
        {dx: outputs[OutputIndex.RIGHT1_X] ?? 0, jump: outputs[OutputIndex.RIGHT1_Y] ?? 0},
        {dx: outputs[OutputIndex.RIGHT2_X] ?? 0, jump: outputs[OutputIndex.RIGHT2_Y] ?? 0}
      ];

      let leftCommands = [commands[0], commands[1]];
      let rightCommands = [commands[2], commands[3]];
      if(this.mirrored){
        leftCommands = [commands[2], commands[3]];
        rightCommands = [commands[0], commands[1]];
      }

      this.leftTeam.forEach((player, idx)=>{
        const cmd = leftCommands[idx] ?? {dx: 0, jump: 0};
        const focusBall = this.getClosestBall(player);
        player.update(cmd.dx, cmd.jump, dt, focusBall);
      });
      this.rightTeam.forEach((player, idx)=>{
        const cmd = rightCommands[idx] ?? {dx: 0, jump: 0};
        const focusBall = this.getClosestBall(player);
        player.update(cmd.dx, cmd.jump, dt, focusBall);
      });
    }

    processPlayerContact(player, ball){
      const contact = player.tryHitBall(ball);
      if(!contact) return false;
      const upward = -contact.normalY;
      const angleBonus = Math.max(0, upward) * 3.0;
      let reward = TOUCH_REWARD + angleBonus;
      if(contact.type === 'arm'){
        reward += armStrikeBonus;
      } else if(contact.type === 'leg'){
        reward += legKickBonus;
      } else if(contact.type === 'head'){
        reward -= headTouchPenalty;
      }
      this.fitness += reward;
      this.lastTouchSide = player.side;
      this.coordinationTouched[player.side].add(player.slot);
      this.touches++;
      ball.lastSide = player.side;
      // update team score in competition mode
      if(config.mode === 'competition'){
        this.teamScores[player.side] = (this.teamScores[player.side] || 0) + reward;
      }
      return true;
    }

    resolveNetCollision(ball){
      const netLeft = NET_X - NET_WIDTH/2;
      const netRight = NET_X + NET_WIDTH/2;
      const netTop = NET_TOP;
      const netBottom = NET_TOP + NET_HEIGHT;
      let closestX = clamp(ball.x, netLeft, netRight);
      let closestY = clamp(ball.y, netTop, netBottom);
      let dx = ball.x - closestX;
      let dy = ball.y - closestY;
      const distSq = dx*dx + dy*dy;
      if(distSq >= ballRadius * ballRadius){
        return false;
      }
      let nx, ny;
      if(distSq === 0){
        const distances = [
          {dist: Math.abs(ball.x - netLeft), nx: -1, ny: 0, adjustX: netLeft},
          {dist: Math.abs(netRight - ball.x), nx: 1, ny: 0, adjustX: netRight},
          {dist: Math.abs(ball.y - netTop), nx: 0, ny: -1, adjustY: netTop},
          {dist: Math.abs(netBottom - ball.y), nx: 0, ny: 1, adjustY: netBottom}
        ].sort((a,b)=> a.dist - b.dist);
        const closest = distances[0];
        nx = closest.nx;
        ny = closest.ny;
        if(closest.adjustX !== undefined) closestX = closest.adjustX;
        if(closest.adjustY !== undefined) closestY = closest.adjustY;
      } else {
        const dist = Math.sqrt(distSq);
        nx = dx / dist;
        ny = dy / dist;
      }
      const dot = ball.vx * nx + ball.vy * ny;
      ball.vx -= 2 * dot * nx;
      ball.vy -= 2 * dot * ny;
      ball.vx *= NET_BOUNCE_DAMPING;
      ball.vy *= NET_BOUNCE_DAMPING;
      ball.x = closestX + nx * (ballRadius + 0.5);
      ball.y = closestY + ny * (ballRadius + 0.5);
      ball.vx = clamp(ball.vx, -MAX_BALL_SPEED, MAX_BALL_SPEED);
      ball.vy = clamp(ball.vy, -MAX_BALL_SPEED, MAX_BALL_SPEED);
      ball.lastSide = ball.x < NET_X ? 'left' : 'right';

      // (5) small penalty for net clip (but don't end run)
      this.fitness -= NET_CLIP_PENALTY;
      // update team score in competition mode
      if(config.mode === 'competition'){
        const penaltySide = ball.lastSide || this.lastTouchSide;
        if(penaltySide){
          this.teamScores[penaltySide] = (this.teamScores[penaltySide] || 0) - NET_CLIP_PENALTY;
        }
      }
      return true;
    }

    resolveWallBounce(ball){
      let bounced = false;
      const leftWall = BORDER_PAD;
      const rightWall = FIELD_WIDTH - BORDER_PAD;
      if(ball.x - ballRadius <= leftWall){
        ball.x = leftWall + ballRadius;
        ball.vx = Math.abs(ball.vx) * WALL_BOUNCE_DAMPING;
        bounced = true;
      } else if(ball.x + ballRadius >= rightWall){
        ball.x = rightWall - ballRadius;
        ball.vx = -Math.abs(ball.vx) * WALL_BOUNCE_DAMPING;
        bounced = true;
      }
      if(bounced){
        this.fitness += WALL_BOUNCE_REWARD; // tiny encouragement to recover
        // update team score in competition mode
        if(config.mode === 'competition'){
          const bounceSide = ball.lastSide || this.lastTouchSide;
          if(bounceSide){
            this.teamScores[bounceSide] = (this.teamScores[bounceSide] || 0) + WALL_BOUNCE_REWARD;
          }
        }
      }
      return bounced;
    }

    handleBall(ball){
      const sortedPlayers = this.players.slice().sort((a,b)=>{
        const da = Math.hypot(ball.x - a.x, ball.y - a.y);
        const db = Math.hypot(ball.x - b.x, ball.y - b.y);
        return da - db;
      });
      for(const player of sortedPlayers){
        if(this.processPlayerContact(player, ball)){
          break;
        }
      }

      if(ball.y + ballRadius >= FLOOR_Y){
        // when the ball hits the floor, award a point to the opposing team in competition mode
        if(config.mode === 'competition'){
          const floorSide = ball.x < NET_X ? 'left' : 'right';
          const opponent = floorSide === 'left' ? 'right' : 'left';
          cumulativeScores[opponent] = (cumulativeScores[opponent] || 0) + 1;
          // also record the point in this session's team scores so overlay reflects it before reset
          this.teamScores[opponent] = (this.teamScores[opponent] || 0) + 1;
        }
        this.done = true;
        this.endCurrentRally();
        return true;
      }

      this.resolveNetCollision(ball);
      this.resolveWallBounce(ball);

      const side = ball.x < NET_X ? 'left' : 'right';
      if(side !== ball.lastSide){
        if(ball.y - ballRadius <= NET_TOP){
          this.crossings++;
          this.fitness += CROSS_REWARD;
          // update team score in competition mode
          if(config.mode === 'competition'){
            const last = this.lastTouchSide;
            if(last === 'left' || last === 'right'){
              this.teamScores[last] = (this.teamScores[last] || 0) + CROSS_REWARD;
            }
          }
          if(this.coordinationTouched.left.size >= 1 && this.coordinationTouched.right.size >= 1){
            this.fitness += 10;
          }
          if(this.coordinationTouched.left.size >= TEAM_SIZE){
            this.fitness += 4;
          }
          if(this.coordinationTouched.right.size >= TEAM_SIZE){
            this.fitness += 4;
          }
          this.coordinationTouched.left.clear();
          this.coordinationTouched.right.clear();
          this.spawnSide = side === 'left' ? 'right' : 'left';
        } else {
          this.done = true;
          this.endCurrentRally();
          return true;
        }
        ball.lastSide = side;
      }
      return false;
    }

    update(dt){
      if(this.done) return;
      if(this.primaryBall){
        this.currentRallyDuration += dt;
      }

      // Dynamic step budget grows with generation (6)
      const maxSteps = MAX_STEPS_BASE + (generation - 1) * 50;

      const outputs = this.genome.feedForward(this.getInputs());
      this.applyOutputs(outputs, dt);
      this.balls.forEach((ball)=> ball.update(dt));
      for(const ball of this.balls){
        if(this.handleBall(ball)){
          break;
        }
      }
      this.steps++;

      const primary = this.primaryBall;
      if(primary){
        // Survival + motion-based shaping (2)
        const speedNorm = Math.min(1, Math.hypot(primary.vx, primary.vy) / MAX_BALL_SPEED);
        this.fitness += SURVIVAL_REWARD + 0.02 * speedNorm;
        // update team score in competition mode
        if(config.mode === 'competition'){
          const survSide = this.lastTouchSide || primary.lastSide;
          if(survSide){
            const delta = SURVIVAL_REWARD + 0.02 * speedNorm;
            this.teamScores[survSide] = (this.teamScores[survSide] || 0) + delta;
          }
        }

        // Anti-idle penalty if ball x hardly changes for many ticks (2)
        const dx = Math.abs(primary.x - this.lastBallX);
        if(dx < 0.8){
          this.idleTicks++;
          if(this.idleTicks % 60 === 0){ // about each second idle
            this.fitness -= 2.0;
          }
        } else {
          this.idleTicks = 0;
        }
        this.lastBallX = primary.x;
      }

      if(this.steps >= maxSteps){
        this.done = true;
        this.endCurrentRally();
      }

      // Allow a limited rally reset if progress was made
      if(this.done && this.crossings > 0 && this.ralliesRemaining > 0){
        this.ralliesRemaining--;
        this.endCurrentRally();
        this.resetPlayers();
        this.resetBalls(this.spawnSide);
        this.lastTouchSide = this.spawnSide;
        this.coordinationTouched.left.clear();
        this.coordinationTouched.right.clear();
        this.done = false;
        this.steps = 0;
        this.spawnSide = this.spawnSide === 'left' ? 'right' : 'left';
      }
    }
  }

  function scheduleConfigRefresh(){ needsConfigRefresh = true; }

  function readControls(){
    const prevBallCount = config.ballCount;
    const prevBallRadius = config.ballRadius;
    config.populationSize = Number(Q('slPopulation').value);
    config.initialHidden = Number(Q('slHidden').value);
    config.mutationRate = Number(Q('slMutRate').value);
    config.addConnectionRate = Number(Q('slAddConn').value);
    config.addNodeRate = Number(Q('slAddNode').value);
    config.simSpeed = Number(Q('slSimSpeed').value);
    config.ballCount = Number(Q('slBallCount').value);
    config.ballRadius = Number(Q('slBallRadius').value);
    config.armReward = Number(Q('slArmBonus').value);
    config.kickReward = Number(Q('slKickBonus').value);
    config.headPenalty = Number(Q('slHeadPenalty').value);
    armStrikeBonus = config.armReward;
    legKickBonus = config.kickReward;
    headTouchPenalty = config.headPenalty;
    baseMutationAtStart = config.mutationRate;

    // update mode and sensor visibility from controls if present
    const modeSelect = Q('selMode');
    if(modeSelect){
      config.mode = modeSelect.value;
    }
    const sensorCheck = Q('cbShowSensors');
    if(sensorCheck){
      config.showSensors = sensorCheck.checked;
    }

    const radiusChanged = prevBallRadius !== config.ballRadius;
    const countChanged = prevBallCount !== config.ballCount;
    ballRadius = config.ballRadius;
    if(currentSession){
      if(radiusChanged){
        currentSession.onBallRadiusChanged();
      }
      if(countChanged){
        currentSession.onBallCountChanged();
      }
    }
  }

  function restartTraining(){
    readControls();
    population = new Population({
      populationSize: config.populationSize,
      inputCount: INPUT_COUNT,
      outputCount: OUTPUT_COUNT
    });
    population.injectHiddenNodes(config.initialHidden);
    population.speciate();
    generation = 1;
    genomeIndex = 0;
    bestFitness = 0;
    totalSpecies = population.species.length || 1;
    evaluationOrder = population.genomes.slice();
    startCurrentGenome();
    updateStats();
  }

  function startCurrentGenome(){
    if(!evaluationOrder.length){
      currentSession = null;
      return;
    }
    const genome = evaluationOrder[genomeIndex];
    genome.fitness = 0;
    currentSession = new VolleyballSession(genome);
    updateStats();
  }

  function finishGenome(){
    if(!currentSession) return;
    const genome = evaluationOrder[genomeIndex];
    genome.fitness = Math.max(genome.fitness, currentSession.fitness);
    if(genome.fitness > bestFitness){
      bestFitness = genome.fitness;
    }
    genomeIndex++;
    if(genomeIndex >= evaluationOrder.length){
      // (7) Auto-decay mutation slightly each generation, lower-bounded
      const decayFactor = 0.98;
      config.mutationRate = Math.max(6, Math.min(80, config.mutationRate * decayFactor));

      population.evolve(config);
      evaluationOrder = population.genomes.slice();
      genomeIndex = 0;
      generation++;
      totalSpecies = population.species.length || 1;
    }
    startCurrentGenome();
  }

  function updateStats(){
    Q('stat-generation').textContent = generation;
    Q('stat-genome').textContent = evaluationOrder.length ? `${genomeIndex + 1} / ${evaluationOrder.length}` : '0 / 0';
    Q('stat-best').textContent = bestFitness.toFixed(1);
    const longest = currentSession ? Math.max(currentSession.longestRallyDuration, currentSession.currentRallyDuration) : 0;
    Q('stat-longest').textContent = `${longest.toFixed(2)} s`;
    Q('stat-crossings').textContent = currentSession ? currentSession.crossings : 0;
    Q('stat-species').textContent = totalSpecies;
    Q('stat-mutation').textContent = `${config.mutationRate.toFixed(1)}%`;
  }

  function drawBackground(){
    const gradient = ctx.createLinearGradient(0, 0, 0, FIELD_HEIGHT);
    gradient.addColorStop(0, '#0b1435');
    gradient.addColorStop(1, '#030817');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, FIELD_WIDTH, FIELD_HEIGHT);
    ctx.strokeStyle = 'rgba(148,163,209,0.35)';
    ctx.lineWidth = 2;
    ctx.strokeRect(BORDER_PAD, BORDER_PAD, FIELD_WIDTH-2*BORDER_PAD, FIELD_HEIGHT-2*BORDER_PAD);
    ctx.fillStyle = 'rgba(14,30,70,0.65)';
    ctx.fillRect(BORDER_PAD, FIELD_HEIGHT-100, FIELD_WIDTH-2*BORDER_PAD, 80);
  }

  function drawNet(){
    ctx.save();
    ctx.fillStyle = 'rgba(56,189,248,0.35)';
    ctx.fillRect(NET_X - NET_WIDTH/2, NET_TOP, NET_WIDTH, NET_HEIGHT);
    ctx.strokeStyle = 'rgba(148,163,209,0.55)';
    ctx.lineWidth = 2;
    ctx.strokeRect(NET_X - NET_WIDTH/2, NET_TOP, NET_WIDTH, NET_HEIGHT);
    ctx.restore();
  }

  function drawPlayer(player, hue){
    const gradient = ctx.createRadialGradient(player.x, player.y, 10, player.x, player.y, PLAYER_RADIUS + 6);
    gradient.addColorStop(0, `hsla(${hue},85%,74%,0.95)`);
    gradient.addColorStop(1, `hsla(${hue},60%,42%,0.32)`);

    ctx.save();
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.strokeStyle = `hsla(${hue},72%,62%,0.55)`;
    ctx.lineWidth = LEG_DRAW_WIDTH;
    ctx.fillStyle = `hsla(${hue},82%,72%,0.35)`;
    (player.legSegments || []).forEach((leg)=>{
      if(!leg) return;
      ctx.beginPath();
      ctx.moveTo(leg.hipX, leg.hipY);
      ctx.lineTo(leg.kneeX, leg.kneeY);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(leg.kneeX, leg.kneeY);
      ctx.lineTo(leg.footX, leg.footY);
      ctx.stroke();

      ctx.beginPath();
      ctx.arc(leg.kneeX, leg.kneeY, 7, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(leg.footX, leg.footY, (leg.footRadius ?? FOOT_HIT_RADIUS) - 3, 0, TAU);
      ctx.fill();
      ctx.stroke();
    });
    ctx.restore();

    ctx.save();
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.strokeStyle = `hsla(${hue},85%,72%,0.6)`;
    ctx.lineWidth = ARM_DRAW_WIDTH;
    ctx.fillStyle = `hsla(${hue},92%,86%,0.4)`;
    (player.armSegments || []).forEach((arm)=>{
      if(!arm) return;
      ctx.beginPath();
      ctx.moveTo(arm.shoulderX, arm.shoulderY);
      ctx.lineTo(arm.elbowX, arm.elbowY);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(arm.elbowX, arm.elbowY);
      ctx.lineTo(arm.handX, arm.handY);
      ctx.stroke();

      ctx.beginPath();
      ctx.arc(arm.elbowX, arm.elbowY, 6, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(arm.handX, arm.handY, (arm.handRadius ?? HAND_HIT_RADIUS) - 2, 0, TAU);
      ctx.fill();
      ctx.stroke();
    });
    ctx.restore();

    ctx.save();
    ctx.strokeStyle = `hsla(${hue},65%,65%,0.45)`;
    ctx.lineWidth = 10;
    ctx.beginPath();
    ctx.moveTo(player.x, player.y - PLAYER_RADIUS * 0.8);
    ctx.lineTo(player.x, player.y + PLAYER_RADIUS * 0.95);
    ctx.stroke();
    ctx.restore();

    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(player.x, player.y, PLAYER_RADIUS, 0, TAU);
    ctx.fill();
    ctx.lineWidth = 6;
    ctx.strokeStyle = 'rgba(2,6,23,0.6)';
    ctx.stroke();
    ctx.lineWidth = 3;
    ctx.strokeStyle = 'rgba(241,245,255,0.45)';
    ctx.beginPath();
    ctx.arc(player.x, player.y, PLAYER_RADIUS - 10, 0, TAU);
    ctx.stroke();
  }

  function drawBall(ball){
    const gradient = ctx.createRadialGradient(ball.x - ball.vx*0.04, ball.y - ball.vy*0.04, 6, ball.x, ball.y, ballRadius);
    gradient.addColorStop(0, 'rgba(248,250,252,0.95)');
    gradient.addColorStop(1, 'rgba(56,189,248,0.45)');
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ballRadius, 0, TAU);
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(56,189,248,0.65)';
    ctx.stroke();
  }

  // ===== Sensor visualization and persistence helpers =====
  function drawSensors(){
    if(!currentSession) return;
    const ball = currentSession.primaryBall;
    if(!ball) return;
    const players = currentSession.players;
    // lines from each player to the ball
    players.forEach((player)=>{
      // color by side: blue-ish for left, pink-ish for right
      const sideColor = player.side === 'left'
        ? 'rgba(56,189,248,0.4)'
        : 'rgba(244,114,182,0.4)';
      ctx.strokeStyle = sideColor;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(player.x, player.y);
      ctx.lineTo(ball.x, ball.y);
      ctx.stroke();
      // lines to other players to indicate relative positioning
      currentSession.players.forEach((other)=>{
        if(other === player) return;
        ctx.strokeStyle = 'rgba(148,163,209,0.2)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(player.x, player.y);
        ctx.lineTo(other.x, other.y);
        ctx.stroke();
      });
      // environment sensor lines: draw to ceiling, floor, net and back wall for the player's body
      ctx.strokeStyle = 'rgba(255,255,255,0.25)';
      ctx.lineWidth = 1;
      // line to ceiling
      ctx.beginPath();
      ctx.moveTo(player.x, player.y);
      ctx.lineTo(player.x, CEILING_Y);
      ctx.stroke();
      // line to floor
      ctx.beginPath();
      ctx.moveTo(player.x, player.y);
      ctx.lineTo(player.x, FLOOR_Y);
      ctx.stroke();
      // line horizontally to net
      ctx.beginPath();
      ctx.moveTo(player.x, player.y);
      ctx.lineTo(NET_X, player.y);
      ctx.stroke();
      // line horizontally to back wall depending on side
      const wallX = player.side === 'left' ? BORDER_PAD : (FIELD_WIDTH - BORDER_PAD);
      ctx.beginPath();
      ctx.moveTo(player.x, player.y);
      ctx.lineTo(wallX, player.y);
      ctx.stroke();
      // draw sensor lines from both hands and both feet to the ball and environment
      // ensure limb segments exist
      if(!player.armSegments || player.armSegments.length < 2) player.updateArms(ball, 0);
      if(!player.legSegments || player.legSegments.length < 2) player.updateLegs(ball, 0);
      const limbs = [player.armSegments[0], player.armSegments[1], player.legSegments[0], player.legSegments[1]];
      limbs.forEach((seg)=>{
        const lx = seg.handX !== undefined ? seg.handX : seg.footX;
        const ly = seg.handY !== undefined ? seg.handY : seg.footY;
        // lines to ceiling and floor
        ctx.strokeStyle = 'rgba(255,255,255,0.25)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(lx, ly);
        ctx.lineTo(lx, CEILING_Y);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(lx, ly);
        ctx.lineTo(lx, FLOOR_Y);
        ctx.stroke();
        // line to net
        ctx.beginPath();
        ctx.moveTo(lx, ly);
        ctx.lineTo(NET_X, ly);
        ctx.stroke();
        // line to back wall
        const wX = player.side === 'left' ? BORDER_PAD : (FIELD_WIDTH - BORDER_PAD);
        ctx.beginPath();
        ctx.moveTo(lx, ly);
        ctx.lineTo(wX, ly);
        ctx.stroke();
        // line to ball from each limb
        const limbColor = player.side === 'left'
          ? 'rgba(56,189,248,0.4)'
          : 'rgba(244,114,182,0.4)';
        ctx.strokeStyle = limbColor;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(lx, ly);
        ctx.lineTo(ball.x, ball.y);
        ctx.stroke();
      });
    });
    // draw ball velocity vector
    ctx.strokeStyle = 'rgba(255,255,255,0.4)';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(ball.x, ball.y);
    ctx.lineTo(ball.x + ball.vx * 0.3, ball.y + ball.vy * 0.3);
    ctx.stroke();
  }

  // Serialize a genome into a plain object for saving
  function serializeGenome(genome){
    return {
      nodes: Array.from(genome.nodes.values()).map((n)=> ({id:n.id, type:n.type, layer:n.layer})),
      connections: genome.connections.map((c)=> ({from:c.from, to:c.to, weight:c.weight, enabled:c.enabled, innovation:c.innovation})),
      fitness: genome.fitness,
      adjustedFitness: genome.adjustedFitness
    };
  }

  // Serialize the entire population
  function serializePopulation(pop){
    return {
      size: pop.size,
      inputCount: pop.inputCount,
      outputCount: pop.outputCount,
      nextNodeId: pop.nextNodeId,
      innovation: {
        next: pop.innovationTracker.next,
        lookup: Array.from(pop.innovationTracker.lookup.entries())
      },
      genomes: pop.genomes.map((g)=> serializeGenome(g))
    };
  }

  // Deserialize a population from saved data
  function deserializePopulation(data){
    const pop = new Population({
      populationSize: data.size,
      inputCount: data.inputCount,
      outputCount: data.outputCount
    });
    // restore innovation tracker
    pop.innovationTracker.next = data.innovation.next;
    pop.innovationTracker.lookup = new Map(data.innovation.lookup);
    pop.nextNodeId = data.nextNodeId;
    // rebuild genomes
    pop.genomes = [];
    data.genomes.forEach((gData)=>{
      const g = new Genome(pop);
      // clear default base nodes and use saved nodes
      g.nodes.clear();
      g._outputNodes = null;
      g.connectionKeys = new Set();
      g.connectionByInnovation = new Map();
      g.connections = [];
      g.cacheDirty = true;
      g.incomingCache = null;
      g.sortedNodesCache = null;
      g.fitness = gData.fitness ?? 0;
      g.adjustedFitness = gData.adjustedFitness ?? 0;
      // restore nodes
      gData.nodes.forEach((n)=>{
        g.nodes.set(n.id, new NodeGene(n.id, n.type, n.layer));
      });
      // restore connections
      gData.connections.forEach((c)=>{
        const conn = new ConnectionGene(c.from, c.to, c.weight, c.enabled, c.innovation);
        g.connections.push(conn);
        g.connectionKeys.add(`${c.from}->${c.to}`);
        g.connectionByInnovation.set(c.innovation, conn);
      });
      g._markDirty();
      pop.genomes.push(g);
    });
    pop.species = [];
    pop.speciate();
    return pop;
  }

  // Save current training progress to localStorage
  function saveProgress(){
    if(!population) return;
    const data = {
      generation,
      bestFitness,
      config: {
        populationSize: config.populationSize,
        mutationRate: config.mutationRate,
        addConnectionRate: config.addConnectionRate,
        addNodeRate: config.addNodeRate,
        initialHidden: config.initialHidden,
        simSpeed: config.simSpeed,
        ballCount: config.ballCount,
        ballRadius: config.ballRadius,
        armReward: config.armReward,
        kickReward: config.kickReward,
        headPenalty: config.headPenalty,
        mode: config.mode,
        showSensors: config.showSensors
      },
      population: serializePopulation(population),
      cumulativeScores
    };
    try{
      localStorage.setItem('volleySave', JSON.stringify(data));
      alert('Progress saved.');
    } catch(err){
      console.error(err);
      alert('Failed to save progress.');
    }
  }

  // Load training progress from localStorage
  function loadProgress(){
    const raw = localStorage.getItem('volleySave');
    if(!raw){
      alert('No saved progress found.');
      return;
    }
    try{
      const data = JSON.parse(raw);
      // restore config
      config.populationSize = data.config.populationSize;
      config.mutationRate = data.config.mutationRate;
      config.addConnectionRate = data.config.addConnectionRate;
      config.addNodeRate = data.config.addNodeRate;
      config.initialHidden = data.config.initialHidden;
      config.simSpeed = data.config.simSpeed;
      config.ballCount = data.config.ballCount;
      config.ballRadius = data.config.ballRadius;
      config.armReward = data.config.armReward;
      config.kickReward = data.config.kickReward;
      config.headPenalty = data.config.headPenalty;
      config.mode = data.config.mode || config.mode;
      config.showSensors = data.config.showSensors || false;
      // update related variables
      armStrikeBonus = config.armReward;
      legKickBonus = config.kickReward;
      headTouchPenalty = config.headPenalty;
      ballRadius = config.ballRadius;
      baseMutationAtStart = config.mutationRate;
      // restore population
      population = deserializePopulation(data.population);
      // restore cumulative scores if saved
      cumulativeScores = data.cumulativeScores || {left: 0, right: 0};
      generation = data.generation || 1;
      bestFitness = data.bestFitness || 0;
      totalSpecies = population.species.length || 1;
      genomeIndex = 0;
      evaluationOrder = population.genomes.slice();
      // update sliders and UI
      Q('slPopulation').value = config.populationSize;
      Q('slHidden').value = config.initialHidden;
      Q('slMutRate').value = config.mutationRate;
      Q('slAddConn').value = config.addConnectionRate;
      Q('slAddNode').value = config.addNodeRate;
      Q('slSimSpeed').value = config.simSpeed;
      Q('slBallCount').value = config.ballCount;
      Q('slBallRadius').value = config.ballRadius;
      Q('slArmBonus').value = config.armReward;
      Q('slKickBonus').value = config.kickReward;
      Q('slHeadPenalty').value = config.headPenalty;
      // update labels
      scheduleConfigRefresh();
      // update mode and sensors UI
      const modeSelect2 = Q('selMode');
      if(modeSelect2) modeSelect2.value = config.mode;
      const sensorCheck2 = Q('cbShowSensors');
      if(sensorCheck2) sensorCheck2.checked = config.showSensors;
      // restart training from loaded state
      startCurrentGenome();
      updateStats();
    } catch(err){
      console.error(err);
      alert('Failed to load progress.');
    }
  }

  function drawOverlay(){
    if(!currentSession) return;
    // Use a light color for overlay text so it stands out against the dark background
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.font = '16px "Inter", system-ui';
    ctx.fillText(`Fitness: ${currentSession.fitness.toFixed(1)}`, 30, 48);
    ctx.fillText(`Touches: ${currentSession.touches}`, 30, 70);
    ctx.fillText(`Crossings: ${currentSession.crossings}`, 30, 92);
    ctx.fillText(`Mirrored: ${currentSession.mirrored ? 'yes' : 'no'}`, 30, 114);
    const longest = Math.max(currentSession.longestRallyDuration, currentSession.currentRallyDuration);
    ctx.fillText(`Longest rally: ${longest.toFixed(2)}s`, 30, 136);

    // in competition mode, display team scores
    if(config.mode === 'competition' && currentSession){
      const ls = currentSession.teamScores?.left ?? 0;
      const rs = currentSession.teamScores?.right ?? 0;
      ctx.fillText(`Left score: ${ls.toFixed(1)}`, 30, 158);
      ctx.fillText(`Right score: ${rs.toFixed(1)}`, 30, 180);
      // display cumulative scores across all rallies
      ctx.fillText(`Total left: ${cumulativeScores.left}`, 30, 202);
      ctx.fillText(`Total right: ${cumulativeScores.right}`, 30, 224);
    }
  }

  function render(){
    drawBackground();
    drawNet();
    if(currentSession){
      const leftHues = [160, 190];
      const rightHues = [320, 300];
      currentSession.leftTeam.forEach((player, idx)=> drawPlayer(player, leftHues[idx % leftHues.length]));
      currentSession.rightTeam.forEach((player, idx)=> drawPlayer(player, rightHues[idx % rightHues.length]));
      currentSession.balls.forEach((ball)=> drawBall(ball));
      // optionally draw sensor lines to visualize inputs
      if(config.showSensors){
        drawSensors();
      }
    }
    drawOverlay();
  }

  function loop(){
    requestAnimationFrame(loop);
    if(needsConfigRefresh){
      readControls();
      needsConfigRefresh = false;
    }
    if(!currentSession){
      render();
      return;
    }
    const steps = Math.max(1, Math.floor(config.simSpeed));
    for(let i=0;i<steps;i++){
      currentSession.update(SIM_DT);
      if(currentSession.done){
        finishGenome();
        break;
      }
    }
    render();
    updateStats();
  }

  bindRange('slPopulation','lbPopulation',(v)=> `${v} genomes`);
  bindRange('slHidden','lbHidden',(v)=> `${v} node${v===1?'':'s'}`);
  bindRange('slMutRate','lbMutRate',(v)=> `${v}%`);
  bindRange('slAddConn','lbAddConn',(v)=> `${v}%`);
  bindRange('slAddNode','lbAddNode',(v)=> `${v}%`);
  bindRange('slSimSpeed','lbSimSpeed',(v)=> `${v}Ã—`);
  bindRange('slBallCount','lbBallCount',(v)=> `${v} ball${v===1?'':'s'}`);
  bindRange('slBallRadius','lbBallRadius',(v)=> `${v}px`);
  bindRange('slArmBonus','lbArmBonus',(v)=> `${Number(v).toFixed(1)}`);
  bindRange('slKickBonus','lbKickBonus',(v)=> `${Number(v).toFixed(1)}`);
  bindRange('slHeadPenalty','lbHeadPenalty',(v)=> `${Number(v).toFixed(1)}`);

  Q('btnRestart').addEventListener('click', restartTraining);

  // hook up new UI controls
  const sensorCheckCtrl = Q('cbShowSensors');
  if(sensorCheckCtrl){
    sensorCheckCtrl.checked = config.showSensors;
    sensorCheckCtrl.addEventListener('change', ()=> {
      config.showSensors = sensorCheckCtrl.checked;
    });
  }
  const modeSelectCtrl = Q('selMode');
  if(modeSelectCtrl){
    modeSelectCtrl.value = config.mode;
    modeSelectCtrl.addEventListener('change', ()=> {
      config.mode = modeSelectCtrl.value;
      restartTraining();
    });
  }
  const saveBtn = Q('btnSave');
  if(saveBtn){
    saveBtn.addEventListener('click', saveProgress);
  }
  const loadBtn = Q('btnLoad');
  if(loadBtn){
    loadBtn.addEventListener('click', loadProgress);
  }

  restartTraining();
  loop();
  </script>
</body>
</html>
