<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Vollylab Humanoid NEAT Playground</title>
<style>
:root {
  color-scheme: dark;
  --bg: #0a0f1d;
  --panel: rgba(16, 26, 52, 0.92);
  --ink: #f5f8ff;
  --muted: #9aa7d7;
  --accent: #7c5cff;
  --accent-2: #2dd4bf;
  --warning: #f8aa4b;
  font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
}
* { box-sizing: border-box; }
body {
  margin: 0;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  background: radial-gradient(circle at 24% 18%, rgba(53, 87, 255, 0.25), rgba(9, 18, 44, 0.95)), linear-gradient(160deg, #0a132b, #050b18 65%);
  color: var(--ink);
}
header {
  position: sticky;
  top: 0;
  z-index: 30;
  background: rgba(4, 10, 32, 0.82);
  border-bottom: 1px solid rgba(126, 141, 199, 0.35);
  padding: 20px 40px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  backdrop-filter: blur(12px);
}
header h1 { margin: 0; font-size: 20px; letter-spacing: 0.06em; text-transform: uppercase; }
header nav { display: flex; gap: 16px; align-items: center; }
header nav a {
  color: var(--ink);
  text-decoration: none;
  font-size: 14px;
  padding: 8px 18px;
  border-radius: 999px;
  border: 1px solid rgba(141, 162, 255, 0.45);
  background: linear-gradient(120deg, rgba(124, 92, 255, 0.24), rgba(45, 212, 191, 0.2));
}
main {
  flex: 1;
  display: grid;
  grid-template-columns: minmax(620px, 1fr) 360px;
  gap: 28px;
  padding: 32px 40px 48px;
}
#sim-wrapper {
  position: relative;
  border-radius: 24px;
  border: 1px solid rgba(126, 141, 199, 0.4);
  background: linear-gradient(180deg, rgba(2, 10, 38, 0.85), rgba(3, 10, 28, 0.92));
  box-shadow: 0 22px 60px rgba(0, 0, 0, 0.35);
  padding: 18px;
  display: flex;
  flex-direction: column;
  gap: 16px;
}
canvas { border-radius: 18px; width: 100%; height: auto; background: #040b1b; border: 1px solid rgba(120, 143, 210, 0.35); }
#hud {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
  gap: 12px;
}
.hud-card {
  background: rgba(10, 18, 46, 0.78);
  padding: 10px 14px;
  border-radius: 12px;
  border: 1px solid rgba(124, 142, 214, 0.35);
}
.hud-label { font-size: 11px; text-transform: uppercase; letter-spacing: 0.12em; color: var(--muted); }
.hud-value { font-size: 20px; font-weight: 700; }
.aside {
  display: flex;
  flex-direction: column;
  gap: 18px;
}
details.panel {
  border-radius: 18px;
  border: 1px solid rgba(116, 132, 204, 0.4);
  background: var(--panel);
  padding: 16px 18px 10px;
  box-shadow: 0 22px 40px rgba(0, 0, 0, 0.28);
}
details.panel > summary {
  cursor: pointer;
  font-weight: 600;
  letter-spacing: 0.04em;
  font-size: 15px;
  list-style: none;
}
details.panel[open] > summary { margin-bottom: 12px; }
summary::-webkit-details-marker { display: none; }
.control-row {
  display: grid;
  grid-template-columns: 1fr auto;
  gap: 10px;
  align-items: center;
  margin-bottom: 10px;
}
.control-row label { font-size: 12px; color: var(--muted); }
.control-row input[type="number"], .control-row input[type="text"] {
  width: 90px;
  border-radius: 10px;
  border: 1px solid rgba(116, 132, 204, 0.6);
  padding: 6px 8px;
  background: rgba(8, 16, 38, 0.82);
  color: var(--ink);
}
.control-row input[type="range"] { width: 100%; accent-color: var(--accent-2); }
button, .btn {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  border-radius: 12px;
  border: 1px solid rgba(124, 92, 255, 0.65);
  background: linear-gradient(120deg, rgba(124, 92, 255, 0.35), rgba(45, 212, 191, 0.25));
  color: var(--ink);
  padding: 10px 16px;
  font-weight: 600;
  cursor: pointer;
  transition: transform 0.18s ease, box-shadow 0.18s ease;
}
button:hover { transform: translateY(-1px); box-shadow: 0 10px 18px rgba(124, 92, 255, 0.35); }
#awareness {
  display: grid;
  grid-template-columns: 1fr;
  gap: 8px;
}
#awareness canvas {
  background: rgba(5, 12, 32, 0.8);
  border-radius: 12px;
  border: 1px solid rgba(116, 132, 204, 0.35);
}
#fitness-breakdown {
  display: grid;
  grid-template-columns: 1fr;
  gap: 8px;
}
.fitness-bar {
  height: 10px;
  border-radius: 6px;
  background: rgba(37, 52, 96, 0.7);
  position: relative;
  overflow: hidden;
}
.fitness-bar span {
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  border-radius: inherit;
  background: linear-gradient(120deg, rgba(124, 92, 255, 0.7), rgba(45, 212, 191, 0.7));
}
.chart {
  height: 90px;
  background: rgba(5, 12, 32, 0.8);
  border-radius: 12px;
  border: 1px solid rgba(116, 132, 204, 0.35);
}
#play-hint { font-size: 12px; color: var(--muted); line-height: 1.6; }
@media (max-width: 1200px) {
  main { grid-template-columns: 1fr; }
  .aside { order: -1; }
}
</style>
</head>
<body>
<header>
  <h1>Vollylab Humanoid NEAT Playground</h1>
  <nav>
    <a href="index.html">Arena</a>
    <a href="volleyball.html" aria-current="page">Vollylab</a>
    <a href="learn-neat.html">Learn NEAT</a>
  </nav>
</header>
<main>
  <section id="sim-wrapper" aria-label="simulation">
    <div style="display:flex; gap:12px; align-items:center; justify-content:space-between;">
      <div style="display:flex; gap:8px; align-items:center;">
        <button id="btnPlayMode">Switch to Train</button>
        <button id="btnStart">Start</button>
        <button id="btnReset">Reset Population</button>
        <button id="btnSave">Save Best</button>
        <button id="btnLoad">Load Genome</button>
      </div>
      <div id="mode-indicator" style="font-size:13px; color:var(--muted);">Mode: Play</div>
    </div>
    <canvas id="sim-canvas" width="960" height="540" aria-label="simulation canvas"></canvas>
    <div id="hud">
      <div class="hud-card"><div class="hud-label">Generation</div><div class="hud-value" id="hud-generation">0</div></div>
      <div class="hud-card"><div class="hud-label">Best fitness</div><div class="hud-value" id="hud-best">0</div></div>
      <div class="hud-card"><div class="hud-label">Average fitness</div><div class="hud-value" id="hud-avg">0</div></div>
      <div class="hud-card"><div class="hud-label">Alive</div><div class="hud-value" id="hud-alive">1</div></div>
      <div class="hud-card"><div class="hud-label">Success rate</div><div class="hud-value" id="hud-success">0%</div></div>
    </div>
  </section>
  <aside class="aside" aria-label="controls">
    <details class="panel" open>
      <summary>Settings</summary>
      <div class="control-row"><label for="gravityInput">Gravity</label><input id="gravityInput" type="number" step="0.1" value="18"></div>
      <div class="control-row"><label for="timeScaleInput">Time scale</label><input id="timeScaleInput" type="number" step="0.1" value="1"></div>
      <div class="control-row"><label for="rayCountInput">Ray count</label><input id="rayCountInput" type="number" min="4" max="32" value="16"></div>
      <div class="control-row"><label for="fovInput">Radar FOV</label><input id="fovInput" type="number" min="30" max="240" value="160"></div>
      <div class="control-row"><label>PD kp</label><input id="kpInput" type="number" step="0.1" value="28"></div>
      <div class="control-row"><label>PD kd</label><input id="kdInput" type="number" step="0.1" value="6"></div>
      <div class="control-row"><label>Torque limit</label><input id="torqueInput" type="number" step="0.1" value="60"></div>
      <div class="control-row"><label>Episode length (s)</label><input id="episodeInput" type="number" min="5" value="22"></div>
      <p id="play-hint">Play mode: shoulders/hips with <kbd>WASD</kbd>, knees/elbows with <kbd>Arrow keys</kbd>, lean with <kbd>Q/E</kbd>, crouch/extend with <kbd>Z/X</kbd>. Hold <kbd>Space</kbd> for quick reset.</p>
    </details>
    <details class="panel" open>
      <summary>NEAT training</summary>
      <div class="control-row"><label>Population size</label><input id="popInput" type="number" min="4" value="24"></div>
      <div class="control-row"><label>Mutation rate</label><input id="mutInput" type="number" step="0.01" value="0.18"></div>
      <div class="control-row"><label>Crossover rate</label><input id="crossInput" type="number" step="0.01" value="0.6"></div>
      <div class="control-row"><label>Elitism</label><input id="eliteInput" type="number" min="0" value="2"></div>
      <div class="control-row"><label>Hidden nodes</label><input id="hiddenInput" type="number" min="0" value="6"></div>
      <div class="control-row"><label>Activation</label><input id="activationInput" type="text" value="tanh"></div>
      <div class="control-row"><label>Species distance</label><input id="distanceInput" type="number" step="0.1" value="3.4"></div>
      <div class="control-row"><label>Stagnation limit</label><input id="stagnationInput" type="number" min="5" value="12"></div>
      <div class="control-row"><label>Curriculum</label><input id="curriculumInput" type="number" min="0" value="0"></div>
    </details>
    <details class="panel" open>
      <summary>Sensors</summary>
      <div id="awareness">
        <canvas id="radar-canvas" width="260" height="160"></canvas>
        <canvas id="heatmap-canvas" width="260" height="90"></canvas>
        <div id="awareness-text" style="font-size:12px; color:var(--muted);"></div>
      </div>
    </details>
    <details class="panel" open>
      <summary>Telemetry</summary>
      <div id="fitness-breakdown"></div>
      <canvas id="fitness-chart" class="chart" width="260" height="90"></canvas>
      <canvas id="speed-chart" class="chart" width="260" height="90"></canvas>
      <canvas id="arm-chart" class="chart" width="260" height="90"></canvas>
    </details>
  </aside>
</main>
<script>
// ===== Utilities =====
const TAU = Math.PI * 2;
function rand(seed) {
  const x = Math.sin(seed) * 10000;
  return x - Math.floor(x);
}
class RNG {
  constructor(seed = 1337) { this.seed = seed; }
  next() { this.seed = (this.seed * 1664525 + 1013904223) % 4294967296; return this.seed / 4294967296; }
  pick(list) { return list[Math.floor(this.next() * list.length)]; }
}
function clamp(v, min, max) { return v < min ? min : v > max ? max : v; }
function lerp(a, b, t) { return a + (b - a) * t; }
function softsign(x) { return x / (1 + Math.abs(x)); }
function activation(name, x) {
  switch (name) {
    case 'relu': return x > 0 ? x : 0;
    case 'sigmoid': return 1 / (1 + Math.exp(-x));
    case 'tanh': default: return Math.tanh(x);
  }
}
function drawRoundedRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.closePath();
}

// ===== Physics =====
const JOINTS = [
  { name: 'hipL', parent: 'torso', child: 'thighL', min: -1.6, max: 1.2 },
  { name: 'hipR', parent: 'torso', child: 'thighR', min: -1.6, max: 1.2 },
  { name: 'kneeL', parent: 'thighL', child: 'shinL', min: -0.1, max: 2.4 },
  { name: 'kneeR', parent: 'thighR', child: 'shinR', min: -0.1, max: 2.4 },
  { name: 'shoulderL', parent: 'torso', child: 'upperArmL', min: -1.6, max: 1.6 },
  { name: 'shoulderR', parent: 'torso', child: 'upperArmR', min: -1.6, max: 1.6 },
  { name: 'elbowL', parent: 'upperArmL', child: 'foreArmL', min: -0.1, max: 2.2 },
  { name: 'elbowR', parent: 'upperArmR', child: 'foreArmR', min: -0.1, max: 2.2 },
  { name: 'neck', parent: 'torso', child: 'head', min: -0.6, max: 0.6 }
];
const BODY_PARTS = {
  torso: { length: 30, mass: 18 },
  head: { length: 14, mass: 4 },
  thighL: { length: 28, mass: 8 },
  shinL: { length: 26, mass: 7 },
  thighR: { length: 28, mass: 8 },
  shinR: { length: 26, mass: 7 },
  upperArmL: { length: 22, mass: 5 },
  foreArmL: { length: 20, mass: 4 },
  upperArmR: { length: 22, mass: 5 },
  foreArmR: { length: 20, mass: 4 }
};
const DEFAULT_PD = { kp: 28, kd: 6 };

class Joint {
  constructor(data) {
    this.name = data.name;
    this.parent = data.parent;
    this.child = data.child;
    this.min = data.min;
    this.max = data.max;
    this.angle = clamp(0, this.min, this.max);
    this.angleVel = 0;
    this.target = 0;
  }
  update(dt, kp, kd, torqueLimit) {
    const error = clamp(this.target, this.min, this.max) - this.angle;
    const torque = clamp(kp * error - kd * this.angleVel, -torqueLimit, torqueLimit);
    this.angleVel += torque * dt * 0.4;
    this.angle += this.angleVel * dt;
    if (this.angle < this.min) { this.angle = this.min; this.angleVel *= -0.3; }
    if (this.angle > this.max) { this.angle = this.max; this.angleVel *= -0.3; }
  }
}

class Humanoid {
  constructor(settings, rng = new RNG()) {
    this.settings = settings;
    this.rng = rng;
    this.reset();
  }
  reset() {
    this.torsoPos = { x: 120, y: 240 };
    this.torsoVel = { x: 0, y: 0 };
    this.torsoAngle = 0.05;
    this.torsoAngVel = 0;
    this.time = 0;
    this.alive = true;
    this.contact = { left: false, right: false };
    this.joints = new Map();
    JOINTS.forEach(cfg => {
      const joint = new Joint(cfg);
      joint.angle = clamp((this.rng.next() - 0.5) * 0.2, joint.min, joint.max);
      joint.target = joint.angle;
      this.joints.set(cfg.name, joint);
    });
  }
  /** Returns joint by name. */
  joint(name) { return this.joints.get(name); }
  /** Computes world coordinates for all segments. */
  computeSkeleton() {
    const points = {};
    const torso = BODY_PARTS.torso;
    const base = { x: this.torsoPos.x, y: this.torsoPos.y };
    const torsoEnd = {
      x: base.x + Math.sin(this.torsoAngle) * torso.length,
      y: base.y - Math.cos(this.torsoAngle) * torso.length
    };
    points.torsoStart = base;
    points.torsoEnd = torsoEnd;
    const attach = (parentEnd, parentAngle, jointName, lengthName) => {
      const joint = this.joint(jointName);
      if (!joint) return { start: parentEnd, end: parentEnd };
      const angle = parentAngle + joint.angle;
      const part = BODY_PARTS[lengthName];
      const end = {
        x: parentEnd.x + Math.sin(angle) * part.length,
        y: parentEnd.y - Math.cos(angle) * part.length
      };
      return { start: parentEnd, end, angle };
    };
    const hipL = attach(base, this.torsoAngle + 0.12, 'hipL', 'thighL');
    const hipR = attach(base, this.torsoAngle - 0.12, 'hipR', 'thighR');
    const kneeL = attach(hipL.end, hipL.angle, 'kneeL', 'shinL');
    const kneeR = attach(hipR.end, hipR.angle, 'kneeR', 'shinR');
    const shoulderL = attach(torsoEnd, this.torsoAngle + 0.05, 'shoulderL', 'upperArmL');
    const shoulderR = attach(torsoEnd, this.torsoAngle - 0.05, 'shoulderR', 'upperArmR');
    const elbowL = attach(shoulderL.end, shoulderL.angle, 'elbowL', 'foreArmL');
    const elbowR = attach(shoulderR.end, shoulderR.angle, 'elbowR', 'foreArmR');
    const neck = attach(torsoEnd, this.torsoAngle, 'neck', 'head');
    points.hipL = hipL; points.hipR = hipR;
    points.kneeL = kneeL; points.kneeR = kneeR;
    points.shoulderL = shoulderL; points.shoulderR = shoulderR;
    points.elbowL = elbowL; points.elbowR = elbowR;
    points.neck = neck;
    return points;
  }
  /** Step physics forward */
  step(dt, env) {
    if (!this.alive) return;
    this.time += dt;
    const g = this.settings.gravity;
    this.torsoVel.y += g * dt;
    this.torsoPos.x += this.torsoVel.x * dt * this.settings.timeScale;
    this.torsoPos.y += this.torsoVel.y * dt * this.settings.timeScale;
    this.torsoAngle += this.torsoAngVel * dt * this.settings.timeScale;
    this.torsoAngVel *= 0.99;
    const skeleton = this.computeSkeleton();
    const feet = [
      { name: 'left', part: skeleton.kneeL.end },
      { name: 'right', part: skeleton.kneeR.end }
    ];
    this.contact.left = false;
    this.contact.right = false;
    feet.forEach((foot, idx) => {
      if (foot.part.y >= env.ground) {
        const penetration = foot.part.y - env.ground;
        this.torsoPos.y -= penetration * 0.5;
        this.torsoVel.y = -this.torsoVel.y * 0.2;
        const friction = clamp(env.friction * (idx === 0 ? -1 : 1), -env.maxSpeed, env.maxSpeed);
        this.torsoVel.x += friction * dt;
        if (idx === 0) this.contact.left = true; else this.contact.right = true;
      }
    });
    if (this.torsoPos.y > env.ground + 40) this.alive = false;
    this.joints.forEach(j => j.update(dt * this.settings.timeScale, this.settings.kp, this.settings.kd, this.settings.torqueLimit));
  }
}

// ===== Sensors =====
class SensorSuite {
  constructor(rayCount, fov) {
    this.rayCount = rayCount;
    this.fov = fov * Math.PI / 180;
    this.values = new Float32Array(rayCount + 16);
  }
  resize(rayCount, fovDeg) {
    this.rayCount = rayCount;
    this.fov = fovDeg * Math.PI / 180;
    this.values = new Float32Array(rayCount + 16);
  }
  sample(humanoid, env) {
    const skeleton = humanoid.computeSkeleton();
    const torsoPos = humanoid.torsoPos;
    const rays = [];
    const startAngle = humanoid.torsoAngle - this.fov / 2;
    for (let i = 0; i < this.rayCount; i++) {
      const angle = startAngle + (this.fov * i) / (this.rayCount - 1);
      const end = {
        x: torsoPos.x + Math.cos(angle) * env.rayLength,
        y: torsoPos.y + Math.sin(angle) * env.rayLength
      };
      let dist = env.rayLength;
      if (angle > Math.PI / 2) {
        const t = (env.ground - torsoPos.y) / Math.sin(angle);
        if (t > 0 && t < dist) dist = t;
      }
      const button = env.button;
      const toButton = { x: button.x - torsoPos.x, y: button.y - torsoPos.y };
      const proj = Math.cos(angle) * toButton.x + Math.sin(angle) * toButton.y;
      if (proj > 0) {
        const orth = Math.abs(-Math.sin(angle) * toButton.x + Math.cos(angle) * toButton.y);
        if (orth < button.radius + 6 && proj < dist) dist = proj;
      }
      rays.push({ angle, dist });
      this.values[i] = 1 - dist / env.rayLength;
    }
    let idx = this.rayCount;
    const joints = JOINTS.map(j => humanoid.joint(j.name));
    joints.forEach(j => {
      this.values[idx++] = (j.angle - j.min) / (j.max - j.min);
      this.values[idx++] = softsign(j.angleVel * 0.2);
    });
    this.values[idx++] = softsign(humanoid.torsoVel.x * 0.05);
    this.values[idx++] = softsign(humanoid.torsoVel.y * 0.05);
    this.values[idx++] = (humanoid.torsoAngle + Math.PI / 2) / Math.PI;
    this.values[idx++] = humanoid.contact.left ? 1 : 0;
    this.values[idx++] = humanoid.contact.right ? 1 : 0;
    const hands = [humanoid.computeSkeleton().elbowL.end, humanoid.computeSkeleton().elbowR.end];
    hands.forEach(hand => {
      const dx = env.button.x - hand.x;
      const dy = env.button.y - hand.y;
      const d = Math.hypot(dx, dy);
      this.values[idx++] = 1 - clamp(d / env.button.range, 0, 1);
    });
    return rays;
  }
}

// ===== NEAT =====
let innovationCounter = 0;
class ConnectionGene {
  constructor(from, to, weight, enabled = true, innovation = innovationCounter++) {
    this.from = from;
    this.to = to;
    this.weight = weight;
    this.enabled = enabled;
    this.innovation = innovation;
  }
  copy() { const c = new ConnectionGene(this.from, this.to, this.weight, this.enabled, this.innovation); return c; }
}
class NodeGene {
  constructor(id, type) {
    this.id = id;
    this.type = type; // input, hidden, output
    this.bias = 0;
  }
  copy() { const n = new NodeGene(this.id, this.type); n.bias = this.bias; return n; }
}
class Genome {
  constructor() {
    this.nodes = new Map();
    this.connections = [];
    this.fitness = 0;
    this.adjustedFitness = 0;
  }
  copy() {
    const g = new Genome();
    this.nodes.forEach(node => g.nodes.set(node.id, node.copy()));
    this.connections.forEach(c => g.connections.push(c.copy()));
    g.fitness = this.fitness;
    g.adjustedFitness = this.adjustedFitness;
    return g;
  }
  mutateWeights(rate = 0.8, power = 0.2, rng) {
    this.connections.forEach(conn => {
      if (rng.next() < rate) {
        if (rng.next() < 0.1) conn.weight = (rng.next() * 2 - 1) * 2.5;
        else conn.weight += (rng.next() * 2 - 1) * power;
      }
    });
    this.nodes.forEach(node => {
      if (rng.next() < rate * 0.5) node.bias += (rng.next() * 2 - 1) * power;
    });
  }
  mutateAddConnection(rng) {
    const nodes = Array.from(this.nodes.values());
    for (let i = 0; i < 10; i++) {
      const a = nodes[Math.floor(rng.next() * nodes.length)];
      const b = nodes[Math.floor(rng.next() * nodes.length)];
      if (a.type === 'output' && b.type !== 'output') continue;
      if (a.id === b.id) continue;
      if (this.connections.some(c => c.from === a.id && c.to === b.id)) continue;
      this.connections.push(new ConnectionGene(a.id, b.id, (rng.next() * 2 - 1) * 1.5));
      return;
    }
  }
  mutateAddNode(rng) {
    const enabledConnections = this.connections.filter(c => c.enabled);
    if (!enabledConnections.length) return;
    const conn = rng.pick(enabledConnections);
    conn.enabled = false;
    const newId = `h${this.nodes.size}`;
    const node = new NodeGene(newId, 'hidden');
    node.bias = 0;
    this.nodes.set(newId, node);
    this.connections.push(new ConnectionGene(conn.from, newId, 1));
    this.connections.push(new ConnectionGene(newId, conn.to, conn.weight));
  }
  buildNetwork(activationName) {
    const order = Array.from(this.nodes.values()).sort((a, b) => a.type.localeCompare(b.type));
    const nodeValues = new Map();
    const enabledConnections = () => this.connections.filter(c => c.enabled);
    const connections = enabledConnections();
    return {
      activate(inputs) {
        order.forEach(node => {
          if (node.type === 'input') nodeValues.set(node.id, inputs[node.id] ?? 0);
          else nodeValues.set(node.id, node.bias);
        });
        connections.forEach(conn => {
          const fromVal = nodeValues.get(conn.from) ?? 0;
          const toVal = nodeValues.get(conn.to) ?? 0;
          nodeValues.set(conn.to, toVal + fromVal * conn.weight);
        });
        const outputs = {};
        order.forEach(node => {
          if (node.type !== 'input') {
            const val = activation(activationName, nodeValues.get(node.id));
            nodeValues.set(node.id, val);
          }
          if (node.type === 'output') outputs[node.id] = nodeValues.get(node.id);
        });
        return outputs;
      },
      nodes: this.nodes,
      connections: connections
    };
  }
}

class Species {
  constructor(representative) {
    this.representative = representative.copy();
    this.members = [];
    this.bestFitness = 0;
    this.stagnation = 0;
  }
  compatibility(genome, c1 = 1, c2 = 1, c3 = 0.4) {
    const innov = new Map();
    this.representative.connections.forEach(c => innov.set(c.innovation, c));
    let excess = 0, disjoint = 0, weightDiff = 0, matches = 0;
    genome.connections.forEach(c => {
      const mate = innov.get(c.innovation);
      if (mate) { weightDiff += Math.abs(mate.weight - c.weight); matches++; }
      else disjoint++;
    });
    const n = Math.max(genome.connections.length, this.representative.connections.length);
    const N = n < 20 ? 1 : n;
    const avgDiff = matches ? weightDiff / matches : 0;
    return c1 * excess / N + c2 * disjoint / N + c3 * avgDiff;
  }
  add(genome) { this.members.push(genome); }
  reset(representative) {
    this.representative = representative.copy();
    this.members = [];
  }
}

class Population {
  constructor(config, rng = new RNG()) {
    this.config = config;
    this.rng = rng;
    this.species = [];
    this.generation = 0;
    this.bestGenome = null;
    this.history = [];
    this.initPopulation();
  }
  initPopulation() {
    this.genomes = [];
    innovationCounter = 0;
    for (let i = 0; i < this.config.populationSize; i++) {
      const genome = new Genome();
      for (let n = 0; n < this.config.inputCount; n++) {
        genome.nodes.set(`in${n}`, new NodeGene(`in${n}`, 'input'));
      }
      for (let o = 0; o < this.config.outputCount; o++) {
        genome.nodes.set(`out${o}`, new NodeGene(`out${o}`, 'output'));
      }
      for (let h = 0; h < this.config.initialHidden; h++) {
        const node = new NodeGene(`h${h}`, 'hidden');
        node.bias = (this.rng.next() * 2 - 1) * 0.2;
        genome.nodes.set(node.id, node);
      }
      const inputNodes = Array.from({ length: this.config.inputCount }, (_, idx) => `in${idx}`);
      const outputNodes = Array.from({ length: this.config.outputCount }, (_, idx) => `out${idx}`);
      inputNodes.forEach(i => {
        outputNodes.forEach(o => {
          if (this.rng.next() < 0.2) genome.connections.push(new ConnectionGene(i, o, (this.rng.next() * 2 - 1) * 0.5));
        });
      });
      this.genomes.push(genome);
    }
  }
  speciate() {
    this.species.forEach(sp => sp.members = []);
    this.genomes.forEach(genome => {
      let found = false;
      for (const sp of this.species) {
        if (sp.compatibility(genome, 1, 1, this.config.compatibilityWeight) < this.config.speciesDistance) {
          sp.add(genome);
          found = true;
          break;
        }
      }
      if (!found) {
        const sp = new Species(genome);
        sp.add(genome);
        this.species.push(sp);
      }
    });
    this.species = this.species.filter(sp => sp.members.length);
  }
  evaluate(evalFn) {
    this.genomes.forEach(genome => genome.fitness = evalFn(genome));
    this.genomes.sort((a, b) => b.fitness - a.fitness);
    if (!this.bestGenome || this.genomes[0].fitness > this.bestGenome.fitness) {
      this.bestGenome = this.genomes[0].copy();
    }
    const avg = this.genomes.reduce((s, g) => s + g.fitness, 0) / this.genomes.length;
    this.history.push({ generation: this.generation, best: this.genomes[0].fitness, avg });
    if (this.history.length > 100) this.history.shift();
  }
  reproduce() {
    this.speciate();
    const totalFitness = this.genomes.reduce((s, g) => s + g.fitness, 0) + 1e-6;
    const children = [];
    this.genomes.sort((a, b) => b.fitness - a.fitness);
    const elite = Math.min(this.config.elitism, this.genomes.length);
    for (let i = 0; i < elite; i++) children.push(this.genomes[i].copy());
    while (children.length < this.config.populationSize) {
      const parentA = this.roulette(totalFitness);
      const parentB = this.roulette(totalFitness);
      let child = this.crossover(parentA, parentB);
      if (this.rng.next() < this.config.mutationRate) child.mutateWeights(0.9, 0.3, this.rng);
      if (this.rng.next() < this.config.mutationAddConn) child.mutateAddConnection(this.rng);
      if (this.rng.next() < this.config.mutationAddNode) child.mutateAddNode(this.rng);
      children.push(child);
    }
    this.genomes = children;
    this.generation++;
  }
  roulette(totalFitness) {
    let slice = this.rng.next() * totalFitness;
    for (const g of this.genomes) {
      slice -= Math.max(g.fitness, 0);
      if (slice <= 0) return g;
    }
    return this.genomes[this.genomes.length - 1];
  }
  crossover(a, b) {
    const child = new Genome();
    a.nodes.forEach(node => child.nodes.set(node.id, node.copy()));
    const genes = new Map();
    a.connections.forEach(c => genes.set(c.innovation, c));
    b.connections.forEach(c => {
      const gene = genes.get(c.innovation);
      if (gene && this.rng.next() < 0.5) genes.set(c.innovation, c);
      else if (!gene) genes.set(c.innovation, c);
    });
    genes.forEach(gene => child.connections.push(gene.copy()));
    return child;
  }
}

// ===== Controller / Simulation =====
const settings = {
  gravity: 18,
  timeScale: 1,
  kp: DEFAULT_PD.kp,
  kd: DEFAULT_PD.kd,
  torqueLimit: 60,
  episodeLength: 22,
  rayCount: 16,
  fov: 160
};
const simCanvas = document.getElementById('sim-canvas');
const ctx = simCanvas.getContext('2d');
const radarCtx = document.getElementById('radar-canvas').getContext('2d');
const heatCtx = document.getElementById('heatmap-canvas').getContext('2d');
const fitnessChartCtx = document.getElementById('fitness-chart').getContext('2d');
const speedChartCtx = document.getElementById('speed-chart').getContext('2d');
const armChartCtx = document.getElementById('arm-chart').getContext('2d');
const hud = {
  gen: document.getElementById('hud-generation'),
  best: document.getElementById('hud-best'),
  avg: document.getElementById('hud-avg'),
  alive: document.getElementById('hud-alive'),
  success: document.getElementById('hud-success')
};
const awarenessText = document.getElementById('awareness-text');
const breakdownEl = document.getElementById('fitness-breakdown');
let population = null;
let humanoids = [];
let currentMode = 'play';
let bestScore = 0;
let curriculumLevel = 0;
const env = {
  ground: 420,
  friction: 26,
  maxSpeed: 180,
  rayLength: 220,
  button: { x: 520, y: 220, radius: 14, pressed: false, range: 140 },
  object: { x: 520, y: 260 }
};
const sensorSuite = new SensorSuite(settings.rayCount, settings.fov);
const keyState = new Set();
let episodeTimer = 0;
let stepCount = 0;
let fitnessBreakdown = { walk: 0, upright: 0, arm: 0, smooth: 0, survival: 0 };
let telemetryHistory = { fitness: [], speed: [], arm: [] };
const rng = new RNG(12345);

function initPopulation() {
  population = new Population({
    populationSize: Number(document.getElementById('popInput').value) || 24,
    mutationRate: Number(document.getElementById('mutInput').value) || 0.18,
    mutationAddConn: 0.12,
    mutationAddNode: 0.05,
    crossoverRate: Number(document.getElementById('crossInput').value) || 0.6,
    elitism: Number(document.getElementById('eliteInput').value) || 2,
    inputCount: sensorSuite.values.length,
    outputCount: JOINTS.length + 1,
    initialHidden: Number(document.getElementById('hiddenInput').value) || 6,
    compatibilityWeight: 0.4,
    speciesDistance: Number(document.getElementById('distanceInput').value) || 3.4
  }, rng);
  resetEpisode();
}

function resetEpisode() {
  humanoids = [];
  episodeTimer = 0;
  stepCount = 0;
  env.button.pressed = false;
  const popSize = currentMode === 'train' ? population.genomes.length : 1;
  for (let i = 0; i < popSize; i++) {
    const agent = new Humanoid(settings, new RNG(rng.next() * 999999));
    agent.torsoPos.x += i * 10;
    humanoids.push(agent);
  }
}

function updateSettingsFromUI() {
  settings.gravity = Number(document.getElementById('gravityInput').value) || 18;
  settings.timeScale = Number(document.getElementById('timeScaleInput').value) || 1;
  settings.rayCount = clamp(Number(document.getElementById('rayCountInput').value) || 16, 4, 32);
  settings.fov = Number(document.getElementById('fovInput').value) || 160;
  settings.kp = Number(document.getElementById('kpInput').value) || DEFAULT_PD.kp;
  settings.kd = Number(document.getElementById('kdInput').value) || DEFAULT_PD.kd;
  settings.torqueLimit = Number(document.getElementById('torqueInput').value) || 60;
  settings.episodeLength = Number(document.getElementById('episodeInput').value) || 22;
  sensorSuite.resize(settings.rayCount, settings.fov);
  if (population) initPopulation();
}

function evaluateGenome(genome) {
  const network = genome.buildNetwork(document.getElementById('activationInput').value || 'tanh');
  const agent = new Humanoid(settings, new RNG(rng.next() * 999999));
  let reward = 0;
  let smoothPenalty = 0;
  let success = 0;
  let steps = 0;
  env.button.pressed = false;
  const weights = { walk: 1.4, upright: 0.7, arm: 1.2, smooth: 0.4, survival: 0.2 };
  while (steps < settings.episodeLength * 60 && agent.alive) {
    const rays = sensorSuite.sample(agent, env);
    const inputs = {};
    sensorSuite.values.forEach((v, idx) => inputs[`in${idx}`] = v);
    const outputs = network.activate(inputs);
    let torqueCost = 0;
    JOINTS.forEach((joint, idx) => {
      const o = outputs[`out${idx}`] ?? 0;
      const target = lerp(joint.min, joint.max, (o + 1) / 2);
      const j = agent.joint(joint.name);
      torqueCost += Math.abs(target - j.target);
      j.target = target;
    });
    const leanTarget = outputs[`out${JOINTS.length}`] ?? 0;
    agent.torsoAngVel += clamp(leanTarget, -1, 1) * 0.12;
    agent.step(1 / 60, env);
    const skeleton = agent.computeSkeleton();
    const walkScore = agent.torsoPos.x * 0.01;
    const upright = 1 - Math.abs(agent.torsoAngle) / (Math.PI / 2);
    const leftHand = skeleton.elbowL.end;
    const rightHand = skeleton.elbowR.end;
    const buttonDist = Math.min(Math.hypot(env.button.x - leftHand.x, env.button.y - leftHand.y), Math.hypot(env.button.x - rightHand.x, env.button.y - rightHand.y));
    if (buttonDist < env.button.radius + 8) { env.button.pressed = true; success += 1; }
    const armScore = 1 - clamp(buttonDist / env.button.range, 0, 1);
    smoothPenalty += torqueCost;
    reward += walkScore * weights.walk + upright * weights.upright + armScore * weights.arm + weights.survival;
    steps++;
    if (!agent.alive) reward -= 20;
  }
  const smoothness = Math.exp(-smoothPenalty / (steps + 1));
  reward += smoothness * 20 * 0.4;
  genome.fitness = reward;
  genome.meta = { successRate: success / (steps + 1), smoothness, survivalSteps: steps };
  return reward;
}

function runGeneration() {
  population.evaluate(evaluateGenome);
  hud.gen.textContent = population.generation;
  hud.best.textContent = population.genomes[0].fitness.toFixed(1);
  const avg = population.genomes.reduce((s, g) => s + g.fitness, 0) / population.genomes.length;
  hud.avg.textContent = avg.toFixed(1);
  hud.alive.textContent = population.genomes.length;
  const bestMeta = population.genomes[0].meta || { successRate: 0 };
  hud.success.textContent = `${(bestMeta.successRate * 100).toFixed(0)}%`;
  bestScore = Math.max(bestScore, population.genomes[0].fitness);
  const weights = { walk: 1.4, upright: 0.7, arm: 1.2, smooth: 0.4, survival: 0.2 };
  fitnessBreakdown = {
    walk: weights.walk,
    upright: weights.upright,
    arm: weights.arm,
    smooth: weights.smooth,
    survival: weights.survival
  };
  updateBreakdown();
  telemetryHistory.fitness.push({ best: population.genomes[0].fitness, avg });
  if (telemetryHistory.fitness.length > 120) telemetryHistory.fitness.shift();
  telemetryHistory.speed.push({ value: population.genomes[0].meta?.survivalSteps || 0 });
  if (telemetryHistory.speed.length > 120) telemetryHistory.speed.shift();
  telemetryHistory.arm.push({ value: population.genomes[0].meta?.successRate || 0 });
  if (telemetryHistory.arm.length > 120) telemetryHistory.arm.shift();
  drawCharts();
  population.reproduce();
  resetEpisode();
}

function updateBreakdown() {
  breakdownEl.innerHTML = '';
  Object.entries(fitnessBreakdown).forEach(([name, value]) => {
    const wrapper = document.createElement('div');
    wrapper.style.fontSize = '12px';
    wrapper.style.color = 'var(--muted)';
    wrapper.textContent = `${name.toUpperCase()} (${value})`;
    const bar = document.createElement('div');
    bar.className = 'fitness-bar';
    const fill = document.createElement('span');
    fill.style.width = `${clamp(value / 2, 0, 1) * 100}%`;
    bar.appendChild(fill);
    breakdownEl.appendChild(wrapper);
    breakdownEl.appendChild(bar);
  });
}

function drawCharts() {
  drawChart(fitnessChartCtx, telemetryHistory.fitness, ['best', 'avg'], ['#7c5cff', '#2dd4bf']);
  drawChart(speedChartCtx, telemetryHistory.speed, ['value'], ['#f8aa4b']);
  drawChart(armChartCtx, telemetryHistory.arm, ['value'], ['#2dd4bf']);
}

function drawChart(ctxChart, data, keys, colors) {
  ctxChart.clearRect(0, 0, ctxChart.canvas.width, ctxChart.canvas.height);
  if (!data.length) return;
  const max = Math.max(...data.map(d => Math.max(...keys.map(k => d[k])))) || 1;
  data.forEach((d, idx) => {
    keys.forEach((key, ki) => {
      const v = d[key];
      const x = (idx / (data.length - 1 || 1)) * ctxChart.canvas.width;
      const y = ctxChart.canvas.height - (v / max) * ctxChart.canvas.height;
      ctxChart.fillStyle = colors[ki];
      ctxChart.fillRect(x, y, 2, ctxChart.canvas.height - y);
    });
  });
}

function simulateStep() {
  ctx.clearRect(0, 0, simCanvas.width, simCanvas.height);
  ctx.save();
  ctx.fillStyle = '#071226';
  ctx.fillRect(0, env.ground, simCanvas.width, simCanvas.height - env.ground);
  ctx.fillStyle = 'rgba(124,92,255,0.25)';
  ctx.fillRect(0, env.ground, simCanvas.width, 20);
  ctx.fillStyle = env.button.pressed ? '#2dd4bf' : '#f5f8ff';
  ctx.beginPath();
  ctx.arc(env.button.x, env.button.y, env.button.radius, 0, TAU);
  ctx.fill();
  const dt = 1 / 60;
  humanoids.forEach((agent, idx) => {
    const rays = sensorSuite.sample(agent, env);
    if (currentMode === 'train') {
      const genome = population.genomes[idx];
      if (!genome.network) genome.network = genome.buildNetwork(document.getElementById('activationInput').value || 'tanh');
      const inputs = {};
      sensorSuite.values.forEach((v, i) => inputs[`in${i}`] = v);
      const outputs = genome.network.activate(inputs);
      JOINTS.forEach((joint, jdx) => {
        const out = outputs[`out${jdx}`] ?? 0;
        const target = lerp(joint.min, joint.max, (out + 1) / 2);
        agent.joint(joint.name).target = target;
      });
      const lean = outputs[`out${JOINTS.length}`] ?? 0;
      agent.torsoAngVel += clamp(lean, -1, 1) * 0.12;
    } else {
      applyManualControls(agent);
    }
    agent.step(dt, env);
    drawHumanoid(agent, rays);
  });
  ctx.restore();
  drawAwareness();
  stepCount++;
  episodeTimer += dt;
  if (currentMode === 'train' && episodeTimer > settings.episodeLength) {
    runGeneration();
  }
  requestAnimationFrame(simulateStep);
}

function drawHumanoid(agent, rays) {
  const skeleton = agent.computeSkeleton();
  ctx.strokeStyle = 'rgba(44,64,104,0.5)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  rays.forEach(ray => {
    const x = agent.torsoPos.x + Math.cos(ray.angle) * ray.dist;
    const y = agent.torsoPos.y + Math.sin(ray.angle) * ray.dist;
    ctx.moveTo(agent.torsoPos.x, agent.torsoPos.y);
    ctx.lineTo(x, y);
  });
  ctx.stroke();
  const bones = [
    [skeleton.torsoStart, skeleton.torsoEnd],
    [skeleton.hipL.start, skeleton.hipL.end],
    [skeleton.kneeL.start, skeleton.kneeL.end],
    [skeleton.hipR.start, skeleton.hipR.end],
    [skeleton.kneeR.start, skeleton.kneeR.end],
    [skeleton.shoulderL.start, skeleton.shoulderL.end],
    [skeleton.elbowL.start, skeleton.elbowL.end],
    [skeleton.shoulderR.start, skeleton.shoulderR.end],
    [skeleton.elbowR.start, skeleton.elbowR.end],
    [skeleton.neck.start, skeleton.neck.end]
  ];
  ctx.lineWidth = 6;
  ctx.lineCap = 'round';
  bones.forEach((bone, idx) => {
    ctx.strokeStyle = idx < 4 ? '#7c5cff' : idx < 6 ? '#2dd4bf' : '#f8aa4b';
    ctx.beginPath();
    ctx.moveTo(bone[0].x, bone[0].y);
    ctx.lineTo(bone[1].x, bone[1].y);
    ctx.stroke();
  });
  ctx.fillStyle = '#f5f8ff';
  ctx.beginPath();
  ctx.arc(skeleton.neck.end.x, skeleton.neck.end.y, 10, 0, TAU);
  ctx.fill();
}

function drawAwareness() {
  radarCtx.clearRect(0, 0, radarCtx.canvas.width, radarCtx.canvas.height);
  const rays = sensorSuite.rayCount;
  radarCtx.save();
  radarCtx.translate(radarCtx.canvas.width / 2, radarCtx.canvas.height - 10);
  radarCtx.fillStyle = 'rgba(124,92,255,0.2)';
  radarCtx.beginPath();
  radarCtx.moveTo(0, 0);
  for (let i = 0; i < rays; i++) {
    const val = sensorSuite.values[i];
    const angle = (-settings.fov / 2 + (settings.fov * i) / (rays - 1)) * Math.PI / 180;
    const radius = val * 120;
    radarCtx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
  }
  radarCtx.closePath();
  radarCtx.fill();
  radarCtx.restore();
  heatCtx.clearRect(0, 0, heatCtx.canvas.width, heatCtx.canvas.height);
  const values = sensorSuite.values;
  const cellWidth = heatCtx.canvas.width / values.length;
  values.forEach((v, idx) => {
    const h = clamp(v, 0, 1) * heatCtx.canvas.height;
    heatCtx.fillStyle = `hsl(${lerp(220, 140, clamp(v, 0, 1))}, 70%, 60%)`;
    heatCtx.fillRect(idx * cellWidth, heatCtx.canvas.height - h, cellWidth - 1, h);
  });
  const agent = humanoids[0];
  if (!agent) return;
  const skeleton = agent.computeSkeleton();
  const button = env.button;
  const dx = button.x - agent.torsoPos.x;
  const direction = dx > 0 ? 'right' : 'left';
  const distance = Math.abs(dx / 100).toFixed(2);
  const leaning = agent.torsoAngle > 0.2 ? 'leaning forward' : agent.torsoAngle < -0.2 ? 'leaning back' : 'upright';
  const hand = Math.min(Math.hypot(button.x - skeleton.elbowL.end.x, button.y - skeleton.elbowL.end.y), Math.hypot(button.x - skeleton.elbowR.end.x, button.y - skeleton.elbowR.end.y));
  const handState = hand < button.radius + 12 ? 'extend hand now' : 'reach out';
  awarenessText.textContent = `Target ${distance}m ${direction}; ${leaning}; ${handState}; step ${(agent.contact.right ? 'right' : agent.contact.left ? 'left' : 'lightly')}.`;
}

function applyManualControls(agent) {
  const hipSpeed = 0.02;
  const kneeSpeed = 0.02;
  const shoulderSpeed = 0.02;
  const elbowSpeed = 0.02;
  if (keyState.has('KeyW')) agent.joint('shoulderL').target += shoulderSpeed;
  if (keyState.has('KeyS')) agent.joint('shoulderL').target -= shoulderSpeed;
  if (keyState.has('KeyA')) agent.joint('hipL').target += hipSpeed;
  if (keyState.has('KeyD')) agent.joint('hipL').target -= hipSpeed;
  if (keyState.has('ArrowUp')) agent.joint('shoulderR').target += shoulderSpeed;
  if (keyState.has('ArrowDown')) agent.joint('shoulderR').target -= shoulderSpeed;
  if (keyState.has('ArrowLeft')) agent.joint('hipR').target += hipSpeed;
  if (keyState.has('ArrowRight')) agent.joint('hipR').target -= hipSpeed;
  if (keyState.has('KeyQ')) agent.torsoAngVel -= 0.04;
  if (keyState.has('KeyE')) agent.torsoAngVel += 0.04;
  if (keyState.has('KeyZ')) { agent.joint('kneeL').target += kneeSpeed; agent.joint('kneeR').target += kneeSpeed; }
  if (keyState.has('KeyX')) { agent.joint('kneeL').target -= kneeSpeed; agent.joint('kneeR').target -= kneeSpeed; }
  if (keyState.has('ShiftLeft')) { agent.joint('elbowL').target += elbowSpeed; agent.joint('elbowR').target += elbowSpeed; }
  if (keyState.has('Space')) agent.reset();
  JOINTS.forEach(joint => {
    const j = agent.joint(joint.name);
    j.target = clamp(j.target, joint.min, joint.max);
  });
}

function toggleMode() {
  currentMode = currentMode === 'play' ? 'train' : 'play';
  document.getElementById('mode-indicator').textContent = `Mode: ${currentMode === 'play' ? 'Play' : 'Train'}`;
  document.getElementById('btnPlayMode').textContent = currentMode === 'play' ? 'Switch to Train' : 'Switch to Play';
  if (currentMode === 'train' && !population) {
    initPopulation();
  }
  resetEpisode();
}

function attachEvents() {
  document.getElementById('btnPlayMode').addEventListener('click', toggleMode);
  document.getElementById('btnStart').addEventListener('click', () => {
    updateSettingsFromUI();
    if (currentMode === 'train') initPopulation();
    resetEpisode();
  });
  document.getElementById('btnReset').addEventListener('click', () => {
    initPopulation();
  });
  document.getElementById('btnSave').addEventListener('click', () => {
    if (population && population.bestGenome) localStorage.setItem('vollylab_best', JSON.stringify(serializeGenome(population.bestGenome)));
  });
  document.getElementById('btnLoad').addEventListener('click', () => {
    const raw = localStorage.getItem('vollylab_best');
    if (!raw) return;
    const data = JSON.parse(raw);
    population.bestGenome = deserializeGenome(data);
    population.genomes[0] = population.bestGenome.copy();
  });
  ['gravityInput','timeScaleInput','rayCountInput','fovInput','kpInput','kdInput','torqueInput','episodeInput'].forEach(id => {
    document.getElementById(id).addEventListener('change', updateSettingsFromUI);
  });
  document.getElementById('curriculumInput').addEventListener('change', e => {
    curriculumLevel = Number(e.target.value) || 0;
  });
  window.addEventListener('keydown', e => { keyState.add(e.code); });
  window.addEventListener('keyup', e => { keyState.delete(e.code); });
}

function serializeGenome(genome) {
  return {
    nodes: Array.from(genome.nodes.values()).map(n => ({ id: n.id, type: n.type, bias: n.bias })),
    connections: genome.connections.map(c => ({ from: c.from, to: c.to, weight: c.weight, enabled: c.enabled, innovation: c.innovation })),
    fitness: genome.fitness
  };
}
function deserializeGenome(data) {
  const genome = new Genome();
  data.nodes.forEach(n => { const node = new NodeGene(n.id, n.type); node.bias = n.bias; genome.nodes.set(node.id, node); });
  data.connections.forEach(c => genome.connections.push(new ConnectionGene(c.from, c.to, c.weight, c.enabled, c.innovation)));
  genome.fitness = data.fitness || 0;
  return genome;
}

function start() {
  attachEvents();
  updateSettingsFromUI();
  resetEpisode();
  requestAnimationFrame(simulateStep);
}

start();
</script>
</body>
</html>
