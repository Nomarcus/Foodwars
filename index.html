<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>FoodSim â€“ Two Teams with NEAT-lite</title>
  <style>
    :root {
      --bg1:#050516;
      --bg2:#161b3f;
      --panel:rgba(18,24,56,.82);
      --ink:#f1f5ff;
      --muted:#a1a9d8;
      --accent:#f472b6;
      --accent-emerald:#2dd4bf;
      --accent-cyan:#38bdf8;
      --silver:rgba(222,231,255,.55);
    }
    *{box-sizing:border-box}
    body{margin:0; min-height:100vh; display:flex; flex-direction:column; background:radial-gradient(circle at 45% 12%, rgba(87,51,183,.55) 0%, rgba(39,56,121,.85) 45%, var(--bg1) 100%); color:var(--ink); font-family:"Inter",system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;}

    .main-nav{position:sticky; top:0; z-index:200; padding:22px 48px; display:flex; align-items:center; justify-content:space-between; background:linear-gradient(120deg, rgba(15,20,48,.92) 0%, rgba(10,14,34,.75) 60%, rgba(10,14,34,.35) 100%); backdrop-filter:blur(14px); border-bottom:1px solid var(--silver); box-shadow:0 22px 45px rgba(5,9,25,.55)}
    .brand{display:flex; align-items:center; gap:12px; font-size:22px; font-weight:700; letter-spacing:.02em; color:var(--ink)}
    .brand-dot{width:14px; height:14px; border-radius:50%; background:linear-gradient(135deg, var(--accent) 0%, #8b5cf6 100%); box-shadow:0 0 18px rgba(244,114,182,.6)}
    .nav-links{display:flex; align-items:center; gap:12px}
    .pill-link{display:inline-flex; align-items:center; justify-content:center; padding:10px 20px; border-radius:999px; border:1px solid rgba(45,212,191,.45); background:linear-gradient(120deg, rgba(45,212,191,.18), rgba(59,130,246,.18)); color:var(--ink); text-decoration:none; font-size:14px; font-weight:600; letter-spacing:.03em; transition:transform .2s ease, box-shadow .2s ease, filter .2s ease, border-color .2s ease}
    .pill-link.secondary{border-color:rgba(139,92,246,.45); background:linear-gradient(120deg, rgba(139,92,246,.18), rgba(244,114,182,.18))}
    .pill-link:hover{transform:translateY(-1px); filter:brightness(1.05); box-shadow:0 16px 32px rgba(45,212,191,.25)}
    .pill-link:focus-visible{outline:2px solid rgba(56,189,248,.65); outline-offset:3px}

    main{flex:1; display:flex; justify-content:center; align-items:flex-start; padding:40px 48px 64px}
    .wrap{display:flex; align-items:flex-start; justify-content:center; gap:40px; width:100%; max-width:2000px}
    .field-area{flex:1 1 auto; display:flex; flex-direction:column; align-items:stretch; gap:18px; min-width:0}
    canvas{border-radius:24px; background:#04091f; box-shadow:0 0 45px rgba(15,23,61,.65), inset 0 0 22px rgba(118,133,255,.12); cursor:crosshair; border:1px solid var(--silver);}
    .stats-bar{display:grid; grid-template-columns:repeat(auto-fit,minmax(150px,1fr)); gap:16px; padding:18px 22px; border-radius:18px; background:rgba(11,16,44,.78); border:1px solid var(--silver); box-shadow:0 18px 32px rgba(5,9,25,.45)}
    .stat-card{display:flex; flex-direction:column; gap:6px; padding:6px 0}
    .stat-label{font-size:12px; text-transform:uppercase; letter-spacing:.12em; color:var(--muted)}
    .stat-value{font-size:26px; font-weight:700; letter-spacing:.02em; color:var(--ink)}

    .side{width:420px; flex:0 1 420px; display:flex; flex-direction:column; gap:20px}
    .panel{background:var(--panel); border:1px solid var(--silver); padding:22px; border-radius:20px; backdrop-filter:blur(16px); box-shadow:0 18px 45px rgba(5,7,24,.55); position:relative}
    .panel-head{display:flex; align-items:center; justify-content:space-between; gap:12px; cursor:pointer; user-select:none; padding-bottom:10px; margin-bottom:14px; border-bottom:1px dashed rgba(189,206,255,.28)}
    .panel-head .h{margin:0; font-size:17px; letter-spacing:.03em}
    .chev{font-weight:900; font-size:16px; opacity:.75; transition:transform .25s ease}
    .panel-body{max-height:1200px; overflow:hidden; transition:max-height .35s ease, opacity .25s ease; opacity:1}
    .panel.collapsed .panel-body{max-height:0; opacity:.0}
    .panel.collapsed .chev{transform:rotate(-90deg)}

    .grid{display:grid; grid-template-columns: 1fr 1.3fr auto; gap:12px 12px; align-items:center}
    .label{font-size:13px; color:var(--muted); letter-spacing:.02em}
    .val{font-family:ui-monospace,Menlo,Consolas,monospace; font-size:12px; padding:4px 8px; border-radius:8px; background:rgba(10,16,46,.7); border:1px solid var(--silver); color:var(--accent-cyan); box-shadow:inset 0 0 12px rgba(56,189,248,.12)}
    input[type=range]{width:100%; accent-color:var(--accent-cyan)}
    .btn{display:block; width:100%; padding:12px 14px; border-radius:12px; border:1px solid rgba(45,212,191,.45); background:linear-gradient(120deg, rgba(45,212,191,.18), rgba(59,130,246,.18)); color:var(--ink); cursor:pointer; text-align:center; margin-top:14px; font-weight:600; letter-spacing:.02em; transition:transform .2s ease, box-shadow .2s ease, filter .2s ease}
    .btn:hover{filter:brightness(1.08); transform:translateY(-1px); box-shadow:0 20px 36px rgba(45,212,191,.28)}
    .tool-hint{margin:0 0 14px; font-size:12px; line-height:1.6; color:var(--muted)}
    .tool-buttons{display:grid; grid-template-columns:repeat(auto-fit,minmax(120px,1fr)); gap:10px}
    .tool-btn{padding:10px 12px; border-radius:12px; border:1px solid rgba(59,130,246,.28); background:rgba(18,27,66,.6); color:var(--ink); font-size:13px; font-weight:600; letter-spacing:.02em; cursor:pointer; transition:transform .2s ease, box-shadow .2s ease, filter .2s ease, border-color .2s ease}
    .tool-btn:hover{filter:brightness(1.05); transform:translateY(-1px); box-shadow:0 12px 26px rgba(59,130,246,.22)}
    .tool-btn.active{border-color:rgba(45,212,191,.65); background:linear-gradient(120deg, rgba(45,212,191,.24), rgba(59,130,246,.24)); box-shadow:0 14px 28px rgba(45,212,191,.24)}
    .sub{font-weight:800; font-size:14px; opacity:.9; margin:10px 0 8px; letter-spacing:.05em; color:var(--ink)}
    .team-roster{display:grid; grid-template-columns:repeat(auto-fit,minmax(160px,1fr)); gap:12px}
    .team-card{position:relative; display:flex; flex-direction:column; gap:6px; padding:14px 16px; border-radius:14px; border:1px solid var(--silver); background:rgba(12,18,44,.72); box-shadow:0 10px 24px rgba(5,9,28,.4); transition:transform .2s ease, box-shadow .2s ease, border-color .2s ease}
    .team-card:hover{transform:translateY(-2px); box-shadow:0 16px 32px rgba(5,9,28,.5)}
    .team-card.active{border-color:rgba(45,212,191,.6); box-shadow:0 18px 36px rgba(45,212,191,.22)}
    .team-card input[type=checkbox]{position:absolute; inset:0; opacity:0; cursor:pointer; border-radius:14px}
    .team-card .team-header{display:flex; align-items:center; gap:10px}
    .team-card .team-name{font-weight:600; letter-spacing:.02em}
    .team-card .team-meta{font-size:12px; color:var(--muted)}
    .team-badge{display:inline-flex; align-items:center; justify-content:center; width:28px; height:28px; border-radius:50%; font-size:16px; box-shadow:0 0 18px rgba(255,255,255,.2); color:#020617}
    .music-lead{font-size:13px; line-height:1.6; opacity:.85; margin:0 0 14px}
    .music-select{display:flex; flex-direction:column; gap:6px}
    .music-dropdown{width:100%; padding:10px 12px; border-radius:12px; border:1px solid var(--silver); background:rgba(12,18,44,.82); color:var(--ink); font-size:13px; font-family:inherit; letter-spacing:.01em; box-shadow:inset 0 0 12px rgba(118,133,255,.15)}
    .music-controls{display:flex; align-items:center; gap:12px; margin-top:12px; flex-wrap:wrap}
    .music-controls .btn{flex:0 0 auto; width:auto; padding:10px 18px; margin-top:0}
    .music-volume{display:flex; flex:1; align-items:center; gap:10px; min-width:200px}
    .music-volume .label{min-width:60px}
    .music-volume input[type=range]{flex:1}
    .music-meta{margin-top:14px; font-size:12px; line-height:1.6; background:rgba(11,16,44,.65); border:1px solid var(--silver); padding:12px 14px; border-radius:14px; box-shadow:inset 0 0 14px rgba(138,92,246,.12)}
    .music-status{display:flex; align-items:center; gap:8px; font-size:12px; text-transform:uppercase; letter-spacing:.08em; opacity:.82; color:var(--accent-cyan)}
    .music-attr{opacity:.72}
    .sr-only{position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0}

    @media (max-width:1200px){
      .wrap{flex-direction:column; align-items:center}
      .field-area{width:100%}
      .side{width:100%; max-width:720px}
    }
    @media (max-width:900px){
      main{padding:32px 28px 56px}
    }
    @media (max-width:768px){
      .main-nav{flex-direction:column; align-items:flex-start; gap:16px; padding:18px 24px}
      .nav-links{flex-wrap:wrap}
      main{padding:28px 20px 56px}
      .wrap{gap:28px}
      canvas{width:100%; height:auto}
      .stats-bar{grid-template-columns:repeat(auto-fit,minmax(130px,1fr)); gap:12px; padding:16px 18px}
      .stat-value{font-size:22px}
      .side{max-width:100%}
    }
  </style>
</head>
<body>
  <header class="main-nav">
    <div class="brand"><span class="brand-dot"></span>FoodSim NEAT Lab</div>
    <nav class="nav-links" aria-label="Primary navigation">
      <a class="pill-link" href="#world">Playfield</a>
      <a class="pill-link" href="#panel-global">Controls</a>
      <a class="pill-link secondary" href="learn-neat.html">How NEAT works</a>
    </nav>
  </header>
  <main>
  <div class="wrap">
    <!-- Left panel: Learning (NEAT) -->
    <aside class="side" id="left-panel">
      <div class="panel" id="panel-learn">
        <div class="panel-head"><div class="h">Learning (NEAT-lite)</div><span class="chev">â–¾</span></div>
        <div class="panel-body">
          <div class="grid">
            <div class="label">Steps / gen</div>
            <input id="slGenSteps" type="range" min="600" max="100000000" value="2800"><div class="val" id="lbGenSteps">2800</div>

            <div class="label">Mutation %</div>
            <input id="slMut" type="range" min="1" max="80" value="16"><div class="val" id="lbMut">16</div>

            <div class="label">Elite ratio</div>
            <input id="slElite" type="range" min="5" max="50" value="20"><div class="val" id="lbElite">0.20</div>
          </div>
          <div class="grid" style="margin-top:8px">
            <div class="label">Auto next gen</div>
            <input id="chkAuto" type="checkbox" checked><div class="val" id="lbAuto">on</div>
          </div>
          <div class="sub" style="margin-top:10px">Status</div>
          <div class="grid" id="learnStatusGrid">
            <div class="label">Generation</div><div></div><div class="val" id="lbGen">1</div>
          </div>
          <button id="btnNextGen" class="btn">Advance generation now</button>
          <button id="btnSaveTraining" class="btn">Save training (.json)</button>
          <button id="btnLoadTraining" class="btn">Load trainingâ€¦</button>
          <input type="file" id="inputLoadTraining" accept="application/json" style="display:none">
        </div>
      </div>
    </aside>

    <!-- Middle: playfield -->
    <div class="field-area">
      <canvas id="world" width="1100" height="640"></canvas>
      <section class="stats-bar" aria-label="Simulation progress" aria-live="polite">
        <div class="stat-card">
          <span class="stat-label">Generation</span>
          <span class="stat-value" id="stat-gen">1</span>
        </div>
        <div class="stat-card">
          <span class="stat-label">Teams active</span>
          <span class="stat-value" id="stat-teams">2</span>
        </div>
        <div class="stat-card">
          <span class="stat-label">Fruits on field</span>
          <span class="stat-value" id="stat-fruits">0</span>
        </div>
        <div class="stat-card">
          <span class="stat-label">Deliveries</span>
          <span class="stat-value" id="stat-deliveries">0</span>
        </div>
        <div class="stat-card">
          <span class="stat-label">Top fitness</span>
          <span class="stat-value" id="stat-top">0</span>
        </div>
      </section>
    </div>

    <!-- Right panels: controls and teams -->
    <aside class="side" id="right-panel">
      <div class="panel" id="panel-global">
        <div class="panel-head"><div class="h">Global controls</div><span class="chev">â–¾</span></div>
        <div class="panel-body">
          <div class="grid">
            <div class="label">Fruit (max)</div>
            <input id="slFruits" type="range" min="2" max="1000" value="32"><div class="val" id="lbFruits">32</div>

            <div class="label">Spawn (ms)</div>
            <input id="slSpawn" type="range" min="120" max="15000" value="900"><div class="val" id="lbSpawn">900</div>

            <div class="label">Obstacles</div>
            <input id="slObst" type="range" min="0" max="40" value="8"><div class="val" id="lbObst">8</div>

            <div class="label">Trail length</div>
            <input id="slTail" type="range" min="4" max="1500" value="24"><div class="val" id="lbTail">24</div>
          </div>
          <button id="btnReset" class="btn">Restart</button>
        </div>
      </div>

      <div class="panel" id="panel-toolbox">
        <div class="panel-head"><div class="h">Obstacle toolbox</div><span class="chev">â–¾</span></div>
        <div class="panel-body">
          <p class="tool-hint">Choose a tool to draw glowing obstacles directly on the field.</p>
          <div class="tool-buttons" role="group" aria-label="Obstacle drawing tools">
            <button class="tool-btn active" data-tool="select" aria-pressed="true">Move</button>
            <button class="tool-btn" data-tool="circle" aria-pressed="false">Circle</button>
            <button class="tool-btn" data-tool="rect" aria-pressed="false">Rectangle</button>
            <button class="tool-btn" data-tool="line" aria-pressed="false">Line</button>
            <button class="tool-btn" data-tool="half" aria-pressed="false">Half circle</button>
          </div>
          <button id="btnClearManual" class="btn">Clear manual obstacles</button>
        </div>
      </div>

      <div class="panel" id="panel-teams">
        <div class="panel-head"><div class="h">Team settings</div><span class="chev">â–¾</span></div>
        <div class="panel-body">
          <div class="sub">Teams</div>
          <div class="team-roster" id="teamRoster"></div>
          <div class="sub" style="margin-top:14px">Shared attributes</div>
          <div class="grid">
            <div class="label">Count</div>
            <input id="slTeamCount" type="range" min="2" max="200" value="28"><div class="val" id="lbTeamCount">28</div>
            <div class="label">Speed</div>
            <input id="slTeamSpeed" type="range" min="10" max="600" value="260"><div class="val" id="lbTeamSpeed">2.60</div>
            <div class="label">Awareness</div>
            <input id="slTeamSmart" type="range" min="0" max="300" value="180"><div class="val" id="lbTeamSmart">1.80</div>
            <div class="label">Strategy</div>
            <input id="slTeamStrat" type="range" min="0" max="300" value="140"><div class="val" id="lbTeamStrat">1.40</div>
            <div class="label">Separation</div>
            <input id="slTeamSep" type="range" min="0" max="300" value="110"><div class="val" id="lbTeamSep">1.10</div>
          </div>
        </div>
      </div>

      <div class="panel" id="panel-music">
        <div class="panel-head"><div class="h">Ambient Sound Lounge</div><span class="chev">â–¾</span></div>
        <div class="panel-body">
          <p class="music-lead">Slip into focus with a hand-picked selection of calm, looping ambient tracks.</p>
          <div class="music-select">
            <label class="label" for="selMusic">Curated playlist</label>
            <select id="selMusic" class="music-dropdown"></select>
          </div>
          <div class="music-controls">
            <button id="btnMusicToggle" class="btn">Play</button>
            <div class="music-volume">
              <span class="label">Volume</span>
              <input id="slMusicVolume" type="range" min="0" max="100" value="55">
              <span class="val" id="lbMusicVolume">55%</span>
            </div>
          </div>
          <div class="music-meta">
            <div class="music-status"><span id="lbMusicState">Paused</span></div>
            <div id="lbMusicNow" class="music-attr">Choose a track to begin.</div>
            <div id="lbMusicSource" class="music-attr">Royalty-free ambient selections streamed from Pixabay artists.</div>
          </div>
        </div>
      </div>
    </aside>
  </div>
  </main>


<script>
// ===== Utils for UI =====
const Q = (id)=>document.getElementById(id);
function bindRange(sl, lb, fmt=(v)=>v){ const s=Q(sl), l=Q(lb); const apply=()=>{ l.textContent = fmt(+s.value); readParams(); }; s.addEventListener('input', apply); apply(); }

function setRangeValue(id, value){
  const el = Q(id);
  if(!el) return;
  const min = el.min !== undefined ? Number(el.min) : Number(value);
  const max = el.max !== undefined ? Number(el.max) : Number(value);
  const clamped = Math.min(max, Math.max(min, Number(value)));
  if(String(el.value) !== String(clamped)){
    el.value = clamped;
  }
  el.dispatchEvent(new Event('input', { bubbles:true }));
}

// === Make panels collapsible ===
(function makePanelsCollapsible(){
  const panels = document.querySelectorAll('.panel');
  panels.forEach((p)=>{
    const head = p.querySelector('.panel-head');
    if(!head) return;
    head.addEventListener('click', (e)=>{
      // Ignore clicks on inputs inside header (none for now)
      p.classList.toggle('collapsed');
    });
  });
})();

// ===== Colors =====
const COLORS = {
  fruit: '#ffd43b',
  goal:  '#3b82f6',
  goalFill: 'rgba(59,130,246,0.18)',
  fruitOutline:'#000'
};

const TEAM_PRESETS = [
  { id:'green', label:'Greens', icon:'ðŸŸ¢', color:'#00ff91', outline:'#003322', badge:'#bbf7d0', goalAnchor:{ x:0.86, y:0.35 }, spawn:{ x:[0.06,0.46], y:[0.12,0.92] } },
  { id:'red', label:'Reds', icon:'ðŸ”´', color:'#ff0055', outline:'#5a001a', badge:'#fecdd3', goalAnchor:{ x:0.14, y:0.65 }, spawn:{ x:[0.54,0.94], y:[0.08,0.9] } },
  { id:'blue', label:'Blues', icon:'ðŸ”µ', color:'#60a5fa', outline:'#1e3a8a', badge:'#bfdbfe', goalAnchor:{ x:0.22, y:0.24 }, spawn:{ x:[0.18,0.52], y:[0.06,0.42] } },
  { id:'amber', label:'Ambers', icon:'ðŸŸ ', color:'#f97316', outline:'#7c2d12', badge:'#fed7aa', goalAnchor:{ x:0.80, y:0.76 }, spawn:{ x:[0.52,0.90], y:[0.58,0.94] } }
];
const TEAM_PRESET_MAP = new Map(TEAM_PRESETS.map((preset)=> [preset.id, preset]));

const OBSTACLE_COLORS = ['#38bdf8', '#f472b6', '#2dd4bf'];

function hexToRgba(hex, alpha){
  const h = hex.replace('#','');
  const bigint = parseInt(h,16);
  const r=(bigint>>16)&255;
  const g=(bigint>>8)&255;
  const b=bigint&255;
  return `rgba(${r},${g},${b},${alpha})`;
}

const canvas = document.getElementById('world');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

const TOOL_SELECT='select';
const TOOL_CIRCLE='circle';
const TOOL_RECT='rect';
const TOOL_LINE='line';
const TOOL_HALF='half';

let currentTool = TOOL_SELECT;
let drawingState = null;
let manualPaletteCursor = 0;
let dragRadius = 0;

// ===== Parameters =====
const params = {
  maxFruits: 32,
  spawnMs: 900,
  obstacles: 8,
  tailLen: 24,
  teams: TEAM_PRESETS.map((preset, index)=>({
    id:preset.id,
    label:preset.label,
    icon:preset.icon,
    color:preset.color,
    outline:preset.outline,
    badge:preset.badge,
    goalAnchor:Object.assign({}, preset.goalAnchor),
    spawn:preset.spawn ? { x:preset.spawn.x.slice(), y:preset.spawn.y.slice() } : { x:[0.1,0.9], y:[0.1,0.9] },
    active:index < 2,
    count:28,
    speed:2.60,
    smart:1.80,
    strat:1.40,
    sep:1.10
  })),
  learn: { genSteps:2800, mut:0.16, elite:0.20, auto:true }
};
let lastObstCount = params.obstacles;

const MUSIC_TRACKS = [
  {
    title: 'Forest Haze',
    artist: 'FoodSim Ensemble',
    source: 'Procedurally generated drone in C â€“ loops seamlessly offline.',
    duration: 24,
    render: renderForestHaze
  },
  {
    title: 'Cloudlight',
    artist: 'FoodSim Ensemble',
    source: 'Procedurally generated airy chords in F major â€“ works without internet.',
    duration: 20,
    render: renderCloudlight
  },
  {
    title: 'Luminous Air',
    artist: 'FoodSim Ensemble',
    source: 'Procedurally generated evolving pad built into this demo.',
    duration: 26,
    render: renderLuminousAir
  }
];
let currentTrackIndex = 0;
let currentTrackToken = 0;
let currentTrackBuffer = null;
let isMusicPlaying = false;

let currentObjectUrl = null;
let currentObjectUrlToken = 0;

function setCurrentObjectUrl(url){
  clearCurrentObjectUrl();
  currentObjectUrl = url;
  currentObjectUrlToken++;
  return { url, token: currentObjectUrlToken };
}

function clearCurrentObjectUrl(expectedToken=null){
  if(expectedToken != null && expectedToken !== currentObjectUrlToken) return;
  if(currentObjectUrl){
    try{ URL.revokeObjectURL(currentObjectUrl); }catch(_err){ /* ignore */ }
    currentObjectUrl = null;
  }
}

let audioCtx = null;
let masterGain = null;
let currentSource = null;
const trackBufferCache = new Map();
let pendingTrackPromise = null;
let pendingVolume = 0.55;
let musicToggleBtn = null;

function ensureAudioContext(){
  if(audioCtx) return audioCtx;
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  if(!AudioCtx){
    throw new Error('Web Audio API not supported');
  }
  audioCtx = new AudioCtx();
  masterGain = audioCtx.createGain();
  masterGain.gain.value = pendingVolume;
  masterGain.connect(audioCtx.destination);
  return audioCtx;
}

async function resumeAudioContext(){
  const ctx = ensureAudioContext();
  if(ctx.state === 'suspended'){
    await ctx.resume();
  }
  return ctx;
}

function readParams(){
  params.maxFruits = +Q('slFruits').value; Q('lbFruits').textContent=params.maxFruits;
  params.spawnMs = +Q('slSpawn').value; Q('lbSpawn').textContent=params.spawnMs;
  params.obstacles = +Q('slObst').value; Q('lbObst').textContent=params.obstacles; if(params.obstacles !== lastObstCount){ makeObstacles(params.obstacles); lastObstCount = params.obstacles; }
  params.tailLen = +Q('slTail').value; Q('lbTail').textContent=params.tailLen;

  const sharedCount = +Q('slTeamCount').value; Q('lbTeamCount').textContent=sharedCount;
  const sharedSpeed = (+Q('slTeamSpeed').value)/100; Q('lbTeamSpeed').textContent=sharedSpeed.toFixed(2);
  const sharedSmart = (+Q('slTeamSmart').value)/100; Q('lbTeamSmart').textContent=sharedSmart.toFixed(2);
  const sharedStrat = (+Q('slTeamStrat').value)/100; Q('lbTeamStrat').textContent=sharedStrat.toFixed(2);
  const sharedSep   = (+Q('slTeamSep').value)/100; Q('lbTeamSep').textContent=sharedSep.toFixed(2);
  params.teams.forEach((team)=>{
    team.count = sharedCount;
    team.speed = sharedSpeed;
    team.smart = sharedSmart;
    team.strat = sharedStrat;
    team.sep = sharedSep;
  });

  params.learn.genSteps = +Q('slGenSteps').value; Q('lbGenSteps').textContent=params.learn.genSteps;
  params.learn.mut = (+Q('slMut').value)/100; Q('lbMut').textContent=Math.round(params.learn.mut*100);
  params.learn.elite = (+Q('slElite').value)/100; Q('lbElite').textContent=params.learn.elite.toFixed(2);
  params.learn.auto = Q('chkAuto').checked; Q('lbAuto').textContent = params.learn.auto? 'on':'off';
  if(params.learn.auto && awaitingManualAdvance){
    forceNextGen = true;
  }
}
function updateMusicMeta(track, stateOverride=null){
  if(!track) return;
  const state = stateOverride || (isMusicPlaying ? 'Playing' : 'Paused');
  Q('lbMusicState').textContent = state;
  Q('lbMusicNow').textContent = `${track.title} â€” ${track.artist}`;
  Q('lbMusicSource').textContent = track.source;
}

let awaitingAudioUnlock = false;

function updateMusicButton(){
  if(!musicToggleBtn) return;
  musicToggleBtn.textContent = isMusicPlaying ? 'Pause' : 'Play';
  musicToggleBtn.setAttribute('aria-pressed', isMusicPlaying ? 'true' : 'false');
}

function stopCurrentTrack(silent=false){
  if(currentSource){
    try{ currentSource.stop(); }catch(err){ /* ignore stop errors */ }
    currentSource.disconnect();
    currentSource = null;
  }
  isMusicPlaying = false;
  if(!silent){
    updateMusicMeta(MUSIC_TRACKS[currentTrackIndex], 'Paused');
    updateMusicButton();
  }
}

function createAudioBuffer(channels, length, sampleRate){
  if(typeof AudioBuffer === 'function'){
    return new AudioBuffer({ numberOfChannels: channels, length, sampleRate });
  }
  const OfflineCtx = window.OfflineAudioContext || window.webkitOfflineAudioContext;
  if(OfflineCtx){
    const offline = new OfflineCtx(channels, length, sampleRate);
    return offline.createBuffer(channels, length, sampleRate);
  }
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  if(AudioCtx){
    const tempCtx = new AudioCtx();
    const buffer = tempCtx.createBuffer(channels, length, sampleRate);
    if(typeof tempCtx.close === 'function') tempCtx.close();
    return buffer;
  }
  throw new Error('Web Audio API not supported');
}

async function ensureTrackBuffer(track, sampleRate){
  let buffersForRate = trackBufferCache.get(sampleRate);
  if(!buffersForRate){
    buffersForRate = new Map();
    trackBufferCache.set(sampleRate, buffersForRate);
  }
  if(buffersForRate.has(track)) return buffersForRate.get(track);
  const buffer = generateProceduralBuffer(track, sampleRate);
  buffersForRate.set(track, buffer);
  return buffer;
}

function generateProceduralBuffer(track, sampleRate){
  const duration = Math.max(4, track.duration || 20);
  const length = Math.max(1, Math.floor(duration * sampleRate));
  const buffer = createAudioBuffer(2, length, sampleRate);
  const left = buffer.getChannelData(0);
  const right = buffer.getChannelData(1);
  track.render(left, right, sampleRate, duration);
  return buffer;
}

function requestAudioUnlock(){
  if(awaitingAudioUnlock) return;
  awaitingAudioUnlock = true;
  const resume = async ()=>{
    document.removeEventListener('pointerdown', resume);
    document.removeEventListener('keydown', resume);
    awaitingAudioUnlock = false;
    try{
      await playCurrentTrack();
    }catch(err){
      handlePlaybackFailure(err, MUSIC_TRACKS[currentTrackIndex]);
    }
  };
  document.addEventListener('pointerdown', resume, { once:true });
  document.addEventListener('keydown', resume, { once:true });
}

function handlePlaybackFailure(err, track){
  if(!err) return;
  const activeTrack = track || MUSIC_TRACKS[currentTrackIndex];
  isMusicPlaying = false;
  if(err.name === 'NotAllowedError' || err.name === 'SecurityError'){
    updateMusicMeta(activeTrack, 'Tap to enable audio');
    updateMusicButton();
    requestAudioUnlock();
    console.warn('Music playback is blocked until the page receives a user interaction.', err);
  } else if(err.message === 'Web Audio API not supported' || err.name === 'NotSupportedError'){
    updateMusicMeta(activeTrack, 'Audio unavailable');
    Q('lbMusicNow').textContent = 'This browser cannot synthesize the selected track.';
    updateMusicButton();
    console.error('Music playback failed', err);
  } else {
    updateMusicMeta(activeTrack, 'Playback failed');
    updateMusicButton();
    console.error('Music playback failed', err);
  }
}

async function playCurrentTrack(){
  const track = MUSIC_TRACKS[currentTrackIndex];
  try{
    const ctx = await resumeAudioContext();
    const buffer = await ensureTrackBuffer(track, ctx.sampleRate);
    currentTrackBuffer = buffer;
    stopCurrentTrack(true);
    const source = ctx.createBufferSource();
    source.buffer = buffer;
    source.loop = true;
    source.connect(masterGain);
    source.start();
    currentSource = source;
    isMusicPlaying = true;
    source.addEventListener('ended', ()=>{
      if(currentSource === source){
        isMusicPlaying = false;
        updateMusicMeta(track, 'Paused');
        updateMusicButton();
      }
    });
    updateMusicMeta(track, 'Playing');
    updateMusicButton();
  }catch(err){
    handlePlaybackFailure(err, track);
    throw err;
  }
}

async function setMusicTrack(index, autoplay=false){
  if(index<0 || index>=MUSIC_TRACKS.length) return;
  const track = MUSIC_TRACKS[index];
  const shouldAutoplay = autoplay || isMusicPlaying;
  currentTrackIndex = index;
  const token = ++currentTrackToken;

  stopCurrentTrack(true);
  updateMusicButton();
  updateMusicMeta(track, 'Preparingâ€¦');

  let sampleRate = 44100;
  try{
    const ctx = ensureAudioContext();
    sampleRate = ctx.sampleRate || sampleRate;
  }catch(err){
    handlePlaybackFailure(err, track);
    return;
  }

  const promise = ensureTrackBuffer(track, sampleRate)
    .then(async buffer => {
      if(token !== currentTrackToken) return;
      currentTrackBuffer = buffer;
      if(shouldAutoplay){
        await playCurrentTrack();
      } else {
        isMusicPlaying = false;
        updateMusicMeta(track, 'Ready');
        updateMusicButton();
      }
    })
    .catch(err => {
      handlePlaybackFailure(err, track);
    })
    .finally(()=>{
      if(token === currentTrackToken){
        pendingTrackPromise = null;
      }
    });

  pendingTrackPromise = promise;
  return promise;
}

function initMusicPanel(){
  const select = Q('selMusic');
  musicToggleBtn = Q('btnMusicToggle');
  const vol = Q('slMusicVolume');
  const volLabel = Q('lbMusicVolume');

  MUSIC_TRACKS.forEach((track, idx)=>{
    const opt = document.createElement('option');
    opt.value = idx;
    opt.textContent = `${track.title} â€” ${track.artist}`;
    select.appendChild(opt);
  });
  select.value = String(currentTrackIndex);

  const applyVolume = ()=>{
    const value = Math.round(vol.value);
    pendingVolume = value/100;
    if(masterGain){
      masterGain.gain.setValueAtTime(pendingVolume, masterGain.context.currentTime);
    }
    volLabel.textContent = `${value}%`;
  };
  applyVolume();
  vol.addEventListener('input', applyVolume);

  musicToggleBtn.addEventListener('click', async ()=>{
    if(isMusicPlaying){
      stopCurrentTrack();
    } else {
      musicToggleBtn.disabled = true;
      try{
        await playCurrentTrack();
      }catch(err){
        // handled in playCurrentTrack
      }finally{
        musicToggleBtn.disabled = false;
      }
    }
  });

  select.addEventListener('change', ()=>{
    const idx = parseInt(select.value, 10);
    setMusicTrack(idx, isMusicPlaying);
  });

  updateMusicButton();
  setMusicTrack(currentTrackIndex, false);
}

const TAU = Math.PI * 2;

function seededNoise(idx, offset=0){
  const x = Math.sin((idx + offset) * 12.9898) * 43758.5453123;
  return (x - Math.floor(x)) * 2 - 1;
}

function applyStereoFadeEnvelope(left, right, sampleRate, seconds){
  const fadeSamples = Math.min(Math.floor(seconds * sampleRate), Math.floor(left.length/2));
  if(fadeSamples <= 0) return;
  const total = left.length;
  for(let i=0; i<total; i++){
    let gain = 1;
    if(i < fadeSamples){
      gain *= i / fadeSamples;
    }
    if(total - i < fadeSamples){
      gain *= (total - i) / fadeSamples;
    }
    left[i] *= gain;
    right[i] *= gain;
  }
}

function normalizeStereo(left, right, target=0.82){
  let peak = 0;
  for(let i=0;i<left.length;i++){
    const l = Math.abs(left[i]);
    const r = Math.abs(right[i]);
    if(l>peak) peak=l;
    if(r>peak) peak=r;
  }
  if(peak > 0){
    const scale = target/peak;
    for(let i=0;i<left.length;i++){
      left[i] *= scale;
      right[i] *= scale;
    }
  }
}

function renderForestHaze(left, right, sampleRate, duration){
  const total = left.length;
  for(let i=0;i<total;i++){
    const t = i / sampleRate;
    const slow = Math.sin(t * 0.045 * TAU);
    const slow2 = Math.sin(t * 0.062 * TAU + 1.3);
    const voiceA = Math.sin(TAU * (110 + slow * 2.5) * t);
    const voiceB = Math.sin(TAU * (165 + slow2 * 2.0) * t + 0.6);
    const voiceC = Math.sin(TAU * (220 + Math.sin(t * 0.018 * TAU) * 3.5) * t + 1.1);
    const shimmer = Math.sin(TAU * (55 + Math.sin(t * 0.01 * TAU) * 4) * t) * 0.35;
    const noise = seededNoise(i, 4.2) * 0.06 * (0.4 + 0.6 * Math.sin(t * 0.08 * TAU + 2));
    const pad = (voiceA * 0.5 + voiceB * 0.42 + voiceC * 0.36 + shimmer * 0.28) * 0.48 + noise;
    const pan = Math.sin(t * 0.017 * TAU + 2.1) * 0.32;
    left[i] = pad * (1 - pan);
    right[i] = pad * (1 + pan);
  }
  applyStereoFadeEnvelope(left, right, sampleRate, 2.6);
  normalizeStereo(left, right, 0.68);
}

function renderCloudlight(left, right, sampleRate, duration){
  const total = left.length;
  const voices = [349.23, 440.0, 523.25];
  const weights = [0.46, 0.34, 0.28];
  for(let i=0;i<total;i++){
    const t = i / sampleRate;
    let l=0, r=0;
    const pulse = 0.55 + 0.45 * Math.sin(t * 0.12 * TAU);
    for(let v=0; v<voices.length; v++){
      const detune = Math.sin(t * (0.03 + v*0.018) * TAU + v) * 3.5;
      const freq = voices[v] + detune;
      const voice = Math.sin(TAU * freq * t + v * 0.8);
      const pan = (v - 1) * 0.35 + Math.sin(t * 0.05 * TAU + v) * 0.12;
      const amp = weights[v] * pulse;
      l += voice * amp * (1 - pan);
      r += voice * amp * (1 + pan);
    }
    const sparkle = seededNoise(i * 1.7, 8.2) * 0.045 * (0.35 + 0.65 * Math.sin(t * 0.42 * TAU));
    left[i] = l + sparkle;
    right[i] = r + sparkle * 0.85;
  }
  applyStereoFadeEnvelope(left, right, sampleRate, 1.6);
  normalizeStereo(left, right, 0.74);
}

function renderLuminousAir(left, right, sampleRate, duration){
  const total = left.length;
  for(let i=0;i<total;i++){
    const t = i / sampleRate;
    const drift = Math.sin(t * 0.022 * TAU);
    const voiceA = Math.sin(TAU * (196 + drift * 5) * t) * 0.55;
    const voiceB = Math.sin(TAU * (294 + Math.sin(t * 0.019 * TAU + 2) * 7) * t + 1.2) * 0.48;
    const airy = Math.sin(TAU * (147 + Math.sin(t * 0.083 * TAU) * 2.5) * t + 2.6) * 0.42;
    const mod = 0.6 + 0.4 * Math.sin(t * 0.07 * TAU + 1.7);
    const pad = (voiceA + voiceB + airy) * 0.32 * mod;
    const breath = seededNoise(i * 0.9, 1.7) * 0.055 * (0.3 + 0.7 * Math.sin(t * 0.11 * TAU));
    const shimmer = Math.sin(TAU * (880 + Math.sin(t * 0.5 * TAU) * 18) * t) * 0.028;
    const pan = Math.sin(t * 0.026 * TAU + 0.5) * 0.38;
    left[i] = pad * (1 - pan) + breath + shimmer * 0.6;
    right[i] = pad * (1 + pan) + breath * 0.92 + shimmer;
  }
  applyStereoFadeEnvelope(left, right, sampleRate, 2.8);
  normalizeStereo(left, right, 0.7);
}

// ===== Data structures =====
const fruits=[], obstacles=[];
let activeTeamStates=[];
const goalStates = {};
const bestFitnessByTeam = {};
const teamStatusLabels = new Map();

// Pheromone grid â€“ per-team fields
let grid, GW, GH, CS = 22; // cell size
function makeGrid(){
  GW=Math.floor(W/CS);
  GH=Math.floor(H/CS);
  grid={};
  params.teams.forEach((team)=>{
    grid[team.id] = {
      food:new Float32Array(GW*GH),
      home:new Float32Array(GW*GH)
    };
  });
}
const gi=(x,y)=> y*GW + x;
const clampi=(v,a,b)=> v<a?a:(v>b?b:v);
function deposit(teamId,type,x,y,amt){
  const fields = grid?.[teamId];
  if(!fields) return;
  const field = fields[type];
  if(!field) return;
  const cx=clampi((x/CS)|0,0,GW-1), cy=clampi((y/CS)|0,0,GH-1);
  field[gi(cx,cy)] += amt;
}
function senseGrad(teamId,type,x,y){
  const fields = grid?.[teamId];
  if(!fields) return { gx:0, gy:0, val:0 };
  const field = fields[type];
  if(!field) return { gx:0, gy:0, val:0 };
  const cx=clampi((x/CS)|0,0,GW-1), cy=clampi((y/CS)|0,0,GH-1);
  let best=-1e9,bx=cx,by=cy;
  for(let dy=-1;dy<=1;dy++){
    for(let dx=-1;dx<=1;dx++){
      const nx=clampi(cx+dx,0,GW-1), ny=clampi(cy+dy,0,GH-1);
      const v=field[gi(nx,ny)];
      if(v>best){best=v; bx=nx; by=ny;}
    }
  }
  return {gx:(bx-cx), gy:(by-cy), val:field[gi(bx,by)]};
}
function evaporate(){
  if(!grid) return;
  const keep=0.985;
  const next={};
  for(const [teamId, fields] of Object.entries(grid)){
    const dest={ food:new Float32Array(GW*GH), home:new Float32Array(GW*GH) };
    for(const key of ['food','home']){
      const src=fields[key];
      const dst=dest[key];
      for(let y=0;y<GH;y++){
        for(let x=0;x<GW;x++){
          let v=src[gi(x,y)]*keep;
          let sum=v*0.4;
          let cnt=0;
          for(let dy=-1;dy<=1;dy++){
            for(let dx=-1;dx<=1;dx++){
              if(dx||dy){
                const nx=clampi(x+dx,0,GW-1), ny=clampi(y+dy,0,GH-1);
                sum += src[gi(nx,ny)]*0.075;
                cnt++;
              }
            }
          }
          dst[gi(x,y)]= sum/(0.4+0.075*cnt);
        }
      }
    }
    next[teamId]=dest;
  }
  grid=next;
}

// Goals â€“ draggable, one per potential team
const GOAL_RADIUS = 34;
function ensureGoalState(teamId){
  let goal = goalStates[teamId];
  if(!goal){
    const preset = TEAM_PRESET_MAP.get(teamId);
    const anchor = preset?.goalAnchor || { x:0.5, y:0.5 };
    goal = { id:teamId, x: anchor.x * W, y: anchor.y * H, r:GOAL_RADIUS, delivered:0 };
    goalStates[teamId] = goal;
  }
  return goal;
}
function resetGoalDelivery(teamId){
  const goal = ensureGoalState(teamId);
  goal.delivered = 0;
  return goal;
}
function getAllGoalStates(){
  return params.teams.map((team)=> ensureGoalState(team.id));
}
let dragTarget=null, dragDX=0, dragDY=0, dragKind=null, dragIndex=-1;

function renderTeamRoster(){
  const roster = Q('teamRoster');
  if(!roster) return;
  roster.innerHTML='';
  params.teams.forEach((team)=>{
    const card=document.createElement('div');
    card.className='team-card';
    if(team.active) card.classList.add('active');
    card.dataset.teamId=team.id;

    const checkbox=document.createElement('input');
    checkbox.type='checkbox';
    checkbox.checked=!!team.active;
    checkbox.setAttribute('aria-label', `${team.label} team active`);

    const header=document.createElement('div');
    header.className='team-header';
    const badge=document.createElement('span');
    badge.className='team-badge';
    badge.textContent=team.icon || 'â—';
    if(team.badge){
      badge.style.background=team.badge;
      badge.style.color='#020617';
    }else{
      badge.style.background=team.color;
      badge.style.color='#fff';
    }
    const name=document.createElement('span');
    name.className='team-name';
    name.textContent=team.label;
    header.append(badge,name);

    const meta=document.createElement('div');
    meta.className='team-meta';
    meta.textContent=team.active? 'Active':'Inactive';

    checkbox.addEventListener('change', ()=>{
      team.active = checkbox.checked;
      meta.textContent = team.active ? 'Active' : 'Inactive';
      card.classList.toggle('active', team.active);
      setup();
    });

    card.append(checkbox, header, meta);
    roster.append(card);
  });
}

function rebuildTeamStatusRows(){
  const grid = Q('learnStatusGrid');
  if(!grid) return;
  grid.innerHTML='';
  teamStatusLabels.clear();
  const createRow=(labelText,valueId,value)=>{
    const label=document.createElement('div');
    label.className='label';
    label.textContent=labelText;
    const spacer=document.createElement('div');
    const valueEl=document.createElement('div');
    valueEl.className='val';
    if(valueId) valueEl.id=valueId;
    valueEl.textContent=value;
    grid.append(label, spacer, valueEl);
    return valueEl;
  };
  createRow('Generation','lbGen', evo.gen);
  activeTeamStates.forEach((team)=>{
    const label=`Best ${team.config.icon || ''} ${team.config.label}`.replace(/\s+/g,' ').trim();
    const baseline = Number.isFinite(team.peakFitness) ? team.peakFitness : (team.bestFitnessCurrent||0);
    const valueEl=createRow(label, `lbBest-${team.config.id}`, Math.round(baseline||0));
    teamStatusLabels.set(team.config.id, valueEl);
  });
}

function refreshTeamStatus(){
  rebuildTeamStatusRows();
}

function updateTeamBestLabel(teamId, best){
  const el = teamStatusLabels.get(teamId);
  if(el){
    el.textContent = Number(best||0).toFixed(0);
  }
}

function refreshStats(){
  const genEl = Q('stat-gen');
  if(genEl) genEl.textContent = evo.gen;
  const teamEl = Q('stat-teams');
  if(teamEl) teamEl.textContent = activeTeamStates.length;
  const fruitEl = Q('stat-fruits');
  if(fruitEl) fruitEl.textContent = fruits.length;
  let deliveries = 0;
  let topFitness = 0;
  for(const team of activeTeamStates){
    deliveries += team.goal?.delivered || 0;
    topFitness = Math.max(topFitness, team.peakFitness||0, team.bestFitnessCurrent||0);
  }
  const deliveryEl = Q('stat-deliveries');
  if(deliveryEl) deliveryEl.textContent = deliveries;
  const topEl = Q('stat-top');
  if(topEl) topEl.textContent = Math.round(topFitness);
}

function getCanvasCoords(evt){
  const rect = canvas.getBoundingClientRect();
  return {
    x: evt.clientX - rect.left,
    y: evt.clientY - rect.top
  };
}

function obstacleHitTest(o, px, py, tolerance=8){
  switch(o.type){
    case 'rect':{
      const halfW = o.width/2 + tolerance;
      const halfH = o.height/2 + tolerance;
      return Math.abs(px - o.x) <= halfW && Math.abs(py - o.y) <= halfH;
    }
    case 'line':{
      const t = distanceToSegment(px, py, o.x1, o.y1, o.x2, o.y2);
      const radius = (o.thickness||12)/2 + tolerance;
      return t.distance <= radius;
    }
    case 'half':{
      const dx = px - o.x;
      const dy = py - o.y;
      const radius = o.r + tolerance;
      const dist = Math.hypot(dx, dy);
      if(dist > radius) return false;
      const facingX = Math.cos(o.angle);
      const facingY = Math.sin(o.angle);
      const proj = dx*facingX + dy*facingY;
      if(proj >= -tolerance) return true;
      const perpX = -facingY;
      const perpY = facingX;
      const ax = o.x - perpX * o.r;
      const ay = o.y - perpY * o.r;
      const bx = o.x + perpX * o.r;
      const by = o.y + perpY * o.r;
      const seg = distanceToSegment(px, py, ax, ay, bx, by);
      return seg.distance <= tolerance;
    }
    default:{
      const r = typeof o.r === 'number' ? o.r : Math.max(16, (o.hitRadius||20));
      return Math.hypot(px - o.x, py - o.y) <= r + tolerance;
    }
  }
}

function getObstacleRadius(o){
  switch(o.type){
    case 'rect':
      return Math.hypot(o.width, o.height) * 0.5;
    case 'line':{
      const halfLen = Math.hypot(o.x2 - o.x1, o.y2 - o.y1) * 0.5;
      return halfLen + (o.thickness||12)/2;
    }
    case 'half':
      return o.r;
    default:
      return o.r || 24;
  }
}

function getObstacleExtents(o){
  switch(o.type){
    case 'rect':
      return { hx:o.width/2, hy:o.height/2 };
    case 'line':{
      const halfWidth = (o.thickness||12)/2;
      const halfDx = Math.abs(o.x2 - o.x1)/2;
      const halfDy = Math.abs(o.y2 - o.y1)/2;
      return { hx:halfDx + halfWidth, hy:halfDy + halfWidth };
    }
    case 'half':
      return { hx:o.r, hy:o.r };
    default:
      const r = o.r || 20;
      return { hx:r, hy:r };
  }
}

function moveObstacleTo(o, nx, ny){
  const dx = nx - o.x;
  const dy = ny - o.y;
  o.x = nx;
  o.y = ny;
  if(o.type === 'line'){
    o.x1 += dx; o.y1 += dy;
    o.x2 += dx; o.y2 += dy;
  }
}

function distanceToSegment(px, py, x1, y1, x2, y2){
  const vx = x2 - x1;
  const vy = y2 - y1;
  const lenSq = vx*vx + vy*vy;
  let t = 0;
  if(lenSq > 0){
    t = ((px - x1)*vx + (py - y1)*vy) / lenSq;
    t = Math.max(0, Math.min(1, t));
  }
  const cx = x1 + vx*t;
  const cy = y1 + vy*t;
  const dx = px - cx;
  const dy = py - cy;
  const dist = Math.hypot(dx, dy);
  const inv = dist>0 ? 1/dist : 0;
  return { distance:dist, cx, cy, nx:dx*inv, ny:dy*inv };
}

function clampObstacleCenter(o, cx, cy){
  const ext = getObstacleExtents(o);
  const hx = ext.hx || 0;
  const hy = ext.hy || 0;
  const minX = hx + 4;
  const maxX = W - hx - 4;
  const minY = hy + 4;
  const maxY = H - hy - 4;
  return {
    x: Math.max(minX, Math.min(maxX, cx)),
    y: Math.max(minY, Math.min(maxY, cy))
  };
}

function keepObstacleInside(o){
  const clamped = clampObstacleCenter(o, o.x, o.y);
  moveObstacleTo(o, clamped.x, clamped.y);
}

function buildObstacleFromState(state, preview=false){
  if(!state) return null;
  const { tool, startX, startY, currentX, currentY } = state;
  const dx = currentX - startX;
  const dy = currentY - startY;
  switch(tool){
    case TOOL_CIRCLE:{
      const radius = Math.hypot(dx, dy);
      if(!preview && radius < 12) return null;
      if(preview && radius < 2) return null;
      return { type:'circle', x:startX, y:startY, r: Math.max(radius, preview?radius:12) };
    }
    case TOOL_RECT:{
      const width = Math.abs(dx);
      const height = Math.abs(dy);
      if(!preview && (width < 16 || height < 16)) return null;
      if(preview && (width < 2 && height < 2)) return null;
      const cx = (startX + currentX) / 2;
      const cy = (startY + currentY) / 2;
      return { type:'rect', x:cx, y:cy, width: Math.max(width, preview?width:16), height: Math.max(height, preview?height:16) };
    }
    case TOOL_LINE:{
      const length = Math.hypot(dx, dy);
      if(!preview && length < 24) return null;
      if(preview && length < 4) return null;
      const cx = (startX + currentX) / 2;
      const cy = (startY + currentY) / 2;
      return {
        type:'line',
        x:cx,
        y:cy,
        x1:startX,
        y1:startY,
        x2:currentX,
        y2:currentY,
        thickness:14
      };
    }
    case TOOL_HALF:{
      const radius = Math.hypot(dx, dy);
      if(!preview && radius < 18) return null;
      if(preview && radius < 4) return null;
      const angle = Math.atan2(dy, dx);
      return { type:'half', x:startX, y:startY, r: Math.max(radius, preview?radius:18), angle };
    }
    default:
      return null;
  }
}

function createCircleObstacle(x, y, r, paletteIndex=0, manual=false){
  return { type:'circle', x, y, r, paletteIndex, phase:Math.random()*Math.PI*2, manual };
}

canvas.addEventListener('mousedown', (e)=>{
  const {x, y} = getCanvasCoords(e);
  if(currentTool !== TOOL_SELECT){
    drawingState = { tool:currentTool, startX:x, startY:y, currentX:x, currentY:y };
    return;
  }
  dragTarget=null; dragKind=null; dragIndex=-1; dragRadius=0;
  for(let i=obstacles.length-1; i>=0; i--){
    const o=obstacles[i];
    if(obstacleHitTest(o, x, y)){
      dragTarget=o; dragKind='obst'; dragIndex=i; dragDX=o.x - x; dragDY=o.y - y; dragRadius=getObstacleRadius(o); return;
    }
  }
  for(const goal of getAllGoalStates()){
    if(Math.hypot(x-goal.x,y-goal.y) <= goal.r+12){
      dragTarget=goal;
      dragKind=`goal:${goal.id}`;
      dragDX=goal.x-x;
      dragDY=goal.y-y;
      return;
    }
  }
});

window.addEventListener('mousemove', (e)=>{
  const {x, y} = getCanvasCoords(e);
  if(drawingState){
    drawingState.currentX = x;
    drawingState.currentY = y;
  }
  if(!dragTarget) return;
  if(dragKind==='obst'){
    const desiredX = x + dragDX;
    const desiredY = y + dragDY;
    const clamped = clampObstacleCenter(dragTarget, desiredX, desiredY);
    if(!obstacleOverlaps(clamped.x, clamped.y, dragRadius, dragIndex)){
      moveObstacleTo(dragTarget, clamped.x, clamped.y);
    }
  } else {
    const nx = Math.max(dragTarget.r+8, Math.min(W - dragTarget.r - 8, x + dragDX));
    const ny = Math.max(dragTarget.r+8, Math.min(H - dragTarget.r - 8, y + dragDY));
    dragTarget.x = nx;
    dragTarget.y = ny;
  }
});

window.addEventListener('mouseup', ()=>{
  if(drawingState){
    const created = buildObstacleFromState(drawingState);
    if(created){
      const paletteIndex = manualPaletteCursor % OBSTACLE_COLORS.length;
      created.manual = true;
      created.paletteIndex = paletteIndex;
      created.phase = Math.random()*Math.PI*2;
      manualPaletteCursor = (manualPaletteCursor + 1) % OBSTACLE_COLORS.length;
      keepObstacleInside(created);
      obstacles.push(created);
    }
    drawingState = null;
  }
  dragTarget=null; dragKind=null; dragIndex=-1; dragRadius=0;
});

// Utils
function rand(a,b){ return a + Math.random()*(b-a); }
function nearest(arr,x,y){ if(!arr.length) return null; let best=arr[0],bd=1e9; for(const o of arr){ const d=Math.hypot(o.x-x,o.y-y); if(d<bd){bd=d; best=o;} } return best; }
const OBSTACLE_PADDING = 12;
function obstacleOverlaps(x,y,r, ignoreIndex=-1){
  for(let i=0;i<obstacles.length;i++){
    if(i===ignoreIndex) continue;
    const o=obstacles[i];
    const otherR = getObstacleRadius(o);
    if(Math.hypot(x-o.x,y-o.y) < r + otherR + OBSTACLE_PADDING) return true;
  }
  return false;
}

function isPointInsideObstacle(o, x, y, padding=0){
  switch(o.type){
    case 'rect':{
      const halfW = o.width/2 + padding;
      const halfH = o.height/2 + padding;
      return Math.abs(x - o.x) <= halfW && Math.abs(y - o.y) <= halfH;
    }
    case 'line':{
      const seg = distanceToSegment(x, y, o.x1, o.y1, o.x2, o.y2);
      const radius = (o.thickness||14)/2 + padding;
      return seg.distance <= radius;
    }
    case 'half':{
      const dx = x - o.x;
      const dy = y - o.y;
      const radius = o.r + padding;
      const dist = Math.hypot(dx, dy);
      if(dist <= radius){
        const facingX = Math.cos(o.angle);
        const facingY = Math.sin(o.angle);
        const proj = dx*facingX + dy*facingY;
        if(proj >= -padding) return true;
      }
      const perpX = -Math.sin(o.angle);
      const perpY = Math.cos(o.angle);
      const ax = o.x - perpX * o.r;
      const ay = o.y - perpY * o.r;
      const bx = o.x + perpX * o.r;
      const by = o.y + perpY * o.r;
      const seg = distanceToSegment(x, y, ax, ay, bx, by);
      return seg.distance <= padding;
    }
    default:
      return Math.hypot(x-o.x,y-o.y) <= (o.r || getObstacleRadius(o)) + padding;
  }
}

function pointInsideObstacle(x,y){
  for(const o of obstacles){
    if(isPointInsideObstacle(o, x, y, 7)) return true;
  }
  return false;
}

function obstacleClearance(o, px, py){
  const margin = 8;
  switch(o.type){
    case 'rect':{
      const halfW = o.width/2 + margin;
      const halfH = o.height/2 + margin;
      const dx = px - o.x;
      const dy = py - o.y;
      const ax = Math.abs(dx) - halfW;
      const ay = Math.abs(dy) - halfH;
      if(ax <= 0 && ay <= 0){
        if(ax > ay){
          const nx = Math.sign(dx) || 1;
          return { distance: ax, nx, ny:0 };
        } else {
          const ny = Math.sign(dy) || 1;
          return { distance: ay, nx:0, ny };
        }
      }
      const outsideX = Math.max(ax, 0);
      const outsideY = Math.max(ay, 0);
      const dist = Math.hypot(outsideX, outsideY);
      let nx = 0, ny = 0;
      if(dist > 0){
        nx = outsideX ? (outsideX/dist) * Math.sign(dx || 1) : 0;
        ny = outsideY ? (outsideY/dist) * Math.sign(dy || 1) : 0;
      } else {
        if(ax > 0) nx = Math.sign(dx) || 1;
        if(ay > 0) ny = Math.sign(dy) || 1;
      }
      return { distance: dist, nx, ny };
    }
    case 'line':{
      const seg = distanceToSegment(px, py, o.x1, o.y1, o.x2, o.y2);
      const radius = (o.thickness||14)/2 + margin;
      let nx = seg.nx;
      let ny = seg.ny;
      if(seg.distance === 0){
        const vx = o.x2 - o.x1;
        const vy = o.y2 - o.y1;
        const len = Math.hypot(vx, vy) || 1;
        nx = -vy / len;
        ny = vx / len;
        const midX = (o.x1 + o.x2) / 2;
        const midY = (o.y1 + o.y2) / 2;
        if((px - midX)*nx + (py - midY)*ny < 0){
          nx = -nx;
          ny = -ny;
        }
      }
      return { distance: seg.distance - radius, nx, ny };
    }
    case 'half':{
      const dx = px - o.x;
      const dy = py - o.y;
      const facingX = Math.cos(o.angle);
      const facingY = Math.sin(o.angle);
      const proj = dx*facingX + dy*facingY;
      if(proj >= 0){
        const dist = Math.hypot(dx, dy);
        const radius = o.r + margin;
        const inv = dist>0 ? 1/dist : 0;
        const nx = inv>0 ? dx*inv : facingX;
        const ny = inv>0 ? dy*inv : facingY;
        return { distance: dist - radius, nx, ny };
      }
      const perpX = -Math.sin(o.angle);
      const perpY = Math.cos(o.angle);
      const ax = o.x - perpX * o.r;
      const ay = o.y - perpY * o.r;
      const bx = o.x + perpX * o.r;
      const by = o.y + perpY * o.r;
      const seg = distanceToSegment(px, py, ax, ay, bx, by);
      let nx = seg.nx;
      let ny = seg.ny;
      if(seg.distance === 0){
        nx = facingX;
        ny = facingY;
      }
      return { distance: seg.distance - margin, nx, ny };
    }
    default:{
      const dx = px - o.x;
      const dy = py - o.y;
      const dist = Math.hypot(dx, dy);
      const radius = (o.r || getObstacleRadius(o)) + margin;
      const inv = dist>0 ? 1/dist : 0;
      const nx = inv>0 ? dx*inv : 1;
      const ny = inv>0 ? dy*inv : 0;
      return { distance: dist - radius, nx, ny };
    }
  }
}
function findFreeFruitSpot(maxTry=80){ for(let i=0;i<maxTry;i++){ const x=rand(40,W-40), y=rand(40,H-40); if(goalTooClose(x,y,6,16)) continue; if(!pointInsideObstacle(x,y)) return {x,y}; } return null; }
function spawnFruit(x=null,y=null){ if(fruits.length>=params.maxFruits) return; if(x==null||y==null){ const pos=findFreeFruitSpot(); if(!pos) return; x=pos.x; y=pos.y; } if(pointInsideObstacle(x,y)){ const pos=findFreeFruitSpot(); if(!pos) return; x=pos.x; y=pos.y; } fruits.push({x,y,r:6,color:COLORS.fruit}); }
function goalTooClose(x,y,r,padding=40){
  for(const goal of getAllGoalStates()){
    if(Math.hypot(x-goal.x,y-goal.y) < goal.r + r + padding) return true;
  }
  return false;
}
function makeObstacles(n){
  const manual = obstacles.filter(o=>o.manual);
  obstacles.length = 0;
  for(const m of manual){
    obstacles.push(m);
  }
  const paletteLen=OBSTACLE_COLORS.length;
  for(let i=0;i<n;i++){
    let r=rand(16,40);
    let placed=false;
    for(let tries=0; tries<420 && !placed; tries++){
      if(tries===240) r=Math.max(12,r*0.85);
      if(tries===360) r=Math.max(10,r*0.85);
      const x=rand(80,W-80);
      const y=rand(60,H-60);
      if(goalTooClose(x,y,r,40)) continue;
      if(obstacleOverlaps(x,y,r)) continue;
      obstacles.push(createCircleObstacle(x,y,r,i%paletteLen,false));
      placed=true;
    }
    if(!placed){
      const step=36;
      outer: for(let gy=60; gy<=H-60 && !placed; gy+=step){
        for(let gx=80; gx<=W-80; gx+=step){
          if(goalTooClose(gx,gy,r,40)) continue;
          if(obstacleOverlaps(gx,gy,r)) continue;
          obstacles.push(createCircleObstacle(gx,gy,r,i%paletteLen,false));
          placed=true;
          break outer;
        }
      }
    }
    if(!placed){
      const fallback = obstacles[obstacles.length-1] || {x:W*0.5,y:H*0.5,r:20};
      let angle=Math.random()*TAU;
      let dist=getObstacleRadius(fallback) + r + OBSTACLE_PADDING + 4;
      for(let steps=0; steps<60 && !placed; steps++){
        const x=Math.max(r+4, Math.min(W-r-4, fallback.x + Math.cos(angle)*dist));
        const y=Math.max(r+4, Math.min(H-r-4, fallback.y + Math.sin(angle)*dist));
        if(obstacleOverlaps(x,y,r)){
          dist += r*0.35 + OBSTACLE_PADDING;
          angle += 0.4;
          continue;
        }
        obstacles.push(createCircleObstacle(x,y,r,i%paletteLen,false));
        placed=true;
      }
    }
    if(!placed){
      const smallR = Math.max(10, r*0.8);
      for(let tries=0; tries<240 && !placed; tries++){
        const x=rand(80,W-80);
        const y=rand(60,H-60);
        if(goalTooClose(x,y,smallR,32)) continue;
        if(obstacleOverlaps(x,y,smallR)) continue;
        obstacles.push(createCircleObstacle(x,y,smallR,i%paletteLen,false));
        placed=true;
      }
    }
  }
}



// ===== NEATâ€‘lite (7â†’16â†’2) =====
function randn(){ let u=0,v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random(); return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v); }
function matmulVec(W, x, out){ const rows=W.length, cols=W[0].length; for(let i=0;i<rows;i++){ let s=0; const Wi=W[i]; for(let j=0;j<cols;j++) s+=Wi[j]*x[j]; out[i]=s; } return out; }
function tanhVec(v){ for(let i=0;i<v.length;i++) v[i]=Math.tanh(v[i]); return v; }
function addBias(v,b){ for(let i=0;i<v.length;i++) v[i]+=b[i]; return v; }
function makeNet(inDim=7,h=16,out=2){ return { W1:Array.from({length:h},()=>Array.from({length:inDim},()=> (Math.random()*2-1)*0.5)), b1:Array.from({length:h},()=> (Math.random()*2-1)*0.2), W2:Array.from({length:out},()=>Array.from({length:h},()=> (Math.random()*2-1)*0.5)), b2:Array.from({length:out},()=> (Math.random()*2-1)*0.2) }; }
function cloneNet(n){ return { W1:n.W1.map(r=>r.slice()), b1:n.b1.slice(), W2:n.W2.map(r=>r.slice()), b2:n.b2.slice() }; }
function mutateNet(n, rate){ const sW=0.2, sB=0.2; for(const r of n.W1) for(let i=0;i<r.length;i++) if(Math.random()<rate) r[i]+=randn()*sW; for(let i=0;i<n.b1.length;i++) if(Math.random()<rate) n.b1[i]+=randn()*sB; for(const r of n.W2) for(let i=0;i<r.length;i++) if(Math.random()<rate) r[i]+=randn()*sW; for(let i=0;i<n.b2.length;i++) if(Math.random()<rate) n.b2[i]+=randn()*sB; }
function crossover(a,b){ const c=cloneNet(a); for(let i=0;i<c.W1.length;i++) for(let j=0;j<c.W1[0].length;j++) c.W1[i][j]=(Math.random()<0.5?a.W1[i][j]:b.W1[i][j]); for(let i=0;i<c.b1.length;i++) c.b1[i]=(Math.random()<0.5?a.b1[i]:b.b1[i]); for(let i=0;i<c.W2.length;i++) for(let j=0;j<c.W2[0].length;j++) c.W2[i][j]=(Math.random()<0.5?a.W2[i][j]:b.W2[i][j]); for(let i=0;i<c.b2.length;i++) c.b2[i]=(Math.random()<0.5?a.b2[i]:b.b2[i]); return c; }
function forward(n, x){ const h=new Array(n.b1.length).fill(0), o=new Array(n.b2.length).fill(0); matmulVec(n.W1,x,h); addBias(h,n.b1); tanhVec(h); matmulVec(n.W2,h,o); addBias(o,n.b2); tanhVec(o); return o; }
function makePopulation(size){ return Array.from({length:size}, ()=> ({ net:makeNet(), fitness:0 })); }
const evo = { gen:1, populations:{} };
params.teams.forEach((team)=>{
  evo.populations[team.id] = makePopulation(team.count);
});
function getPopulation(teamId){
  if(!evo.populations[teamId]){
    const team = params.teams.find((t)=>t.id===teamId);
    const size = team ? Math.max(0, team.count) : 0;
    evo.populations[teamId] = makePopulation(size);
  }
  return evo.populations[teamId];
}
function resizePop(){
  params.teams.forEach((team)=>{
    const pop = getPopulation(team.id);
    if(pop.length < team.count){
      while(pop.length < team.count) pop.push({ net:makeNet(), fitness:0 });
    } else if(pop.length > team.count){
      pop.length = team.count;
    }
  });
}
function evolveTeam(teamState){
  const pop = getPopulation(teamState.config.id);
  if(!pop.length) return;
  pop.sort((a,b)=> b.fitness - a.fitness);
  const eliteN=Math.max(1, Math.floor(pop.length*params.learn.elite));
  const elites=pop.slice(0,eliteN).map((e)=> cloneNet(e.net));
  const best=pop[0]?.fitness||0;
  teamState.bestFitnessCurrent = best;
  teamState.peakFitness = Math.max(teamState.peakFitness||0, best);
  bestFitnessByTeam[teamState.config.id] = teamState.peakFitness;
  updateTeamBestLabel(teamState.config.id, best);
  const newPop=[];
  for(let i=0;i<eliteN;i++) newPop.push({ net:cloneNet(elites[i]), fitness:0 });
  function pick(){
    const k=Math.min(pop.length, Math.max(2,eliteN*2));
    const a=pop[Math.floor(Math.random()*k)];
    const b=pop[Math.floor(Math.random()*k)];
    return (a.fitness>b.fitness?a:b).net;
  }
  while(newPop.length<pop.length){
    const pa=pick(), pb=pick();
    let child=crossover(pa,pb);
    mutateNet(child, params.learn.mut);
    newPop.push({ net:child, fitness:0 });
  }
  for(let i=0;i<pop.length;i++){
    pop[i].net=newPop[i].net;
    pop[i].fitness=0;
  }
}

// ===== Agent core =====
class Agent{
  constructor(x,y,color,maxSpeed,team){ this.x=x; this.y=y; this.vx=rand(-1,1); this.vy=rand(-1,1); this.color=color; this.maxSpeed=maxSpeed; this.trail=[]; this.carry=false; this.team=team; this.side=Math.random()<0.5?-1:1; this.stuckT=0; this.wander={x:rand(-1,1), y:rand(-1,1)}; }
  stepSpeed(v){ this.maxSpeed=v; }
  steerSeparation(peers, radius=18, gain=0.12){ let sx=0,sy=0; for(const p of peers){ if(p===this) continue; const dx=this.x-p.x, dy=this.y-p.y; const d=Math.hypot(dx,dy); if(d>0 && d<radius){ sx+=dx/(d*d); sy+=dy/(d*d); } } this.vx+=sx*gain; this.vy+=sy*gain; }
  applyWander(str=0.055, damp=0.92){ this.wander.x=this.wander.x*damp+(Math.random()*2-1)*(1-damp); this.wander.y=this.wander.y*damp+(Math.random()*2-1)*(1-damp); const wn=Math.hypot(this.wander.x,this.wander.y)||1; this.vx+=(this.wander.x/wn)*str; this.vy+=(this.wander.y/wn)*str; }
  avoidObstacles(){
    for(const o of obstacles){
      const clearance = obstacleClearance(o, this.x, this.y);
      if(!clearance) continue;
      const threshold = 12;
      if(clearance.distance < threshold){
        const push = (threshold - clearance.distance) * 0.055;
        const nx = Number.isFinite(clearance.nx) ? clearance.nx : 0;
        const ny = Number.isFinite(clearance.ny) ? clearance.ny : 0;
        this.vx += nx * push;
        this.vy += ny * push;
      }
    }
  }
  keepInBounds(){ if(this.x<10){this.x=10; this.vx=Math.abs(this.vx);} if(this.x>W-10){this.x=W-10; this.vx=-Math.abs(this.vx);} if(this.y<10){this.y=10; this.vy=Math.abs(this.vy);} if(this.y>H-10){this.y=H-10; this.vy=-Math.abs(this.vy);} }
  integrate(){ const sp=Math.hypot(this.vx,this.vy); if(sp>this.maxSpeed){ this.vx*=this.maxSpeed/sp; this.vy*=this.maxSpeed/sp; } this.trail.push({x:this.x,y:this.y}); if(this.trail.length>params.tailLen) this.trail.shift(); this.x+=this.vx; this.y+=this.vy; this.stuckT=(sp<0.10)?(this.stuckT+1):0; }
}

class Collector extends Agent{
  constructor(x,y,teamState,netRef){
    const cfg=teamState.config;
    super(x,y,teamState.config.color,cfg.speed,teamState.config.id);
    this.teamState=teamState;
    this.netRef=netRef;
    this.fitness=0;
  }
  update(){
    const cfg=this.teamState.config;
    const teamId=cfg.id;
    this.stepSpeed(cfg.speed);
    const myGoal=this.teamState.goal;
    const tgt = this.carry? myGoal : nearest(fruits, this.x, this.y);
    let tx=0,ty=0, dn=1;
    if(tgt){ tx=tgt.x-this.x; ty=tgt.y-this.y; dn=Math.hypot(tx,ty)||1; tx/=dn; ty/=dn; }
    const g = senseGrad(teamId, this.carry? 'home':'food', this.x, this.y);
    const mates = this.teamState.agents;
    let sx=0, sy=0;
    for(const p of mates){
      if(p===this) continue;
      const dx=this.x-p.x, dy=this.y-p.y;
      const d=Math.hypot(dx,dy);
      if(d>0 && d<22){ sx+=dx/(d*d); sy+=dy/(d*d); }
    }
    const input = [tx,ty, g.gx, g.gy, sx, sy, 1.0];
    const out = forward(this.netRef.net, input);
    this.vx += out[0]*(0.45 + 0.15*cfg.smart) + (tx*0.15*cfg.strat);
    this.vy += out[1]*(0.45 + 0.15*cfg.smart) + (ty*0.15*cfg.strat);
    if(!this.carry && tgt && Math.hypot(tgt.x-this.x,tgt.y-this.y)<9){
      const i=fruits.indexOf(tgt);
      if(i>-1) fruits.splice(i,1);
      this.carry=true;
      this.fitness += 8;
    }
    if(this.carry && Math.hypot(myGoal.x-this.x,myGoal.y-this.y)<myGoal.r){
      this.carry=false;
      myGoal.delivered++;
      this.fitness += 120;
    }
    if(this.carry){
      const dGoal=Math.hypot(myGoal.x-this.x,myGoal.y-this.y);
      this.fitness += (1/(1+dGoal))*0.2;
    }
    deposit(teamId, this.carry? 'food':'home', this.x, this.y, 0.30);
    if(this.stuckT>35){
      this.vx += tx*(0.9+0.2*cfg.strat);
      this.vy += ty*(0.9+0.2*cfg.strat);
      this.stuckT=0;
    }
    this.avoidObstacles();
    this.keepInBounds();
    this.integrate();
  }
}

// ===== Setup & loop =====
let lastSpawn=performance.now();
function setup(){
  fruits.length=0;
  activeTeamStates=[];
  const activeTeams = params.teams.filter((team)=> team.active);
  if(activeTeams.length===0){
    params.teams[0].active = true;
    activeTeams.push(params.teams[0]);
    renderTeamRoster();
  }
  makeGrid();
  if(obstacles.length===0){ makeObstacles(params.obstacles); }
  resizePop();
  for(const team of activeTeams){
    resetGoalDelivery(team.id);
  }
  for(let i=0;i<params.maxFruits;i++) spawnFruit();
  activeTeamStates = activeTeams.map((team)=>{
    const population = getPopulation(team.id);
    const goal = ensureGoalState(team.id);
    goal.delivered = 0;
    const state = {
      config:team,
      population,
      agents:[],
      goal,
      bestFitnessCurrent:0,
      peakFitness:bestFitnessByTeam[team.id]||0
    };
    return state;
  });
  activeTeamStates.forEach((state)=>{
    const spawn = state.config.spawn || { x:[0.1,0.9], y:[0.1,0.9] };
    const minX = (spawn.x?.[0] ?? 0.1) * W;
    const maxX = (spawn.x?.[1] ?? 0.9) * W;
    const minY = (spawn.y?.[0] ?? 0.1) * H;
    const maxY = (spawn.y?.[1] ?? 0.9) * H;
    for(let i=0;i<state.config.count;i++){
      const netRef = state.population[i] || { net:makeNet(), fitness:0 };
      if(!state.population[i]) state.population[i] = netRef;
      netRef.fitness = 0;
      const agent = new Collector(rand(minX, maxX), rand(minY, maxY), state, netRef);
      state.agents.push(agent);
    }
  });
  lastSpawn=performance.now();
  Q('lbGen').textContent=evo.gen;
  refreshTeamStatus();
  refreshStats();
}

function drawTrail(trail,color){ if(trail.length<2) return; ctx.lineWidth=2; const grad=ctx.createLinearGradient(trail[0].x,trail[0].y,trail[trail.length-1].x,trail[trail.length-1].y); grad.addColorStop(0,'rgba(255,255,255,0)'); grad.addColorStop(1,color); ctx.strokeStyle=grad; ctx.beginPath(); ctx.moveTo(trail[0].x,trail[0].y); for(let i=1;i<trail.length;i++) ctx.lineTo(trail[i].x,trail[i].y); ctx.stroke(); }
function drawGoal(g, tint){
  ctx.beginPath();
  ctx.arc(g.x,g.y,g.r,0,Math.PI*2);
  ctx.fillStyle=COLORS.goalFill;
  ctx.fill();
  ctx.save();
  ctx.strokeStyle=tint;
  ctx.lineWidth = 4; // static
  ctx.shadowColor='transparent';
  ctx.shadowBlur=0;
  ctx.stroke();
  ctx.restore();
  ctx.fillStyle='#fff';
  ctx.font='bold 18px ui-sans-serif';
  ctx.textAlign='center';
  ctx.textBaseline='middle';
  ctx.fillText(String(g.delivered), g.x, g.y);
}

function drawObstacleShape(o, time, preview=false){
  const paletteIndex = (typeof o.paletteIndex === 'number') ? o.paletteIndex : 0;
  const palette = OBSTACLE_COLORS[paletteIndex % OBSTACLE_COLORS.length];
  const phase = (typeof o.phase === 'number') ? o.phase : 0;
  const pulse = preview ? 0.3 + 0.2*Math.sin(time*0.9 + phase) : 0.45 + 0.35*Math.sin(time*0.9 + phase);
  const fillAlpha = preview ? 0.06 + 0.08*pulse : 0.10 + 0.14*pulse;
  const strokeAlpha = preview ? 0.45 : 0.6 + 0.3*pulse;
  const shadowAlpha = preview ? 0.16 : 0.35*pulse;
  ctx.save();
  ctx.shadowColor = hexToRgba(palette, shadowAlpha);
  ctx.shadowBlur = preview ? 10 : 18*pulse;
  const applyStroke = ()=>{ ctx.strokeStyle = hexToRgba(palette, strokeAlpha); };
  switch(o.type){
    case 'rect':{
      const halfW = o.width/2;
      const halfH = o.height/2;
      ctx.fillStyle = hexToRgba(palette, fillAlpha);
      applyStroke();
      ctx.lineWidth = (preview?1.6:2.2) + 0.8*pulse;
      ctx.setLineDash(preview ? [8,6] : []);
      ctx.beginPath();
      ctx.rect(o.x - halfW, o.y - halfH, o.width, o.height);
      ctx.fill();
      ctx.stroke();
      break;
    }
    case 'line':{
      applyStroke();
      ctx.lineWidth = (o.thickness||14) + (preview?0:2)*pulse;
      ctx.lineCap = 'round';
      ctx.setLineDash(preview ? [6,6] : []);
      ctx.beginPath();
      ctx.moveTo(o.x1, o.y1);
      ctx.lineTo(o.x2, o.y2);
      ctx.stroke();
      break;
    }
    case 'half':{
      const start = o.angle - Math.PI/2;
      const end = o.angle + Math.PI/2;
      const startX = o.x + Math.cos(start)*o.r;
      const startY = o.y + Math.sin(start)*o.r;
      ctx.fillStyle = hexToRgba(palette, fillAlpha);
      applyStroke();
      ctx.lineWidth = (preview?1.6:2.3) + 0.8*pulse;
      ctx.setLineDash(preview ? [8,6] : []);
      ctx.beginPath();
      ctx.moveTo(startX, startY);
      ctx.arc(o.x, o.y, o.r, start, end);
      ctx.lineTo(startX, startY);
      ctx.fill();
      ctx.stroke();
      break;
    }
    default:{
      const radius = o.r || getObstacleRadius(o);
      ctx.fillStyle = hexToRgba(palette, fillAlpha);
      applyStroke();
      ctx.lineWidth = 2.1 + 0.9*pulse;
      ctx.setLineDash(preview ? [8,6] : []);
      ctx.beginPath();
      ctx.arc(o.x, o.y, radius, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
      break;
    }
  }
  ctx.restore();
}

function draw(){
  ctx.clearRect(0,0,W,H);

  // Goals (static, no blinking)
  for(const team of activeTeamStates){
    drawGoal(team.goal, team.config.color);
  }

  // Obstacles (ambient pulse)
  const t = performance.now()*0.001;
  for(const o of obstacles){
    drawObstacleShape(o, t, false);
  }
  if(drawingState){
    const preview = buildObstacleFromState(drawingState, true);
    if(preview){
      preview.paletteIndex = manualPaletteCursor % OBSTACLE_COLORS.length;
      drawObstacleShape(preview, t, true);
    }
  }

  // Fruits
  for(const f of fruits){
    ctx.beginPath();
    ctx.arc(f.x,f.y,f.r,0,Math.PI*2);
    ctx.fillStyle=COLORS.fruit;
    ctx.fill();
    ctx.lineWidth=1.5;
    ctx.strokeStyle=COLORS.fruitOutline;
    ctx.stroke();
  }

  // Agents (no shadow flash)
  for(const team of activeTeamStates){
    const outline = team.config.outline || '#0f172a';
    for(const a of team.agents){
      ctx.beginPath();
      ctx.arc(a.x,a.y,5.2,0,Math.PI*2);
      ctx.fillStyle=team.config.color;
      ctx.fill();
      ctx.lineWidth=2;
      ctx.strokeStyle=outline;
      ctx.stroke();
      if(a.carry){ ctx.lineWidth=2; ctx.strokeStyle='#ffff33'; ctx.stroke(); }
      drawTrail(a.trail, team.config.color);
    }
  }
}

let simSteps=0, forceNextGen=false, awaitingManualAdvance=false;
function advanceGeneration(){
  for(const teamState of activeTeamStates){
    const pop = getPopulation(teamState.config.id);
    for(let i=0;i<teamState.agents.length && i<pop.length;i++){
      pop[i].fitness += teamState.agents[i].fitness;
    }
    evolveTeam(teamState);
  }
  evo.gen++;
  Q('lbGen').textContent=evo.gen;
  simSteps=0;
  forceNextGen=false;
  awaitingManualAdvance=false;
  setup();
}
function loop(){
  requestAnimationFrame(loop);

  if(awaitingManualAdvance){
    if(forceNextGen){
      advanceGeneration();
    }
    return;
  }

  const now = performance.now();
  for(const team of activeTeamStates){
    for(const agent of team.agents){
      agent.update();
    }
  }
  evaporate();
  if(now - lastSpawn >= params.spawnMs){
    spawnFruit();
    lastSpawn = now;
  }
  draw();
  refreshStats();
  simSteps++;

  const reachedLimit = simSteps>=params.learn.genSteps;
  if(forceNextGen || (reachedLimit && params.learn.auto)){
    advanceGeneration();
  }else if(reachedLimit){
    awaitingManualAdvance=true;
  }
}

function applyBestFitnessSnapshot(bestMap){
  if(!bestMap) return;
  for(const [teamId, value] of Object.entries(bestMap)){
    const numeric = Number(value);
    if(!Number.isFinite(numeric)) continue;
    bestFitnessByTeam[teamId] = numeric;
  }
  for(const team of activeTeamStates){
    const stored = bestFitnessByTeam[team.config.id];
    if(Number.isFinite(stored)){
      team.peakFitness = Math.max(team.peakFitness||0, stored);
      updateTeamBestLabel(team.config.id, stored);
    }
  }
  refreshStats();
}

function captureTrainingSnapshot(){
  const paramsClone = JSON.parse(JSON.stringify(params));
  const evoTeams = params.teams.map((team)=>{
    const population = getPopulation(team.id);
    return {
      id:team.id,
      active:!!team.active,
      members:population.map((member)=> ({ net:cloneNet(member.net), fitness:member.fitness||0 }))
    };
  });
  return {
    version:2,
    savedAt:new Date().toISOString(),
    params:paramsClone,
    evo:{
      gen:evo.gen,
      teams:evoTeams
    },
    best:Object.fromEntries(Object.entries(bestFitnessByTeam))
  };
}

function downloadTrainingData(){
  try{
    const snapshot = captureTrainingSnapshot();
    const json = JSON.stringify(snapshot, null, 2);
    const blob = new Blob([json], { type:'application/json' });
    const { url, token } = setCurrentObjectUrl(URL.createObjectURL(blob));
    const genStr = String(snapshot.evo?.gen ?? 1).padStart(3, '0');
    const link = document.createElement('a');
    link.href = url;
    link.download = `foodsim-training-gen${genStr}.json`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    setTimeout(()=> clearCurrentObjectUrl(token), 1000);
  }catch(err){
    console.error('Failed to export training data', err);
    alert('Could not save training data. Please try again.');
  }
}

function applyParamsSnapshot(snapshot){
  if(!snapshot) return;
  if(snapshot.maxFruits != null) setRangeValue('slFruits', snapshot.maxFruits);
  if(snapshot.spawnMs != null) setRangeValue('slSpawn', snapshot.spawnMs);
  if(snapshot.obstacles != null) setRangeValue('slObst', snapshot.obstacles);
  if(snapshot.tailLen != null) setRangeValue('slTail', snapshot.tailLen);

  if(Array.isArray(snapshot.teams) && snapshot.teams.length){
    const first = snapshot.teams.find(Boolean) || {};
    if(first.count != null) setRangeValue('slTeamCount', first.count);
    if(first.speed != null) setRangeValue('slTeamSpeed', Math.round(first.speed*100));
    if(first.smart != null) setRangeValue('slTeamSmart', Math.round(first.smart*100));
    if(first.strat != null) setRangeValue('slTeamStrat', Math.round(first.strat*100));
    if(first.sep != null) setRangeValue('slTeamSep', Math.round(first.sep*100));
    snapshot.teams.forEach((teamSnapshot)=>{
      const target = params.teams.find((t)=>t.id===teamSnapshot.id);
      if(!target) return;
      if(teamSnapshot.active !== undefined) target.active = !!teamSnapshot.active;
    });
    renderTeamRoster();
  } else {
    const refTeam = snapshot.green || snapshot.red || null;
    if(refTeam){
      if(refTeam.count != null) setRangeValue('slTeamCount', refTeam.count);
      if(refTeam.speed != null) setRangeValue('slTeamSpeed', Math.round(refTeam.speed*100));
      if(refTeam.smart != null) setRangeValue('slTeamSmart', Math.round(refTeam.smart*100));
      if(refTeam.strat != null) setRangeValue('slTeamStrat', Math.round(refTeam.strat*100));
      if(refTeam.sep != null) setRangeValue('slTeamSep', Math.round(refTeam.sep*100));
    }
    params.teams.forEach((team, index)=>{
      team.active = index < 2;
    });
    renderTeamRoster();
  }

  if(snapshot.learn){
    if(snapshot.learn.genSteps != null) setRangeValue('slGenSteps', snapshot.learn.genSteps);
    if(snapshot.learn.mut != null) setRangeValue('slMut', Math.round(snapshot.learn.mut*100));
    if(snapshot.learn.elite != null) setRangeValue('slElite', Math.round(snapshot.learn.elite*100));
    if(snapshot.learn.auto !== undefined){
      const auto = Q('chkAuto');
      if(auto){
        auto.checked = !!snapshot.learn.auto;
        auto.dispatchEvent(new Event('change', { bubbles:true }));
      }
    }
  }
}

function loadTrainingSnapshot(data){
  if(!data || typeof data !== 'object') throw new Error('Invalid training file.');
  const evoData = data.evo || data;
  if(!evoData) throw new Error('Training file is missing the evo section.');

  const toIndividual = (entry)=>{
    const netData = entry && (entry.net || entry);
    if(!netData || !netData.W1 || !netData.b1 || !netData.W2 || !netData.b2){
      throw new Error('Training file contains malformed network data.');
    }
    return { net:cloneNet(netData), fitness:0 };
  };

  let bestFromSnapshot = {};

  if(data.params) applyParamsSnapshot(data.params);

  if(Array.isArray(evoData.teams)){
    bestFromSnapshot = {};
    evoData.teams.forEach((teamEntry)=>{
      const members = Array.isArray(teamEntry.members) ? teamEntry.members : [];
      evo.populations[teamEntry.id] = members.map(toIndividual);
      const targetTeam = params.teams.find((t)=>t.id===teamEntry.id);
      if(targetTeam && teamEntry.active !== undefined){
        targetTeam.active = !!teamEntry.active;
      }
      let bestFitness = 0;
      for(const item of members){
        const val = Number(item?.fitness);
        if(Number.isFinite(val) && val > bestFitness) bestFitness = val;
      }
      bestFromSnapshot[teamEntry.id] = bestFitness;
    });
    renderTeamRoster();
  } else {
    const greensData = Array.isArray(evoData.greens) ? evoData.greens : (Array.isArray(evoData.G) ? evoData.G : null);
    const redsData = Array.isArray(evoData.reds) ? evoData.reds : (Array.isArray(evoData.R) ? evoData.R : null);
    if(!greensData || !redsData) throw new Error('Training file does not contain both team genomes.');

    evo.populations.green = greensData.map(toIndividual);
    evo.populations.red = redsData.map(toIndividual);
    params.teams.forEach((team, index)=>{
      team.active = index < 2;
    });
    renderTeamRoster();

    let bestG = 0;
    for(const item of greensData){
      const val = Number(item?.fitness);
      if(Number.isFinite(val) && val > bestG) bestG = val;
    }
    let bestR = 0;
    for(const item of redsData){
      const val = Number(item?.fitness);
      if(Number.isFinite(val) && val > bestR) bestR = val;
    }
    bestFromSnapshot = { green:bestG, red:bestR };
  }

  const parsedGen = Number(evoData.gen);
  evo.gen = Number.isFinite(parsedGen) && parsedGen > 0 ? parsedGen : 1;

  simSteps = 0;
  forceNextGen = false;
  awaitingManualAdvance = false;
  setup();

  const bestCombined = Object.assign({}, bestFromSnapshot, data.best || {});
  applyBestFitnessSnapshot(bestCombined);
}

function handleTrainingFileSelection(evt){
  const input = evt.target;
  const file = input?.files?.[0];
  if(input) input.value = '';
  if(!file) return;
  const reader = new FileReader();
  reader.onload = ()=>{
    try{
      const parsed = JSON.parse(reader.result);
      loadTrainingSnapshot(parsed);
    }catch(err){
      console.error('Failed to load training file', err);
      alert('Could not load training data. Please ensure it was exported from this simulator.');
    }
  };
  reader.onerror = ()=>{
    console.error('Unable to read the selected file', reader.error);
    alert('Could not read the selected file.');
  };
  reader.readAsText(file);
}

const btnSaveTraining = Q('btnSaveTraining');
if(btnSaveTraining){
  btnSaveTraining.addEventListener('click', downloadTrainingData);
}
const btnLoadTraining = Q('btnLoadTraining');
const inputLoadTraining = Q('inputLoadTraining');
if(btnLoadTraining && inputLoadTraining){
  btnLoadTraining.addEventListener('click', ()=> inputLoadTraining.click());
  inputLoadTraining.addEventListener('change', handleTrainingFileSelection);
}

const toolButtons = Array.from(document.querySelectorAll('.tool-btn'));
function setTool(tool){
  if(!toolButtons.length){
    currentTool = tool || TOOL_SELECT;
    return;
  }
  const nextTool = toolButtons.some(btn=>btn.dataset.tool===tool) ? tool : TOOL_SELECT;
  currentTool = nextTool;
  toolButtons.forEach(btn=>{
    const isActive = btn.dataset.tool === nextTool;
    btn.classList.toggle('active', isActive);
    btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
  });
  if(currentTool === TOOL_SELECT){
    drawingState = null;
  }
}

if(toolButtons.length){
  toolButtons.forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const tool = btn.dataset.tool || TOOL_SELECT;
      setTool(tool);
    });
  });
  setTool(TOOL_SELECT);
}

const btnClearManual = Q('btnClearManual');
if(btnClearManual){
  btnClearManual.addEventListener('click', ()=>{
    for(let i=obstacles.length-1; i>=0; i--){
      if(obstacles[i].manual){
        obstacles.splice(i,1);
      }
    }
    manualPaletteCursor = 0;
  });
}

// Bind ranges after DOM ready
['Fruits','Spawn','Obst','Tail','TeamCount','TeamSpeed','TeamSmart','TeamStrat','TeamSep','GenSteps','Mut','Elite'].forEach(k=>{
  bindRange('sl'+k, 'lb'+k, (v)=> (k.includes('Speed')||k.includes('Smart')||k.includes('Strat')||k.includes('Sep')) ? (v/100).toFixed(2) : v);
});
Q('btnReset').onclick = ()=> { awaitingManualAdvance=false; forceNextGen=false; simSteps=0; setup(); };
Q('btnNextGen').onclick = ()=> { forceNextGen = true; };
Q('chkAuto').addEventListener('change', ()=> readParams());

window.addEventListener('beforeunload', clearCurrentObjectUrl);

// Start
initMusicPanel();
renderTeamRoster();
readParams();
setup();
loop();
</script>
</body>
</html>
