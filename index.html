<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>FoodSim – Two Teams with NEAT-lite</title>
  <style>
    :root {
      --bg1:#050516;
      --bg2:#161b3f;
      --panel:rgba(18,24,56,.82);
      --ink:#f1f5ff;
      --muted:#a1a9d8;
      --accent:#f472b6;
      --accent-emerald:#2dd4bf;
      --accent-cyan:#38bdf8;
      --silver:rgba(222,231,255,.55);
    }
    *{box-sizing:border-box}
    body{margin:0; min-height:100vh; display:flex; flex-direction:column; background:radial-gradient(circle at 45% 12%, rgba(87,51,183,.55) 0%, rgba(39,56,121,.85) 45%, var(--bg1) 100%); color:var(--ink); font-family:"Inter",system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;}

    .main-nav{position:sticky; top:0; z-index:200; padding:22px 48px; display:flex; align-items:center; justify-content:space-between; background:linear-gradient(120deg, rgba(15,20,48,.92) 0%, rgba(10,14,34,.75) 60%, rgba(10,14,34,.35) 100%); backdrop-filter:blur(14px); border-bottom:1px solid var(--silver); box-shadow:0 22px 45px rgba(5,9,25,.55)}
    .brand{display:flex; align-items:center; gap:12px; font-size:22px; font-weight:700; letter-spacing:.02em; color:var(--ink)}
    .brand-dot{width:14px; height:14px; border-radius:50%; background:linear-gradient(135deg, var(--accent) 0%, #8b5cf6 100%); box-shadow:0 0 18px rgba(244,114,182,.6)}
    .nav-links{display:flex; align-items:center; gap:12px}
    .pill-link{display:inline-flex; align-items:center; justify-content:center; padding:10px 20px; border-radius:999px; border:1px solid rgba(45,212,191,.45); background:linear-gradient(120deg, rgba(45,212,191,.18), rgba(59,130,246,.18)); color:var(--ink); text-decoration:none; font-size:14px; font-weight:600; letter-spacing:.03em; transition:transform .2s ease, box-shadow .2s ease, filter .2s ease, border-color .2s ease}
    .pill-link.secondary{border-color:rgba(139,92,246,.45); background:linear-gradient(120deg, rgba(139,92,246,.18), rgba(244,114,182,.18))}
    .pill-link:hover{transform:translateY(-1px); filter:brightness(1.05); box-shadow:0 16px 32px rgba(45,212,191,.25)}
    .pill-link:focus-visible{outline:2px solid rgba(56,189,248,.65); outline-offset:3px}

    main{flex:1; display:flex; justify-content:center; align-items:flex-start; padding:40px 48px 64px}
    .wrap{display:flex; align-items:flex-start; justify-content:center; gap:40px; width:100%; max-width:2000px}
    .field-area{flex:1 1 auto; display:flex; flex-direction:column; align-items:stretch; gap:18px; min-width:0}
    canvas{border-radius:24px; background:#04091f; box-shadow:0 0 45px rgba(15,23,61,.65), inset 0 0 22px rgba(118,133,255,.12); cursor:crosshair; border:1px solid var(--silver);}
    .stats-bar{display:grid; grid-template-columns:repeat(auto-fit,minmax(150px,1fr)); gap:16px; padding:18px 22px; border-radius:18px; background:rgba(11,16,44,.78); border:1px solid var(--silver); box-shadow:0 18px 32px rgba(5,9,25,.45)}
    .stat-card{display:flex; flex-direction:column; gap:6px; padding:6px 0}
    .stat-label{font-size:12px; text-transform:uppercase; letter-spacing:.12em; color:var(--muted)}
    .stat-value{font-size:26px; font-weight:700; letter-spacing:.02em; color:var(--ink)}

    .brain-viz{padding:20px 24px; border-radius:22px; background:rgba(11,16,44,.82); border:1px solid var(--silver); box-shadow:0 18px 32px rgba(5,9,25,.4); display:flex; flex-direction:column; gap:14px}
    .brain-viz.brain-viz--hidden{box-shadow:0 12px 24px rgba(5,9,25,.35)}
    .brain-head{display:flex; align-items:flex-start; justify-content:space-between; gap:18px; flex-wrap:wrap}
    .brain-title{font-size:16px; font-weight:600; letter-spacing:.03em}
    .brain-sub{font-size:12px; color:var(--muted); margin-top:4px; max-width:420px}
    .brain-controls{display:flex; align-items:center; flex-wrap:wrap; gap:10px; margin-top:12px}
    .brain-select{padding:7px 16px; border-radius:999px; border:1px solid rgba(56,189,248,.35); background:rgba(12,20,46,.75); color:var(--ink); font-size:12px; font-weight:600; letter-spacing:.05em; text-transform:uppercase; cursor:pointer; appearance:none; position:relative; min-width:190px; box-shadow:inset 0 0 16px rgba(56,189,248,.12)}
    .brain-select:focus-visible{outline:2px solid rgba(56,189,248,.65); outline-offset:3px}
    .brain-toggle{padding:6px 14px; border-radius:999px; border:1px solid rgba(56,189,248,.45); background:rgba(15,23,61,.6); color:var(--ink); font-size:11px; font-weight:600; letter-spacing:.12em; text-transform:uppercase; cursor:pointer; transition:transform .18s ease, box-shadow .2s ease, filter .2s ease}
    .brain-toggle:hover{filter:brightness(1.05); transform:translateY(-1px); box-shadow:0 12px 24px rgba(56,189,248,.25)}
    .brain-toggle[aria-pressed="false"]{border-color:rgba(244,114,182,.45); background:rgba(24,16,38,.65); color:var(--muted)}
    .brain-score{display:flex; flex-direction:column; align-items:flex-end; min-width:120px}
    .brain-score-label{font-size:11px; text-transform:uppercase; letter-spacing:.12em; color:var(--muted)}
    .brain-score-value{font-size:30px; font-weight:700; color:var(--ink)}
    .brain-team{display:flex; align-items:center; gap:10px; font-size:13px; color:var(--muted); flex-wrap:wrap}
    .brain-badge{display:inline-flex; align-items:center; justify-content:center; width:26px; height:26px; border-radius:50%; background:rgba(56,189,248,.3); color:#020617; font-size:15px; font-weight:700; box-shadow:0 0 18px rgba(56,189,248,.28)}
    .brain-gen{margin-left:auto; font-size:11px; color:var(--muted); letter-spacing:.08em; text-transform:uppercase}
    .brain-canvas{width:100%; height:220px; border-radius:18px; background:linear-gradient(135deg, rgba(15,23,61,.65), rgba(12,18,44,.92)); border:1px solid rgba(148,163,209,.28)}
    .brain-paused{margin-top:10px; padding:12px 14px; border-radius:14px; border:1px dashed rgba(148,163,209,.4); background:rgba(15,23,61,.55); font-size:12px; line-height:1.6; color:var(--muted)}
    .brain-guide{margin-top:16px; padding:18px 20px; border-radius:18px; border:1px solid var(--silver); background:rgba(11,16,44,.78); box-shadow:0 12px 28px rgba(5,9,25,.35);}
    .brain-guide summary{cursor:pointer; font-weight:600; letter-spacing:.04em; text-transform:uppercase; font-size:12px; color:var(--muted); display:flex; align-items:center; justify-content:space-between; gap:12px}
    .brain-guide summary::-webkit-details-marker{display:none}
    .brain-guide summary::after{content:'▾'; font-size:12px; transition:transform .25s ease}
    .brain-guide[open] summary::after{transform:rotate(-180deg)}
    .brain-guide-body{margin-top:14px; display:grid; gap:16px}
    .brain-guide-body p{margin:0; font-size:13px; color:var(--ink); line-height:1.7}
    .brain-diagram{border-radius:16px; border:1px solid rgba(148,163,209,.28); background:linear-gradient(135deg, rgba(15,23,61,.55), rgba(12,18,44,.9)); padding:14px}
    .brain-diagram svg{width:100%; height:auto}
    .brain-diagram text{fill:rgba(226,232,255,0.82); font-family:"Inter",system-ui,-apple-system,sans-serif; font-size:12px; letter-spacing:.02em}
    .brain-diagram .label{font-size:13px; font-weight:600}

    .side{width:420px; flex:0 1 420px; display:flex; flex-direction:column; gap:20px}
    .panel{background:var(--panel); border:1px solid var(--silver); padding:22px; border-radius:20px; backdrop-filter:blur(16px); box-shadow:0 18px 45px rgba(5,7,24,.55); position:relative}
    .panel-head{display:flex; align-items:center; justify-content:space-between; gap:12px; cursor:pointer; user-select:none; padding-bottom:10px; margin-bottom:14px; border-bottom:1px dashed rgba(189,206,255,.28)}
    .panel-head .h{margin:0; font-size:17px; letter-spacing:.03em}
    .chev{font-weight:900; font-size:16px; opacity:.75; transition:transform .25s ease}
    .panel-body{max-height:none; overflow:visible; transition:opacity .25s ease; opacity:1}
    .panel.collapsed .panel-body{max-height:0; opacity:0; overflow:hidden; pointer-events:none}
    .panel.collapsed .chev{transform:rotate(-90deg)}

    .grid{display:grid; grid-template-columns: 1fr 1.3fr auto; gap:12px 12px; align-items:center}
    .label{font-size:13px; color:var(--muted); letter-spacing:.02em}
    .val{font-family:ui-monospace,Menlo,Consolas,monospace; font-size:12px; padding:4px 8px; border-radius:8px; background:rgba(10,16,46,.7); border:1px solid var(--silver); color:var(--accent-cyan); box-shadow:inset 0 0 12px rgba(56,189,248,.12)}
    input[type=range]{width:100%; accent-color:var(--accent-cyan)}
    .fruit-placement-options{grid-column:2 / span 2; display:flex; flex-wrap:wrap; gap:8px}
    .fruit-placement-option{position:relative; display:inline-flex; align-items:center; gap:8px; padding:8px 12px; border-radius:12px; border:1px solid var(--silver); background:rgba(12,18,44,.65); color:var(--muted); font-size:12px; font-weight:600; letter-spacing:.03em; cursor:pointer; transition:filter .2s ease, transform .2s ease, box-shadow .2s ease, border-color .2s ease}
    .fruit-placement-option:hover{filter:brightness(1.05); transform:translateY(-1px)}
    .fruit-placement-option.active{border-color:rgba(56,189,248,.55); color:var(--ink); background:rgba(12,22,56,.9); box-shadow:0 10px 24px rgba(56,189,248,.18)}
    .fruit-placement-option input{position:absolute; inset:0; opacity:0; pointer-events:none}
    .btn{display:block; width:100%; padding:12px 14px; border-radius:12px; border:1px solid rgba(45,212,191,.45); background:linear-gradient(120deg, rgba(45,212,191,.18), rgba(59,130,246,.18)); color:var(--ink); cursor:pointer; text-align:center; margin-top:14px; font-weight:600; letter-spacing:.02em; transition:transform .2s ease, box-shadow .2s ease, filter .2s ease}
    .btn:hover{filter:brightness(1.08); transform:translateY(-1px); box-shadow:0 20px 36px rgba(45,212,191,.28)}
    .btn:disabled{opacity:.55; cursor:not-allowed; filter:saturate(.5); box-shadow:none}
    .tool-hint{margin:0 0 14px; font-size:12px; line-height:1.6; color:var(--muted)}
    .tool-buttons{display:grid; grid-template-columns:repeat(auto-fit,minmax(120px,1fr)); gap:10px}
    .tool-btn{padding:10px 12px; border-radius:12px; border:1px solid rgba(59,130,246,.28); background:rgba(18,27,66,.6); color:var(--ink); font-size:13px; font-weight:600; letter-spacing:.02em; cursor:pointer; transition:transform .2s ease, box-shadow .2s ease, filter .2s ease, border-color .2s ease}
    .tool-btn:hover{filter:brightness(1.05); transform:translateY(-1px); box-shadow:0 12px 26px rgba(59,130,246,.22)}
    .tool-btn.active{border-color:rgba(45,212,191,.65); background:linear-gradient(120deg, rgba(45,212,191,.24), rgba(59,130,246,.24)); box-shadow:0 14px 28px rgba(45,212,191,.24)}
    .sub{font-weight:800; font-size:14px; opacity:.9; margin:10px 0 8px; letter-spacing:.05em; color:var(--ink)}
    .team-roster{display:grid; grid-template-columns:repeat(auto-fit,minmax(160px,1fr)); gap:12px}
    .team-card{position:relative; display:flex; flex-direction:column; gap:6px; padding:14px 16px; border-radius:14px; border:1px solid var(--silver); background:rgba(12,18,44,.72); box-shadow:0 10px 24px rgba(5,9,28,.4); transition:transform .2s ease, box-shadow .2s ease, border-color .2s ease}
    .team-card:hover{transform:translateY(-2px); box-shadow:0 16px 32px rgba(5,9,28,.5)}
    .team-card.active{border-color:rgba(45,212,191,.6); box-shadow:0 18px 36px rgba(45,212,191,.22)}
    .team-card input[type=checkbox]{position:absolute; inset:0; opacity:0; cursor:pointer; border-radius:14px}
    .team-card .team-header{display:flex; align-items:center; gap:10px}
    .team-card .team-name{font-weight:600; letter-spacing:.02em}
    .team-card .team-meta{font-size:12px; color:var(--muted)}
    .team-score{font-size:12px; color:var(--ink); font-weight:600; margin-top:2px}
    .team-score span{color:var(--muted); font-weight:500}
    .team-badge{display:inline-flex; align-items:center; justify-content:center; width:28px; height:28px; border-radius:50%; font-size:16px; box-shadow:0 0 18px rgba(255,255,255,.2); color:#020617}
    .team-configs{display:grid; gap:16px; margin-top:16px}
    .team-config-card{border:1px solid var(--silver); border-radius:16px; background:rgba(12,18,44,.72); padding:18px 20px; box-shadow:0 12px 28px rgba(5,9,28,.45); display:grid; gap:14px; transition:filter .2s ease, border-color .2s ease}
    .team-config-card.inactive{filter:saturate(.65) brightness(.85); border-color:rgba(148,163,209,.28)}
    .team-config-header{display:flex; align-items:center; justify-content:space-between; gap:12px}
    .team-config-title{display:flex; align-items:center; gap:10px; font-weight:600; letter-spacing:.02em}
    .team-config-badge{display:inline-flex; align-items:center; justify-content:center; width:26px; height:26px; border-radius:50%; box-shadow:0 0 12px rgba(148,163,209,.28); font-size:15px}
    .team-config-status{font-size:12px; color:var(--muted)}
    .team-config-grid{display:grid; grid-template-columns: minmax(90px,0.9fr) 1fr auto; gap:10px 12px; align-items:center}
    .team-config-grid .label{font-size:12px; text-transform:uppercase; letter-spacing:.08em}
    .team-config-grid .val{min-width:56px; text-align:right}
    .music-lead{font-size:13px; line-height:1.6; opacity:.85; margin:0 0 14px}
    .music-select{display:flex; flex-direction:column; gap:6px}
    .music-dropdown{width:100%; padding:10px 12px; border-radius:12px; border:1px solid var(--silver); background:rgba(12,18,44,.82); color:var(--ink); font-size:13px; font-family:inherit; letter-spacing:.01em; box-shadow:inset 0 0 12px rgba(118,133,255,.15)}
    .music-controls{display:flex; align-items:center; gap:12px; margin-top:12px; flex-wrap:wrap}
    .music-controls .btn{flex:0 0 auto; width:auto; padding:10px 18px; margin-top:0}
    .music-volume{display:flex; flex:1; align-items:center; gap:10px; min-width:200px}
    .music-volume .label{min-width:60px}
    .music-volume input[type=range]{flex:1}
    .music-meta{margin-top:14px; font-size:12px; line-height:1.6; background:rgba(11,16,44,.65); border:1px solid var(--silver); padding:12px 14px; border-radius:14px; box-shadow:inset 0 0 14px rgba(138,92,246,.12)}
    .music-status{display:flex; align-items:center; gap:8px; font-size:12px; text-transform:uppercase; letter-spacing:.08em; opacity:.82; color:var(--accent-cyan)}
    .music-attr{opacity:.72}
    .sr-only{position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0}

    @media (max-width:1200px){
      .wrap{flex-direction:column; align-items:center}
      .field-area{width:100%}
      .side{width:100%; max-width:720px}
    }
    @media (max-width:900px){
      main{padding:32px 28px 56px}
    }
    @media (max-width:768px){
      .main-nav{flex-direction:column; align-items:flex-start; gap:16px; padding:18px 24px}
      .nav-links{flex-wrap:wrap}
      main{padding:28px 20px 56px}
      .wrap{gap:28px}
      canvas{width:100%; height:auto}
      .stats-bar{grid-template-columns:repeat(auto-fit,minmax(130px,1fr)); gap:12px; padding:16px 18px}
      .stat-value{font-size:22px}
      .side{max-width:100%}
      .brain-canvas{height:200px}
    }
  </style>
</head>
<body>
  <header class="main-nav">
    <div class="brand"><span class="brand-dot"></span>FoodSim NEAT Lab</div>
    <nav class="nav-links" aria-label="Primary navigation">
      <a class="pill-link" href="#world">Playfield</a>
      <a class="pill-link" href="#panel-global">Controls</a>
      <a class="pill-link secondary" href="learn-neat.html">How NEAT works</a>
    </nav>
  </header>
  <main>
  <div class="wrap">
    <!-- Left panel: Learning (NEAT) -->
    <aside class="side" id="left-panel">
      <div class="panel" id="panel-learn">
        <div class="panel-head"><div class="h">Learning (NEAT-lite)</div><span class="chev">▾</span></div>
        <div class="panel-body">
          <div class="grid">
            <div class="label" title="Number of simulation steps each generation runs before evaluating fitness.">Steps / gen</div>
            <input id="slGenSteps" type="range" min="600" max="100000000" value="2800" title="Number of simulation steps each generation runs before evaluating fitness."><div class="val" id="lbGenSteps">2800</div>

            <div class="label" title="Percentage of offspring genomes that receive random mutations.">Mutation %</div>
            <input id="slMut" type="range" min="1" max="80" value="16" title="Percentage of offspring genomes that receive random mutations."><div class="val" id="lbMut">16%</div>

            <div class="label" title="Share of the best performers copied directly into the next generation.">Elite ratio</div>
            <input id="slElite" type="range" min="1" max="100" value="20" title="Share of the best performers copied directly into the next generation."><div class="val" id="lbElite">20%</div>

            <div class="label" title="Strength of the random adjustments applied to neural network connection weights.">Mutate weights</div>
            <input id="slMutStrengthW" type="range" min="5" max="100" value="20" title="Strength of the random adjustments applied to neural network connection weights."><div class="val" id="lbMutStrengthW">0.20</div>

            <div class="label" title="Strength of the random adjustments applied to neuron bias values.">Mutate biases</div>
            <input id="slMutStrengthB" type="range" min="5" max="100" value="20" title="Strength of the random adjustments applied to neuron bias values."><div class="val" id="lbMutStrengthB">0.20</div>

            <div class="label" title="Chance that crossover keeps genes from parent A versus parent B.">Crossover bias</div>
            <input id="slCrossover" type="range" min="0" max="100" value="50" title="Chance that crossover keeps genes from parent A versus parent B."><div class="val" id="lbCrossover">50% A</div>

            <div class="label" title="Number of contenders in the tournament pool when picking parents.">Selection pool</div>
            <input id="slTournament" type="range" min="10" max="60" value="20" step="1" title="Number of contenders in the tournament pool when picking parents."><div class="val" id="lbTournament">×2.0</div>

            <div class="label" title="Percentage of brand new genomes injected into each generation.">Fresh spawn %</div>
            <input id="slFresh" type="range" min="0" max="40" value="0" title="Percentage of brand new genomes injected into each generation."><div class="val" id="lbFresh">0%</div>

            <div class="label" title="Automatically advance once the current generation finishes simulating.">Auto next gen</div>
            <input id="chkAuto" type="checkbox" checked title="Automatically advance once the current generation finishes simulating."><div class="val" id="lbAuto">on</div>
          </div>
          <button id="btnNextGen" class="btn">Advance generation now</button>
          <button id="btnSaveTraining" class="btn">Save training (.json)</button>
          <button id="btnLoadTraining" class="btn">Load training…</button>
          <input type="file" id="inputLoadTraining" accept="application/json" style="display:none">
        </div>
      </div>

      <div class="panel" id="panel-toolbox">
        <div class="panel-head"><div class="h">Obstacle toolbox</div><span class="chev">▾</span></div>
        <div class="panel-body">
          <p class="tool-hint">Choose a tool to draw glowing obstacles directly on the field.</p>
          <div class="tool-buttons" role="group" aria-label="Obstacle drawing tools">
            <button class="tool-btn active" data-tool="select" aria-pressed="true">Move</button>
            <button class="tool-btn" data-tool="circle" aria-pressed="false">Circle</button>
            <button class="tool-btn" data-tool="rect" aria-pressed="false">Rectangle</button>
            <button class="tool-btn" data-tool="line" aria-pressed="false">Line</button>
            <button class="tool-btn" data-tool="half" aria-pressed="false">Half circle</button>
          </div>
          <button id="btnUndoManual" class="btn" disabled>Undo last manual obstacle</button>
          <button id="btnClearManual" class="btn">Clear manual obstacles</button>
        </div>
      </div>

      <div class="panel" id="panel-music">
        <div class="panel-head"><div class="h">Ambient Sound Lounge</div><span class="chev">▾</span></div>
        <div class="panel-body">
          <p class="music-lead">Play MP3 files from your audio folder. Add your own tracks to the list!</p>
          <div class="music-select">
            <label class="label" for="selMusic">Curated playlist</label>
            <select id="selMusic" class="music-dropdown"></select>
          </div>
          <div class="music-controls">
            <button id="btnMusicToggle" class="btn">Play</button>
            <div class="music-volume">
              <span class="label">Volume</span>
              <input id="slMusicVolume" type="range" min="0" max="100" value="55">
              <span class="val" id="lbMusicVolume">55%</span>
            </div>
          </div>
          <div class="music-meta">
            <div class="music-status"><span id="lbMusicState">Paused</span></div>
            <div id="lbMusicNow" class="music-attr">Choose a track to begin.</div>
            <div id="lbMusicSource" class="music-attr">Royalty-free ambient selections streamed from Pixabay artists.</div>
          </div>
        </div>
      </div>
    </aside>

    <!-- Middle: playfield -->
    <div class="field-area">
      <canvas id="world" width="1100" height="640"></canvas>
      <section class="stats-bar" aria-label="Simulation progress" aria-live="polite">
        <div class="stat-card">
          <span class="stat-label">Generation</span>
          <span class="stat-value" id="stat-gen">1</span>
        </div>
        <div class="stat-card">
          <span class="stat-label">Teams active</span>
          <span class="stat-value" id="stat-teams">2</span>
        </div>
        <div class="stat-card">
          <span class="stat-label">Fruits on field</span>
          <span class="stat-value" id="stat-fruits">0</span>
        </div>
        <div class="stat-card">
          <span class="stat-label">Deliveries</span>
          <span class="stat-value" id="stat-deliveries">0</span>
        </div>
        <div class="stat-card">
          <span class="stat-label">Top fitness</span>
          <span class="stat-value" id="stat-top">0</span>
        </div>
      </section>
      <section class="brain-viz" aria-live="polite" aria-label="Best performing neural network">
        <div class="brain-head">
          <div>
            <div class="brain-title">Neural Network Monitor</div>
            <div class="brain-sub" id="brain-subtitle">The leading brain will appear here once a team starts scoring.</div>
            <div class="brain-controls">
              <label class="sr-only" for="brainTeamSelect">Choose the team to visualize</label>
              <select id="brainTeamSelect" class="brain-select">
                <option value="auto">Auto — top performer</option>
              </select>
              <button type="button" id="brainToggleBtn" class="brain-toggle" aria-pressed="true">
                Hide visualization
              </button>
            </div>
          </div>
          <div class="brain-score">
            <span class="brain-score-label">Fitness</span>
            <span class="brain-score-value" id="brain-fitness">—</span>
          </div>
        </div>
        <div class="brain-team">
          <span class="brain-badge" id="brain-badge">●</span>
          <span id="brain-team">No leader yet</span>
          <span class="brain-gen" id="brain-generation">Gen —</span>
        </div>
        <canvas id="brainVizCanvas" class="brain-canvas" width="560" height="240" role="img" aria-label="Visualization of the current top neural network"></canvas>
        <div id="brainPausedNotice" class="brain-paused" hidden>
          Visualization hidden to save performance. Toggle it back on anytime to resume live updates.
        </div>
      </section>
      <details class="brain-guide" id="brainGuide">
        <summary>Neural network visual guide</summary>
        <div class="brain-guide-body">
          <p>
            This panel shows the brain of whichever team is winning the food race right now. Circles on the left are the signals the
            agents feel — fruit direction, teammate distance, obstacle pings and the round timer. The middle dots mix those signals,
            and the four outputs on the right tell the agent how to turn and how fast to move.
          </p>
          <figure class="brain-diagram">
            <svg viewBox="0 0 520 220" role="img" aria-labelledby="brain-diagram-title brain-diagram-desc">
              <title id="brain-diagram-title">Neural network layers</title>
              <desc id="brain-diagram-desc">Inputs flow to hidden neurons and then to four output commands.</desc>
              <defs>
                <linearGradient id="nodeInput" x1="0" x2="1" y1="0" y2="1">
                  <stop offset="0%" stop-color="#38bdf8" stop-opacity="0.6" />
                  <stop offset="100%" stop-color="#38bdf8" stop-opacity="0.2" />
                </linearGradient>
                <linearGradient id="nodeHidden" x1="0" x2="1" y1="0" y2="1">
                  <stop offset="0%" stop-color="#2dd4bf" stop-opacity="0.6" />
                  <stop offset="100%" stop-color="#2dd4bf" stop-opacity="0.2" />
                </linearGradient>
                <linearGradient id="nodeOutput" x1="0" x2="1" y1="0" y2="1">
                  <stop offset="0%" stop-color="#f472b6" stop-opacity="0.6" />
                  <stop offset="100%" stop-color="#f472b6" stop-opacity="0.2" />
                </linearGradient>
              </defs>
              <g stroke="rgba(148,163,209,0.35)" stroke-width="1.2">
                <line x1="110" y1="40" x2="260" y2="40" />
                <line x1="110" y1="40" x2="260" y2="100" />
                <line x1="110" y1="40" x2="260" y2="160" />
                <line x1="110" y1="100" x2="260" y2="40" />
                <line x1="110" y1="100" x2="260" y2="100" />
                <line x1="110" y1="100" x2="260" y2="160" />
                <line x1="110" y1="160" x2="260" y2="40" />
                <line x1="110" y1="160" x2="260" y2="100" />
                <line x1="110" y1="160" x2="260" y2="160" />
                <line x1="260" y1="40" x2="410" y2="40" />
                <line x1="260" y1="40" x2="410" y2="90" />
                <line x1="260" y1="40" x2="410" y2="140" />
                <line x1="260" y1="40" x2="410" y2="190" />
                <line x1="260" y1="100" x2="410" y2="40" />
                <line x1="260" y1="100" x2="410" y2="90" />
                <line x1="260" y1="100" x2="410" y2="140" />
                <line x1="260" y1="100" x2="410" y2="190" />
                <line x1="260" y1="160" x2="410" y2="40" />
                <line x1="260" y1="160" x2="410" y2="90" />
                <line x1="260" y1="160" x2="410" y2="140" />
                <line x1="260" y1="160" x2="410" y2="190" />
              </g>
              <g fill="url(#nodeInput)">
                <circle cx="110" cy="40" r="18"></circle>
                <circle cx="110" cy="100" r="18"></circle>
                <circle cx="110" cy="160" r="18"></circle>
              </g>
              <g fill="url(#nodeHidden)">
                <circle cx="260" cy="40" r="16"></circle>
                <circle cx="260" cy="100" r="16"></circle>
                <circle cx="260" cy="160" r="16"></circle>
              </g>
              <g fill="url(#nodeOutput)">
                <circle cx="410" cy="40" r="18"></circle>
                <circle cx="410" cy="90" r="18"></circle>
                <circle cx="410" cy="140" r="18"></circle>
                <circle cx="410" cy="190" r="18"></circle>
              </g>
              <text class="label" x="110" y="200" text-anchor="middle">Inputs</text>
              <text class="label" x="260" y="200" text-anchor="middle">Hidden layer</text>
              <text class="label" x="410" y="200" text-anchor="middle">Outputs</text>
              <text x="440" y="40" text-anchor="start" dominant-baseline="middle">Drive X</text>
              <text x="440" y="90" text-anchor="start" dominant-baseline="middle">Drive Y</text>
              <text x="440" y="140" text-anchor="start" dominant-baseline="middle">Speed +</text>
              <text x="440" y="190" text-anchor="start" dominant-baseline="middle">Speed −</text>
            </svg>
          </figure>
          <p>
            Bright lines mean a strong signal. Cyan edges push movement in the same direction as the input, while magenta edges flip
            the response. Watching the colours change makes it easier to spot why a team turns, speeds up or slows down.
          </p>
          <p>
            The badge above the diagram lists which team owns the brain and which generation discovered it so you always know whose
            strategy you are following.
          </p>
        </div>
      </details>
    </div>

    <!-- Right panels: controls and teams -->
    <aside class="side" id="right-panel">
      <div class="panel" id="panel-global">
        <div class="panel-head"><div class="h">Global controls</div><span class="chev">▾</span></div>
        <div class="panel-body">
          <div class="grid">
            <div class="label">Fruit (max)</div>
            <input id="slFruits" type="range" min="2" max="1000" value="32"><div class="val" id="lbFruits">32</div>

            <div class="label" id="fruitPlacementLabel">Fruit placement</div>
            <div class="fruit-placement-options" role="group" aria-labelledby="fruitPlacementLabel">
              <label class="fruit-placement-option">
                <input type="checkbox" name="fruitPlacement" value="sw">
                <span>Bottom left</span>
              </label>
              <label class="fruit-placement-option">
                <input type="checkbox" name="fruitPlacement" value="se">
                <span>Bottom right</span>
              </label>
              <label class="fruit-placement-option">
                <input type="checkbox" name="fruitPlacement" value="ne">
                <span>Top right</span>
              </label>
              <label class="fruit-placement-option">
                <input type="checkbox" name="fruitPlacement" value="nw">
                <span>Top left</span>
              </label>
              <label class="fruit-placement-option">
                <input type="checkbox" name="fruitPlacement" value="random" checked>
                <span>Random</span>
              </label>
            </div>

            <div class="label">Spawn (ms)</div>
            <input id="slSpawn" type="range" min="120" max="15000" value="900"><div class="val" id="lbSpawn">900</div>

            <div class="label">Obstacles</div>
            <input id="slObst" type="range" min="0" max="40" value="0"><div class="val" id="lbObst">0</div>

            <div class="label">Trail length</div>
            <input id="slTail" type="range" min="4" max="1500" value="24"><div class="val" id="lbTail">24</div>

            <div class="label">Snake size</div>
            <input id="slAgentScale" type="range" min="50" max="150" value="100" step="5"><div class="val" id="lbAgentScale">1.00×</div>

            <div class="label">Agent collisions</div>
            <input id="chkAgentCollisions" type="checkbox"><div class="val" id="lbAgentCollisions">off</div>

            <div class="label">Top performer glow</div>
            <input id="chkTopHighlight" type="checkbox" checked><div class="val" id="lbTopHighlight">on</div>
          </div>
          <button id="btnReset" class="btn">Restart</button>
        </div>
      </div>

      <div class="panel" id="panel-teams">
        <div class="panel-head"><div class="h">Team settings</div><span class="chev">▾</span></div>
        <div class="panel-body">
          <div class="sub">Teams</div>
          <div class="team-roster" id="teamRoster"></div>
          <div class="sub" style="margin-top:14px">Attributes per team</div>
          <div class="team-configs" id="teamConfigs"></div>
        </div>
      </div>
    </aside>
  </div>
  </main>


<script>
// ===== Utils for UI =====
const Q = (id)=>document.getElementById(id);
function bindRange(sl, lb, fmt=(v)=>v){ const s=Q(sl), l=Q(lb); const apply=()=>{ l.textContent = fmt(+s.value); readParams(); }; s.addEventListener('input', apply); apply(); }

function setRangeValue(id, value){
  const el = Q(id);
  if(!el) return;
  const min = el.min !== undefined ? Number(el.min) : Number(value);
  const max = el.max !== undefined ? Number(el.max) : Number(value);
  const clamped = Math.min(max, Math.max(min, Number(value)));
  if(String(el.value) !== String(clamped)){
    el.value = clamped;
  }
  el.dispatchEvent(new Event('input', { bubbles:true }));
}

// === Make panels collapsible ===
(function makePanelsCollapsible(){
  const panels = document.querySelectorAll('.panel');
  panels.forEach((p)=>{
    const head = p.querySelector('.panel-head');
    if(!head) return;
    head.addEventListener('click', (e)=>{
      // Ignore clicks on inputs inside header (none for now)
      p.classList.toggle('collapsed');
    });
  });
})();

// ===== Colors =====
const COLORS = {
  fruit: '#ffd43b',
  goal:  '#3b82f6',
  goalFill: 'rgba(59,130,246,0.18)',
  fruitOutline:'#000'
};

const FRUIT_PLACEMENT_LABELS = {
  random: 'Random',
  nw: 'Top left',
  ne: 'Top right',
  sw: 'Bottom left',
  se: 'Bottom right'
};
const FRUIT_PLACEMENT_MODES = Object.keys(FRUIT_PLACEMENT_LABELS);

const TEAM_PRESETS = [
  { id:'green', label:'Greens', icon:'🟢', color:'#00ff91', outline:'#003322', badge:'#bbf7d0', goalAnchor:{ x:0.86, y:0.35 }, spawn:{ x:[0.06,0.46], y:[0.12,0.92] } },
  { id:'red', label:'Reds', icon:'🔴', color:'#ff0055', outline:'#5a001a', badge:'#fecdd3', goalAnchor:{ x:0.14, y:0.65 }, spawn:{ x:[0.54,0.94], y:[0.08,0.9] } },
  { id:'blocker', label:'Blockers', icon:'🛡️', color:'#a855f7', outline:'#581c87', badge:'#e9d5ff', role:'blocker', goalAnchor:{ x:0.48, y:0.50 }, spawn:{ x:[0.16,0.84], y:[0.18,0.82] } },
  { id:'blue', label:'Blues', icon:'🔵', color:'#60a5fa', outline:'#1e3a8a', badge:'#bfdbfe', goalAnchor:{ x:0.22, y:0.24 }, spawn:{ x:[0.18,0.52], y:[0.06,0.42] } },
  { id:'amber', label:'Ambers', icon:'🟠', color:'#f97316', outline:'#7c2d12', badge:'#fed7aa', goalAnchor:{ x:0.80, y:0.76 }, spawn:{ x:[0.52,0.90], y:[0.58,0.94] } }
];
const TEAM_PRESET_MAP = new Map(TEAM_PRESETS.map((preset)=> [preset.id, preset]));

const OBSTACLE_COLORS = ['#38bdf8', '#f472b6', '#2dd4bf'];

function clamp(value, min, max){
  return Math.max(min, Math.min(max, value));
}

const SPEED_FACTOR_MIN = 0.35;
const SPEED_FACTOR_MAX = 1.0;
const SPEED_FACTOR_ADJUST = 0.03;

function hexToRgba(hex, alpha){
  const h = hex.replace('#','');
  const bigint = parseInt(h,16);
  const r=(bigint>>16)&255;
  const g=(bigint>>8)&255;
  const b=bigint&255;
  return `rgba(${r},${g},${b},${alpha})`;
}

const canvas = document.getElementById('world');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

const brainCanvas = document.getElementById('brainVizCanvas');
const brainCtx = brainCanvas ? brainCanvas.getContext('2d') : null;
const brainSubtitleEl = Q('brain-subtitle');
const brainTeamEl = Q('brain-team');
const brainBadgeEl = Q('brain-badge');
const brainFitnessEl = Q('brain-fitness');
const brainGenEl = Q('brain-generation');
const brainToggleBtn = Q('brainToggleBtn');
const brainPausedEl = Q('brainPausedNotice');
const brainVizSection = document.querySelector('.brain-viz');
const brainTeamSelect = Q('brainTeamSelect');
let brainCanvasWidth = brainCanvas ? brainCanvas.clientWidth : 0;
let brainCanvasHeight = brainCanvas ? brainCanvas.clientHeight : 0;
let brainVizEnabled = true;
const AGENT_BASE_RADIUS = 5.2;
const AGENT_BASE_PICKUP_RADIUS = 9;
const AGENT_BASE_SEPARATION_RADIUS = 22;
const AGENT_OBSTACLE_THRESHOLD = 12;
const AGENT_BOUNDARY_PADDING = 10;
const AGENT_TRAIL_WIDTH = 2;

const TOOL_SELECT='select';
const TOOL_CIRCLE='circle';
const TOOL_RECT='rect';
const TOOL_LINE='line';
const TOOL_HALF='half';

let currentTool = TOOL_SELECT;
let drawingState = null;
let manualPaletteCursor = 0;
let dragRadius = 0;

// ===== Parameters =====
const params = {
  maxFruits: 32,
  spawnMs: 900,
  obstacles: 0,
  tailLen: 24,
  agentScale: 1.00,
  agentCollisions: false,
  showTopHighlight: true,
  fruitPlacement: 'random',
  teams: TEAM_PRESETS.map((preset, index)=>({
    id:preset.id,
    label:preset.label,
    icon:preset.icon,
    color:preset.color,
    outline:preset.outline,
    badge:preset.badge,
    role:preset.role || 'collector',
    goalAnchor:Object.assign({}, preset.goalAnchor),
    spawn:preset.spawn ? { x:preset.spawn.x.slice(), y:preset.spawn.y.slice() } : { x:[0.1,0.9], y:[0.1,0.9] },
    active:index < 2,
    count:28,
    speed:2.60,
    smart:1.80,
    strat:1.40,
    sep:1.10
  })),
  learn: { genSteps:2800, mut:0.16, elite:0.20, mutStrengthW:0.20, mutStrengthB:0.20, crossoverBias:0.50, tournamentFactor:2.0, fresh:0, auto:true }
};
let lastObstCount = params.obstacles;

// MP3 files from the audio folder
// Add your MP3 files here - just add the filename (they should be in an 'audio' folder next to this HTML file)
const MUSIC_TRACKS = [
  { filename: 'breath-of-enlightenment.mp3', title: 'breath-of-enlightenment.mp3', artist: 'Unknown Artist' },
  // Add more tracks here as needed
];

let currentTrackIndex = 0;
let isMusicPlaying = false;
let musicToggleBtn = null;
let audioElement = null;
let pendingVolume = 0.55;

// Initialize HTML5 Audio element
function initAudioElement(){
  if(!audioElement){
    audioElement = new Audio();
    audioElement.loop = true;
    audioElement.volume = pendingVolume;
    audioElement.addEventListener('ended', ()=>{
      isMusicPlaying = false;
      updateMusicMeta(MUSIC_TRACKS[currentTrackIndex], 'Ended');
      updateMusicButton();
    });
    audioElement.addEventListener('error', (e)=>{
      console.error('Audio playback error:', e);
      isMusicPlaying = false;
      updateMusicMeta(MUSIC_TRACKS[currentTrackIndex], 'Error loading track');
      updateMusicButton();
    });
    audioElement.addEventListener('canplay', ()=>{
      if(isMusicPlaying){
        updateMusicMeta(MUSIC_TRACKS[currentTrackIndex], 'Playing');
      }
    });
  }
  return audioElement;
}


function readParams(){
  params.maxFruits = +Q('slFruits').value; Q('lbFruits').textContent=params.maxFruits;
  params.spawnMs = +Q('slSpawn').value; Q('lbSpawn').textContent=params.spawnMs;
  params.obstacles = +Q('slObst').value; Q('lbObst').textContent=params.obstacles; if(params.obstacles !== lastObstCount){ makeObstacles(params.obstacles); lastObstCount = params.obstacles; }
  params.tailLen = +Q('slTail').value; Q('lbTail').textContent=params.tailLen;
  params.agentScale = (+Q('slAgentScale').value)/100; Q('lbAgentScale').textContent=`${params.agentScale.toFixed(2)}×`;
  const collisionToggle = Q('chkAgentCollisions');
  if(collisionToggle){
    params.agentCollisions = collisionToggle.checked;
    const label = Q('lbAgentCollisions');
    if(label){
      label.textContent = collisionToggle.checked ? 'on' : 'off';
    }
  }

  const topHighlightToggle = Q('chkTopHighlight');
  if(topHighlightToggle){
    params.showTopHighlight = topHighlightToggle.checked;
    const label = Q('lbTopHighlight');
    if(label){
      label.textContent = topHighlightToggle.checked ? 'on' : 'off';
    }
  }

  params.learn.genSteps = +Q('slGenSteps').value; Q('lbGenSteps').textContent=params.learn.genSteps;
  params.learn.mut = (+Q('slMut').value)/100; Q('lbMut').textContent=`${Math.round(params.learn.mut*100)}%`;
  params.learn.elite = (+Q('slElite').value)/100; Q('lbElite').textContent=`${Math.round(params.learn.elite*100)}%`;
  params.learn.mutStrengthW = (+Q('slMutStrengthW').value)/100; Q('lbMutStrengthW').textContent=params.learn.mutStrengthW.toFixed(2);
  params.learn.mutStrengthB = (+Q('slMutStrengthB').value)/100; Q('lbMutStrengthB').textContent=params.learn.mutStrengthB.toFixed(2);
  params.learn.crossoverBias = (+Q('slCrossover').value)/100; Q('lbCrossover').textContent = `${Math.round(params.learn.crossoverBias*100)}% A`;
  params.learn.tournamentFactor = (+Q('slTournament').value)/10; Q('lbTournament').textContent = `×${params.learn.tournamentFactor.toFixed(1)}`;
  params.learn.fresh = (+Q('slFresh').value)/100; Q('lbFresh').textContent = `${Math.round(params.learn.fresh*100)}%`;
  params.learn.auto = Q('chkAuto').checked; Q('lbAuto').textContent = params.learn.auto? 'on':'off';
  if(params.learn.auto && awaitingManualAdvance){
    forceNextGen = true;
  }
}
function updateMusicMeta(track, stateOverride=null){
  if(!track) return;
  const state = stateOverride || (isMusicPlaying ? 'Playing' : 'Paused');
  Q('lbMusicState').textContent = state;
  Q('lbMusicNow').textContent = `${track.title} — ${track.artist}`;
  Q('lbMusicSource').textContent = `File: audio/${track.filename}`;
}

let awaitingAudioUnlock = false;

function updateMusicButton(){
  if(!musicToggleBtn) return;
  musicToggleBtn.textContent = isMusicPlaying ? 'Pause' : 'Play';
  musicToggleBtn.setAttribute('aria-pressed', isMusicPlaying ? 'true' : 'false');
}

function stopCurrentTrack(silent=false){
  if(audioElement){
    audioElement.pause();
  }
  isMusicPlaying = false;
  if(!silent){
    updateMusicMeta(MUSIC_TRACKS[currentTrackIndex], 'Paused');
    updateMusicButton();
  }
}

async function playCurrentTrack(){
  const track = MUSIC_TRACKS[currentTrackIndex];
  try{
    const audio = initAudioElement();
    stopCurrentTrack(true);
    
    // Set the audio source to the MP3 file in the audio folder
    audio.src = `audio/${track.filename}`;
    audio.load();
    
    // Play the audio
    await audio.play();
    isMusicPlaying = true;
    
    updateMusicMeta(track, 'Playing');
    updateMusicButton();
  }catch(err){
    console.error('Playback error:', err);
    isMusicPlaying = false;
    updateMusicMeta(track, 'Error: ' + err.message);
    updateMusicButton();
    throw err;
  }
}

async function setMusicTrack(index, autoplay=false){
  if(index<0 || index>=MUSIC_TRACKS.length) return;
  const track = MUSIC_TRACKS[index];
  const shouldAutoplay = autoplay || isMusicPlaying;
  currentTrackIndex = index;

  stopCurrentTrack(true);
  updateMusicButton();
  updateMusicMeta(track, 'Loading…');

  try{
    const audio = initAudioElement();
    audio.src = `audio/${track.filename}`;
    
    if(shouldAutoplay){
      await playCurrentTrack();
    } else {
      isMusicPlaying = false;
      updateMusicMeta(track, 'Ready');
      updateMusicButton();
    }
  }catch(err){
    console.error('Track loading error:', err);
    updateMusicMeta(track, 'Error loading track');
  }
}

function initMusicPanel(){
  const select = Q('selMusic');
  musicToggleBtn = Q('btnMusicToggle');
  const vol = Q('slMusicVolume');
  const volLabel = Q('lbMusicVolume');

  MUSIC_TRACKS.forEach((track, idx)=>{
    const opt = document.createElement('option');
    opt.value = idx;
    opt.textContent = `${track.title} — ${track.artist}`;
    select.appendChild(opt);
  });
  select.value = String(currentTrackIndex);

  const applyVolume = ()=>{
    const value = Math.round(vol.value);
    pendingVolume = value/100;
    if(audioElement){
      audioElement.volume = pendingVolume;
    }
    volLabel.textContent = `${value}%`;
  };
  applyVolume();
  vol.addEventListener('input', applyVolume);

  musicToggleBtn.addEventListener('click', async ()=>{
    if(isMusicPlaying){
      stopCurrentTrack();
    } else {
      musicToggleBtn.disabled = true;
      try{
        await playCurrentTrack();
      }catch(err){
        // handled in playCurrentTrack
      }finally{
        musicToggleBtn.disabled = false;
      }
    }
  });

  select.addEventListener('change', ()=>{
    const idx = parseInt(select.value, 10);
    setMusicTrack(idx, isMusicPlaying);
  });

  updateMusicButton();
  setMusicTrack(currentTrackIndex, false);
}

// Procedural audio generation functions removed - now using MP3 files from audio folder

// ===== Data structures =====
const fruits=[], obstacles=[];
let activeTeamStates=[];
const goalStates = {};
const bestFitnessByTeam = {};
const teamScoreBook = new Map();
const teamScoreDisplays = new Map();

function updateFruitPlacementUI(mode){
  const options = document.querySelectorAll('.fruit-placement-options input[name="fruitPlacement"]');
  options.forEach((input)=>{
    const isActive = input.value === mode;
    if(input.checked !== isActive){
      input.checked = isActive;
    }
    const optionLabel = input.closest('.fruit-placement-option');
    if(optionLabel){
      optionLabel.classList.toggle('active', isActive);
      optionLabel.setAttribute('data-selected', isActive ? 'true' : 'false');
      const readable = FRUIT_PLACEMENT_LABELS[input.value] || input.value;
      optionLabel.setAttribute('title', readable);
    }
  });
  const placementLabel = Q('fruitPlacementLabel');
  if(placementLabel){
    placementLabel.setAttribute('data-selected', FRUIT_PLACEMENT_LABELS[mode] || mode);
  }
}

function regenerateFruitField(){
  const target = Math.max(0, Math.floor(params.maxFruits || 0));
  fruits.length = 0;
  for(let i=0;i<target;i++){
    spawnFruit();
  }
  refreshStats();
}

function setFruitPlacement(mode, fromUser=false){
  const normalized = FRUIT_PLACEMENT_MODES.includes(mode) ? mode : 'random';
  if(params.fruitPlacement === normalized && !fromUser){
    updateFruitPlacementUI(normalized);
    return;
  }
  params.fruitPlacement = normalized;
  updateFruitPlacementUI(normalized);
  if(fromUser){
    regenerateFruitField();
  }
}

function initFruitPlacementControls(){
  const options = Array.from(document.querySelectorAll('.fruit-placement-options input[name="fruitPlacement"]'));
  if(!options.length) return;
  options.forEach((input)=>{
    input.addEventListener('change', ()=>{
      if(input.checked){
        setFruitPlacement(input.value, true);
      }else if(params.fruitPlacement === input.value){
        setFruitPlacement(params.fruitPlacement, false);
      }
    });
  });
  setFruitPlacement(params.fruitPlacement || 'random', false);
}

const PICKUP_REWARD = 8;
const DELIVERY_REWARD = 120;
const BLOCKER_BLOCK_REWARD = 60;
const BLOCKER_BLOCK_PENALTY = 40;
const BLOCKER_EVENT_COOLDOWN = 55;
const BLOCKER_TRIGGER_RADIUS_BASE = 18;

function getTeamScoreData(teamId){
  if(!teamId) return { score:0, pickups:0, deliveries:0, blocks:0, fumbles:0 };
  let entry = teamScoreBook.get(teamId);
  if(!entry){
    entry = { score:0, pickups:0, deliveries:0, blocks:0, fumbles:0 };
    teamScoreBook.set(teamId, entry);
  }
  return entry;
}

function updateTeamScoreDisplay(teamId){
  const el = teamScoreDisplays.get(teamId);
  if(!el) return;
  const data = getTeamScoreData(teamId);
  const points = Math.round(data.score || 0);
  const metrics = [];
  metrics.push(`${data.pickups} caught`);
  metrics.push(`${data.deliveries} delivered`);
  metrics.push(`${data.blocks} blocked`);
  metrics.push(`${data.fumbles} fumbles`);
  el.textContent = `Points: ${points} (${metrics.join(' · ')})`;
}

function awardTeamPoints(teamState, type, amount){
  if(!teamState || !teamState.config) return;
  const scoreboard = teamState.scoreboard || getTeamScoreData(teamState.config.id);
  if(!scoreboard) return;
  if(type === 'pickup') scoreboard.pickups++;
  if(type === 'delivery') scoreboard.deliveries++;
  if(type === 'block') scoreboard.blocks++;
  const numeric = Number(amount);
  if(Number.isFinite(numeric)) scoreboard.score += numeric;
  teamState.scoreboard = scoreboard;
  updateTeamScoreDisplay(teamState.config.id);
}

function registerTeamFumble(teamState, penalty=0){
  if(!teamState || !teamState.config) return;
  const scoreboard = teamState.scoreboard || getTeamScoreData(teamState.config.id);
  scoreboard.fumbles = (scoreboard.fumbles || 0) + 1;
  if(Number.isFinite(penalty) && penalty !== 0){
    scoreboard.score += penalty;
  }
  teamState.scoreboard = scoreboard;
  updateTeamScoreDisplay(teamState.config.id);
}

// Pheromone grid – per-team fields
let grid, GW, GH, CS = 22; // cell size
function makeGrid(){
  GW=Math.floor(W/CS);
  GH=Math.floor(H/CS);
  grid={};
  params.teams.forEach((team)=>{
    grid[team.id] = {
      food:new Float32Array(GW*GH),
      home:new Float32Array(GW*GH)
    };
  });
}
const gi=(x,y)=> y*GW + x;
const clampi=(v,a,b)=> v<a?a:(v>b?b:v);
function deposit(teamId,type,x,y,amt){
  const fields = grid?.[teamId];
  if(!fields) return;
  const field = fields[type];
  if(!field) return;
  const cx=clampi((x/CS)|0,0,GW-1), cy=clampi((y/CS)|0,0,GH-1);
  field[gi(cx,cy)] += amt;
}
function senseGrad(teamId,type,x,y){
  const fields = grid?.[teamId];
  if(!fields) return { gx:0, gy:0, val:0 };
  const field = fields[type];
  if(!field) return { gx:0, gy:0, val:0 };
  const cx=clampi((x/CS)|0,0,GW-1), cy=clampi((y/CS)|0,0,GH-1);
  let best=-1e9,bx=cx,by=cy;
  for(let dy=-1;dy<=1;dy++){
    for(let dx=-1;dx<=1;dx++){
      const nx=clampi(cx+dx,0,GW-1), ny=clampi(cy+dy,0,GH-1);
      const v=field[gi(nx,ny)];
      if(v>best){best=v; bx=nx; by=ny;}
    }
  }
  return {gx:(bx-cx), gy:(by-cy), val:field[gi(bx,by)]};
}
function evaporate(){
  if(!grid) return;
  const keep=0.985;
  const next={};
  for(const [teamId, fields] of Object.entries(grid)){
    const dest={ food:new Float32Array(GW*GH), home:new Float32Array(GW*GH) };
    for(const key of ['food','home']){
      const src=fields[key];
      const dst=dest[key];
      for(let y=0;y<GH;y++){
        for(let x=0;x<GW;x++){
          let v=src[gi(x,y)]*keep;
          let sum=v*0.4;
          let cnt=0;
          for(let dy=-1;dy<=1;dy++){
            for(let dx=-1;dx<=1;dx++){
              if(dx||dy){
                const nx=clampi(x+dx,0,GW-1), ny=clampi(y+dy,0,GH-1);
                sum += src[gi(nx,ny)]*0.075;
                cnt++;
              }
            }
          }
          dst[gi(x,y)]= sum/(0.4+0.075*cnt);
        }
      }
    }
    next[teamId]=dest;
  }
  grid=next;
}

// Goals – draggable, one per potential team
const GOAL_RADIUS = 34;
function ensureGoalState(teamId){
  let goal = goalStates[teamId];
  if(!goal){
    const preset = TEAM_PRESET_MAP.get(teamId);
    const anchor = preset?.goalAnchor || { x:0.5, y:0.5 };
    goal = { id:teamId, x: anchor.x * W, y: anchor.y * H, r:GOAL_RADIUS, delivered:0 };
    goalStates[teamId] = goal;
  }
  return goal;
}
function resetGoalDelivery(teamId){
  const goal = ensureGoalState(teamId);
  goal.delivered = 0;
  return goal;
}
function getAllGoalStates(){
  return params.teams.map((team)=> ensureGoalState(team.id));
}
let dragTarget=null, dragDX=0, dragDY=0, dragKind=null, dragIndex=-1;

function renderTeamRoster(){
  const roster = Q('teamRoster');
  if(!roster) return;
  roster.innerHTML='';
  teamScoreDisplays.clear();
  params.teams.forEach((team)=>{
    const card=document.createElement('div');
    card.className='team-card';
    if(team.active) card.classList.add('active');
    card.dataset.teamId=team.id;

    const checkbox=document.createElement('input');
    checkbox.type='checkbox';
    checkbox.checked=!!team.active;
    checkbox.setAttribute('aria-label', `${team.label} team active`);

    const header=document.createElement('div');
    header.className='team-header';
    const badge=document.createElement('span');
    badge.className='team-badge';
    badge.textContent=team.icon || '●';
    if(team.badge){
      badge.style.background=team.badge;
      badge.style.color='#020617';
    }else{
      badge.style.background=team.color;
      badge.style.color='#fff';
    }
    const name=document.createElement('span');
    name.className='team-name';
    name.textContent=team.label;
    header.append(badge,name);

    const meta=document.createElement('div');
    meta.className='team-meta';
    const roleLabel = team.role === 'blocker' ? 'Blocker' : 'Collector';
    meta.textContent = `${team.active? 'Active':'Inactive'} · ${roleLabel}`;

    const score=document.createElement('div');
    score.className='team-score';
    score.textContent='Points: 0';
    teamScoreDisplays.set(team.id, score);
    updateTeamScoreDisplay(team.id);

    checkbox.addEventListener('change', ()=>{
      team.active = checkbox.checked;
      meta.textContent = `${team.active ? 'Active' : 'Inactive'} · ${roleLabel}`;
      card.classList.toggle('active', team.active);
      refreshBrainTeamOptions();
      renderTeamControls();
      setup();
    });

    card.append(checkbox, header, meta, score);
    roster.append(card);
  });
  refreshBrainTeamOptions();
  renderTeamControls();
}

function renderTeamControls(){
  const container = Q('teamConfigs');
  if(!container) return;
  container.innerHTML='';
  params.teams.forEach((team)=>{
    const card = document.createElement('div');
    card.className='team-config-card';
    if(!team.active) card.classList.add('inactive');

    const header = document.createElement('div');
    header.className='team-config-header';

    const title = document.createElement('div');
    title.className='team-config-title';
    const badge = document.createElement('span');
    badge.className='team-config-badge';
    badge.textContent = team.icon || '●';
    if(team.badge){
      badge.style.background = team.badge;
      badge.style.color = '#020617';
    }else{
      badge.style.background = team.color;
      badge.style.color = '#fff';
    }
    const name = document.createElement('span');
    name.textContent = team.label;
    title.append(badge, name);

    const status = document.createElement('div');
    status.className='team-config-status';
    status.textContent = team.active ? 'Active' : 'Inactive';

    header.append(title, status);
    card.append(header);

    const grid = document.createElement('div');
    grid.className='team-config-grid';

    const makeSlider = (labelText, key, options)=>{
      const label = document.createElement('div');
      label.className='label';
      label.textContent = labelText;

      const input = document.createElement('input');
      input.type='range';
      input.min = options.min;
      input.max = options.max;
      if(options.step != null) input.step = options.step;
      const sliderValue = options.toSlider ? options.toSlider(team[key]) : team[key];
      const clampedValue = Math.min(options.max, Math.max(options.min, sliderValue));
      input.value = String(clampedValue);
      if(clampedValue !== sliderValue){
        const coerced = options.fromSlider ? options.fromSlider(clampedValue) : clampedValue;
        team[key] = coerced;
      }

      const valueEl = document.createElement('div');
      valueEl.className='val';
      valueEl.textContent = options.format(team[key]);

      if(options.tooltip){
        label.title = options.tooltip;
        input.title = options.tooltip;
        valueEl.title = options.tooltip;
      }

      input.addEventListener('input', ()=>{
        const numeric = options.fromSlider ? options.fromSlider(+input.value) : +input.value;
        team[key] = numeric;
        valueEl.textContent = options.format(numeric);
        if(typeof options.onChange === 'function') options.onChange(numeric);
      });

      grid.append(label, input, valueEl);
    };

    makeSlider('Count', 'count', {
      min:2,
      max:200,
      format:(v)=> Math.round(v),
      onChange:()=> resizePop(),
      tooltip:'How many agents this team spawns onto the field.'
    });
    makeSlider('Speed', 'speed', {
      min:10,
      max:600,
      step:5,
      toSlider:(v)=> Math.round(v*100),
      fromSlider:(v)=> (v/100),
      format:(v)=> v.toFixed(2),
      tooltip:'Base movement speed multiplier applied to the team.'
    });
    makeSlider('Awareness', 'smart', {
      min:0,
      max:300,
      toSlider:(v)=> Math.round(v*100),
      fromSlider:(v)=> (v/100),
      format:(v)=> v.toFixed(2),
      tooltip:'How far agents sense fruit, teammates, and obstacles.'
    });
    makeSlider('Strategy', 'strat', {
      min:0,
      max:300,
      toSlider:(v)=> Math.round(v*100),
      fromSlider:(v)=> (v/100),
      format:(v)=> v.toFixed(2),
      tooltip:'Balance between chasing goals and wandering for this team.'
    });
    makeSlider('Separation', 'sep', {
      min:0,
      max:300,
      toSlider:(v)=> Math.round(v*100),
      fromSlider:(v)=> (v/100),
      format:(v)=> v.toFixed(2),
      tooltip:'How strongly agents steer away from crowding teammates.'
    });

    card.append(grid);
    container.append(card);
  });
}

function refreshStats(){
  const genEl = Q('stat-gen');
  if(genEl) genEl.textContent = evo.gen;
  const teamEl = Q('stat-teams');
  if(teamEl) teamEl.textContent = activeTeamStates.length;
  const fruitEl = Q('stat-fruits');
  if(fruitEl) fruitEl.textContent = fruits.length;
  let deliveries = 0;
  let topFitness = 0;
  for(const team of activeTeamStates){
    deliveries += team.goal?.delivered || 0;
    topFitness = Math.max(topFitness, team.peakFitness||0, team.bestFitnessCurrent||0);
  }
  const deliveryEl = Q('stat-deliveries');
  if(deliveryEl) deliveryEl.textContent = deliveries;
  const topEl = Q('stat-top');
  if(topEl) topEl.textContent = Math.round(topFitness);
}

function getCanvasCoords(evt){
  const rect = canvas.getBoundingClientRect();
  return {
    x: evt.clientX - rect.left,
    y: evt.clientY - rect.top
  };
}

function obstacleHitTest(o, px, py, tolerance=8){
  switch(o.type){
    case 'rect':{
      const halfW = o.width/2 + tolerance;
      const halfH = o.height/2 + tolerance;
      return Math.abs(px - o.x) <= halfW && Math.abs(py - o.y) <= halfH;
    }
    case 'line':{
      const t = distanceToSegment(px, py, o.x1, o.y1, o.x2, o.y2);
      const radius = (o.thickness||12)/2 + tolerance;
      return t.distance <= radius;
    }
    case 'half':{
      const dx = px - o.x;
      const dy = py - o.y;
      const radius = o.r + tolerance;
      const dist = Math.hypot(dx, dy);
      if(dist > radius) return false;
      const facingX = Math.cos(o.angle);
      const facingY = Math.sin(o.angle);
      const proj = dx*facingX + dy*facingY;
      if(proj >= -tolerance) return true;
      const perpX = -facingY;
      const perpY = facingX;
      const ax = o.x - perpX * o.r;
      const ay = o.y - perpY * o.r;
      const bx = o.x + perpX * o.r;
      const by = o.y + perpY * o.r;
      const seg = distanceToSegment(px, py, ax, ay, bx, by);
      return seg.distance <= tolerance;
    }
    default:{
      const r = typeof o.r === 'number' ? o.r : Math.max(16, (o.hitRadius||20));
      return Math.hypot(px - o.x, py - o.y) <= r + tolerance;
    }
  }
}

function getObstacleRadius(o){
  switch(o.type){
    case 'rect':
      return Math.hypot(o.width, o.height) * 0.5;
    case 'line':{
      const halfLen = Math.hypot(o.x2 - o.x1, o.y2 - o.y1) * 0.5;
      return halfLen + (o.thickness||12)/2;
    }
    case 'half':
      return o.r;
    default:
      return o.r || 24;
  }
}

function getObstacleExtents(o){
  switch(o.type){
    case 'rect':
      return { hx:o.width/2, hy:o.height/2 };
    case 'line':{
      const halfWidth = (o.thickness||12)/2;
      const halfDx = Math.abs(o.x2 - o.x1)/2;
      const halfDy = Math.abs(o.y2 - o.y1)/2;
      return { hx:halfDx + halfWidth, hy:halfDy + halfWidth };
    }
    case 'half':
      return { hx:o.r, hy:o.r };
    default:
      const r = o.r || 20;
      return { hx:r, hy:r };
  }
}

function moveObstacleTo(o, nx, ny){
  const dx = nx - o.x;
  const dy = ny - o.y;
  o.x = nx;
  o.y = ny;
  if(o.type === 'line'){
    o.x1 += dx; o.y1 += dy;
    o.x2 += dx; o.y2 += dy;
  }
}

function computeObstacleDragOffset(o, pointerX, pointerY){
  if(!o) return { dx:0, dy:0 };
  switch(o.type){
    case 'circle':
    case 'half':
      return { dx:0, dy:0 };
    default:
      return { dx:o.x - pointerX, dy:o.y - pointerY };
  }
}

function distanceToSegment(px, py, x1, y1, x2, y2){
  const vx = x2 - x1;
  const vy = y2 - y1;
  const lenSq = vx*vx + vy*vy;
  let t = 0;
  if(lenSq > 0){
    t = ((px - x1)*vx + (py - y1)*vy) / lenSq;
    t = Math.max(0, Math.min(1, t));
  }
  const cx = x1 + vx*t;
  const cy = y1 + vy*t;
  const dx = px - cx;
  const dy = py - cy;
  const dist = Math.hypot(dx, dy);
  const inv = dist>0 ? 1/dist : 0;
  return { distance:dist, cx, cy, nx:dx*inv, ny:dy*inv };
}

function clampObstacleCenter(o, cx, cy){
  const ext = getObstacleExtents(o);
  const hx = ext.hx || 0;
  const hy = ext.hy || 0;
  const minX = hx + 4;
  const maxX = W - hx - 4;
  const minY = hy + 4;
  const maxY = H - hy - 4;
  return {
    x: Math.max(minX, Math.min(maxX, cx)),
    y: Math.max(minY, Math.min(maxY, cy))
  };
}

function keepObstacleInside(o){
  const clamped = clampObstacleCenter(o, o.x, o.y);
  moveObstacleTo(o, clamped.x, clamped.y);
}

function buildObstacleFromState(state, preview=false){
  if(!state) return null;
  const { tool, startX, startY, currentX, currentY } = state;
  const dx = currentX - startX;
  const dy = currentY - startY;
  switch(tool){
    case TOOL_CIRCLE:{
      const radius = Math.hypot(dx, dy);
      if(!preview && radius < 12) return null;
      if(preview && radius < 2) return null;
      return { type:'circle', x:startX, y:startY, r: Math.max(radius, preview?radius:12) };
    }
    case TOOL_RECT:{
      const width = Math.abs(dx);
      const height = Math.abs(dy);
      if(!preview && (width < 16 || height < 16)) return null;
      if(preview && (width < 2 && height < 2)) return null;
      const cx = (startX + currentX) / 2;
      const cy = (startY + currentY) / 2;
      return { type:'rect', x:cx, y:cy, width: Math.max(width, preview?width:16), height: Math.max(height, preview?height:16) };
    }
    case TOOL_LINE:{
      const length = Math.hypot(dx, dy);
      if(!preview && length < 24) return null;
      if(preview && length < 4) return null;
      const cx = (startX + currentX) / 2;
      const cy = (startY + currentY) / 2;
      return {
        type:'line',
        x:cx,
        y:cy,
        x1:startX,
        y1:startY,
        x2:currentX,
        y2:currentY,
        thickness:14
      };
    }
    case TOOL_HALF:{
      const radius = Math.hypot(dx, dy);
      if(!preview && radius < 18) return null;
      if(preview && radius < 4) return null;
      const angle = Math.atan2(dy, dx);
      return { type:'half', x:startX, y:startY, r: Math.max(radius, preview?radius:18), angle };
    }
    default:
      return null;
  }
}

function createCircleObstacle(x, y, r, paletteIndex=0, manual=false){
  return { type:'circle', x, y, r, paletteIndex, phase:Math.random()*Math.PI*2, manual };
}

function getManualObstacleCount(){
  let count = 0;
  for(const obstacle of obstacles){
    if(obstacle.manual) count++;
  }
  return count;
}

function syncManualObstacleState(){
  const manualCount = getManualObstacleCount();
  manualPaletteCursor = manualCount % OBSTACLE_COLORS.length;
  if(btnUndoManual){
    btnUndoManual.disabled = manualCount === 0;
  }
}

canvas.addEventListener('mousedown', (e)=>{
  const {x, y} = getCanvasCoords(e);
  if(currentTool !== TOOL_SELECT){
    drawingState = { tool:currentTool, startX:x, startY:y, currentX:x, currentY:y };
    return;
  }
  dragTarget=null; dragKind=null; dragIndex=-1; dragRadius=0;
  for(let i=obstacles.length-1; i>=0; i--){
    const o=obstacles[i];
    if(obstacleHitTest(o, x, y)){
      const offset = computeObstacleDragOffset(o, x, y);
      dragTarget = o;
      dragKind = 'obst';
      dragIndex = i;
      dragDX = offset.dx;
      dragDY = offset.dy;
      dragRadius = getObstacleRadius(o);
      return;
    }
  }
  for(const goal of getAllGoalStates()){
    if(Math.hypot(x-goal.x,y-goal.y) <= goal.r+12){
      dragTarget=goal;
      dragKind=`goal:${goal.id}`;
      dragDX=goal.x-x;
      dragDY=goal.y-y;
      return;
    }
  }
});

window.addEventListener('mousemove', (e)=>{
  const {x, y} = getCanvasCoords(e);
  if(drawingState){
    drawingState.currentX = x;
    drawingState.currentY = y;
  }
  if(!dragTarget) return;
  if(dragKind==='obst'){
    const desiredX = x + dragDX;
    const desiredY = y + dragDY;
    const clamped = clampObstacleCenter(dragTarget, desiredX, desiredY);
    if(!obstacleOverlaps(clamped.x, clamped.y, dragRadius, dragIndex)){
      moveObstacleTo(dragTarget, clamped.x, clamped.y);
    }
  } else {
    const nx = Math.max(dragTarget.r+8, Math.min(W - dragTarget.r - 8, x + dragDX));
    const ny = Math.max(dragTarget.r+8, Math.min(H - dragTarget.r - 8, y + dragDY));
    dragTarget.x = nx;
    dragTarget.y = ny;
  }
});

window.addEventListener('mouseup', ()=>{
  if(drawingState){
    const created = buildObstacleFromState(drawingState);
    if(created){
      const paletteIndex = manualPaletteCursor % OBSTACLE_COLORS.length;
      created.manual = true;
      created.paletteIndex = paletteIndex;
      created.phase = Math.random()*Math.PI*2;
      manualPaletteCursor = (manualPaletteCursor + 1) % OBSTACLE_COLORS.length;
      keepObstacleInside(created);
      obstacles.push(created);
      syncManualObstacleState();
    }
    drawingState = null;
  }
  dragTarget=null; dragKind=null; dragIndex=-1; dragRadius=0;
});

// Utils
function rand(a,b){ return a + Math.random()*(b-a); }
function nearest(arr,x,y){ if(!arr.length) return null; let best=arr[0],bd=1e9; for(const o of arr){ const d=Math.hypot(o.x-x,o.y-y); if(d<bd){bd=d; best=o;} } return best; }
const OBSTACLE_PADDING = 12;
function obstacleOverlaps(x,y,r, ignoreIndex=-1){
  for(let i=0;i<obstacles.length;i++){
    if(i===ignoreIndex) continue;
    const o=obstacles[i];
    const otherR = getObstacleRadius(o);
    if(Math.hypot(x-o.x,y-o.y) < r + otherR + OBSTACLE_PADDING) return true;
  }
  return false;
}

function isPointInsideObstacle(o, x, y, padding=0){
  switch(o.type){
    case 'rect':{
      const halfW = o.width/2 + padding;
      const halfH = o.height/2 + padding;
      return Math.abs(x - o.x) <= halfW && Math.abs(y - o.y) <= halfH;
    }
    case 'line':{
      const seg = distanceToSegment(x, y, o.x1, o.y1, o.x2, o.y2);
      const radius = (o.thickness||14)/2 + padding;
      return seg.distance <= radius;
    }
    case 'half':{
      const dx = x - o.x;
      const dy = y - o.y;
      const radius = o.r + padding;
      const dist = Math.hypot(dx, dy);
      if(dist <= radius){
        const facingX = Math.cos(o.angle);
        const facingY = Math.sin(o.angle);
        const proj = dx*facingX + dy*facingY;
        if(proj >= -padding) return true;
      }
      const perpX = -Math.sin(o.angle);
      const perpY = Math.cos(o.angle);
      const ax = o.x - perpX * o.r;
      const ay = o.y - perpY * o.r;
      const bx = o.x + perpX * o.r;
      const by = o.y + perpY * o.r;
      const seg = distanceToSegment(x, y, ax, ay, bx, by);
      return seg.distance <= padding;
    }
    default:
      return Math.hypot(x-o.x,y-o.y) <= (o.r || getObstacleRadius(o)) + padding;
  }
}

function pointInsideObstacle(x,y){
  for(const o of obstacles){
    if(isPointInsideObstacle(o, x, y, 7)) return true;
  }
  return false;
}

function obstacleClearance(o, px, py){
  const margin = 8;
  switch(o.type){
    case 'rect':{
      const halfW = o.width/2 + margin;
      const halfH = o.height/2 + margin;
      const dx = px - o.x;
      const dy = py - o.y;
      const ax = Math.abs(dx) - halfW;
      const ay = Math.abs(dy) - halfH;
      if(ax <= 0 && ay <= 0){
        if(ax > ay){
          const nx = Math.sign(dx) || 1;
          return { distance: ax, nx, ny:0 };
        } else {
          const ny = Math.sign(dy) || 1;
          return { distance: ay, nx:0, ny };
        }
      }
      const outsideX = Math.max(ax, 0);
      const outsideY = Math.max(ay, 0);
      const dist = Math.hypot(outsideX, outsideY);
      let nx = 0, ny = 0;
      if(dist > 0){
        nx = outsideX ? (outsideX/dist) * Math.sign(dx || 1) : 0;
        ny = outsideY ? (outsideY/dist) * Math.sign(dy || 1) : 0;
      } else {
        if(ax > 0) nx = Math.sign(dx) || 1;
        if(ay > 0) ny = Math.sign(dy) || 1;
      }
      return { distance: dist, nx, ny };
    }
    case 'line':{
      const seg = distanceToSegment(px, py, o.x1, o.y1, o.x2, o.y2);
      const radius = (o.thickness||14)/2 + margin;
      let nx = seg.nx;
      let ny = seg.ny;
      if(seg.distance === 0){
        const vx = o.x2 - o.x1;
        const vy = o.y2 - o.y1;
        const len = Math.hypot(vx, vy) || 1;
        nx = -vy / len;
        ny = vx / len;
        const midX = (o.x1 + o.x2) / 2;
        const midY = (o.y1 + o.y2) / 2;
        if((px - midX)*nx + (py - midY)*ny < 0){
          nx = -nx;
          ny = -ny;
        }
      }
      return { distance: seg.distance - radius, nx, ny };
    }
    case 'half':{
      const dx = px - o.x;
      const dy = py - o.y;
      const facingX = Math.cos(o.angle);
      const facingY = Math.sin(o.angle);
      const proj = dx*facingX + dy*facingY;
      if(proj >= 0){
        const dist = Math.hypot(dx, dy);
        const radius = o.r + margin;
        const inv = dist>0 ? 1/dist : 0;
        const nx = inv>0 ? dx*inv : facingX;
        const ny = inv>0 ? dy*inv : facingY;
        return { distance: dist - radius, nx, ny };
      }
      const perpX = -Math.sin(o.angle);
      const perpY = Math.cos(o.angle);
      const ax = o.x - perpX * o.r;
      const ay = o.y - perpY * o.r;
      const bx = o.x + perpX * o.r;
      const by = o.y + perpY * o.r;
      const seg = distanceToSegment(px, py, ax, ay, bx, by);
      let nx = seg.nx;
      let ny = seg.ny;
      if(seg.distance === 0){
        nx = facingX;
        ny = facingY;
      }
      return { distance: seg.distance - margin, nx, ny };
    }
    default:{
      const dx = px - o.x;
      const dy = py - o.y;
      const dist = Math.hypot(dx, dy);
      const radius = (o.r || getObstacleRadius(o)) + margin;
      const inv = dist>0 ? 1/dist : 0;
      const nx = inv>0 ? dx*inv : 1;
      const ny = inv>0 ? dy*inv : 0;
      return { distance: dist - radius, nx, ny };
    }
  }
}
function getFruitSpawnArea(){
  const mode = params.fruitPlacement;
  if(!mode || mode === 'random') return null;
  const margin = 48;
  const spanX = Math.max(170, Math.min(280, W - margin*2));
  const spanY = Math.max(150, Math.min(240, H - margin*2));
  let minX = margin;
  let minY = margin;
  switch(mode){
    case 'ne':
      minX = Math.max(margin, W - margin - spanX);
      break;
    case 'se':
      minX = Math.max(margin, W - margin - spanX);
      minY = Math.max(margin, H - margin - spanY);
      break;
    case 'sw':
      minY = Math.max(margin, H - margin - spanY);
      break;
    case 'nw':
      // already top-left
      break;
    default:
      return null;
  }
  const maxX = Math.min(W - margin, minX + spanX);
  const maxY = Math.min(H - margin, minY + spanY);
  return {
    minX,
    maxX,
    minY,
    maxY
  };
}

function normalizeFruitArea(area){
  if(!area) return null;
  const minX = Math.max(40, Math.min(area.minX, W - 40));
  const maxX = Math.min(area.maxX, W - 40);
  const minY = Math.max(40, Math.min(area.minY, H - 40));
  const maxY = Math.min(area.maxY, H - 40);
  if(!Number.isFinite(minX) || !Number.isFinite(maxX) || maxX - minX < 20) return null;
  if(!Number.isFinite(minY) || !Number.isFinite(maxY) || maxY - minY < 20) return null;
  return { minX, maxX, minY, maxY };
}

function selectFruitClusterCenter(area, clusterRadius, fallbackX, fallbackY){
  const keepouts = getAllGoalStates()
    .map((goal)=> ({ x: goal.x, y: goal.y, r: goal.r + 10 }))
    .filter((keep)=> (
      keep.x >= area.minX - keep.r && keep.x <= area.maxX + keep.r &&
      keep.y >= area.minY - keep.r && keep.y <= area.maxY + keep.r
    ));
  if(keepouts.length === 0){
    return { x: fallbackX, y: fallbackY };
  }

  const padX = Math.min(clusterRadius * 0.75, (area.maxX - area.minX) * 0.5);
  const padY = Math.min(clusterRadius * 0.75, (area.maxY - area.minY) * 0.5);
  let clampMinX = area.minX + padX;
  let clampMaxX = area.maxX - padX;
  let clampMinY = area.minY + padY;
  let clampMaxY = area.maxY - padY;
  if(clampMinX > clampMaxX){
    const mid = (area.minX + area.maxX) / 2;
    clampMinX = clampMaxX = mid;
  }
  if(clampMinY > clampMaxY){
    const mid = (area.minY + area.maxY) / 2;
    clampMinY = clampMaxY = mid;
  }

  const candidates = [];
  const addCandidate = (x, y)=>{
    const cx = clamp(x, clampMinX, clampMaxX);
    const cy = clamp(y, clampMinY, clampMaxY);
    candidates.push({ x: cx, y: cy });
  };

  addCandidate(fallbackX, fallbackY);
  addCandidate(area.minX + padX, area.minY + padY);
  addCandidate(area.maxX - padX, area.minY + padY);
  addCandidate(area.maxX - padX, area.maxY - padY);
  addCandidate(area.minX + padX, area.maxY - padY);
  for(const keep of keepouts){
    const angle = Math.atan2(fallbackY - keep.y, fallbackX - keep.x);
    const targetDist = keep.r + Math.min(clusterRadius * 0.6, 32);
    addCandidate(keep.x - Math.cos(angle || 0) * targetDist, keep.y - Math.sin(angle || 0) * targetDist);
  }

  let best = { x: clamp(fallbackX, clampMinX, clampMaxX), y: clamp(fallbackY, clampMinY, clampMaxY) };
  let bestScore = -Infinity;
  for(const candidate of candidates){
    let minClear = Infinity;
    for(const keep of keepouts){
      const clearance = Math.hypot(candidate.x - keep.x, candidate.y - keep.y) - keep.r;
      if(clearance < minClear) minClear = clearance;
    }
    if(minClear > bestScore){
      bestScore = minClear;
      best = candidate;
    }
  }
  return best;
}

function findFreeFruitSpot(maxTry=80, preferredArea=null){
  const area = normalizeFruitArea(preferredArea);
  const trySampler = (sampler)=>{
    for(let i=0;i<maxTry;i++){
      const { x, y } = sampler();
      if(goalTooClose(x,y,6,16)) continue;
      if(pointInsideObstacle(x,y)) continue;
      return { x, y };
    }
    return null;
  };
  if(area){
    const midX = (area.minX + area.maxX) / 2;
    const midY = (area.minY + area.maxY) / 2;
    const spanX = Math.max(20, (area.maxX - area.minX));
    const spanY = Math.max(20, (area.maxY - area.minY));
    const baseRadius = Math.min(spanX, spanY) * 0.45;
    const clusterRadius = clamp(baseRadius, 32, Math.min(spanX, spanY) * 0.5);
    const jitterLimit = Math.min(8, clusterRadius * 0.28);
    const clusterCenter = selectFruitClusterCenter(area, clusterRadius, midX, midY);
    const clusterSampler = ()=>{
      const angle = Math.random() * TAU;
      const radius = Math.sqrt(Math.random()) * clusterRadius;
      const orbitX = clusterCenter.x + Math.cos(angle) * radius;
      const orbitY = clusterCenter.y + Math.sin(angle) * radius;
      const jitterX = clamp(randn() * jitterLimit, -jitterLimit, jitterLimit);
      const jitterY = clamp(randn() * jitterLimit, -jitterLimit, jitterLimit);
      return {
        x: clamp(orbitX + jitterX, area.minX, area.maxX),
        y: clamp(orbitY + jitterY, area.minY, area.maxY)
      };
    };
    const clusterSpot = trySampler(clusterSampler);
    if(clusterSpot) return clusterSpot;
  }
  return trySampler(()=> ({ x: rand(40, W-40), y: rand(40, H-40) }));
}

function spawnFruit(x=null,y=null){
  if(fruits.length>=params.maxFruits) return;
  if(x==null||y==null){
    const pos = findFreeFruitSpot(120, getFruitSpawnArea());
    if(!pos) return;
    x=pos.x;
    y=pos.y;
  }
  if(pointInsideObstacle(x,y)){
    const pos = findFreeFruitSpot(80, getFruitSpawnArea()) || findFreeFruitSpot();
    if(!pos) return;
    x=pos.x;
    y=pos.y;
  }
  fruits.push({x,y,r:6,color:COLORS.fruit});
}
function goalTooClose(x,y,r,padding=40){
  for(const goal of getAllGoalStates()){
    if(Math.hypot(x-goal.x,y-goal.y) < goal.r + r + padding) return true;
  }
  return false;
}
function makeObstacles(n){
  const manual = obstacles.filter(o=>o.manual);
  obstacles.length = 0;
  for(const m of manual){
    obstacles.push(m);
  }
  const paletteLen=OBSTACLE_COLORS.length;
  for(let i=0;i<n;i++){
    let r=rand(16,40);
    let placed=false;
    for(let tries=0; tries<420 && !placed; tries++){
      if(tries===240) r=Math.max(12,r*0.85);
      if(tries===360) r=Math.max(10,r*0.85);
      const x=rand(80,W-80);
      const y=rand(60,H-60);
      if(goalTooClose(x,y,r,40)) continue;
      if(obstacleOverlaps(x,y,r)) continue;
      obstacles.push(createCircleObstacle(x,y,r,i%paletteLen,false));
      placed=true;
    }
    if(!placed){
      const step=36;
      outer: for(let gy=60; gy<=H-60 && !placed; gy+=step){
        for(let gx=80; gx<=W-80; gx+=step){
          if(goalTooClose(gx,gy,r,40)) continue;
          if(obstacleOverlaps(gx,gy,r)) continue;
          obstacles.push(createCircleObstacle(gx,gy,r,i%paletteLen,false));
          placed=true;
          break outer;
        }
      }
    }
    if(!placed){
      const fallback = obstacles[obstacles.length-1] || {x:W*0.5,y:H*0.5,r:20};
      let angle=Math.random()*TAU;
      let dist=getObstacleRadius(fallback) + r + OBSTACLE_PADDING + 4;
      for(let steps=0; steps<60 && !placed; steps++){
        const x=Math.max(r+4, Math.min(W-r-4, fallback.x + Math.cos(angle)*dist));
        const y=Math.max(r+4, Math.min(H-r-4, fallback.y + Math.sin(angle)*dist));
        if(obstacleOverlaps(x,y,r)){
          dist += r*0.35 + OBSTACLE_PADDING;
          angle += 0.4;
          continue;
        }
        obstacles.push(createCircleObstacle(x,y,r,i%paletteLen,false));
        placed=true;
      }
    }
    if(!placed){
      const smallR = Math.max(10, r*0.8);
      for(let tries=0; tries<240 && !placed; tries++){
        const x=rand(80,W-80);
        const y=rand(60,H-60);
        if(goalTooClose(x,y,smallR,32)) continue;
        if(obstacleOverlaps(x,y,smallR)) continue;
        obstacles.push(createCircleObstacle(x,y,smallR,i%paletteLen,false));
        placed=true;
      }
    }
  }
}



const NET_INPUTS = 7;
const NET_HIDDEN = 16;
const NET_OUTPUTS = 4;
const OUTPUT_NODE_LABELS = ['Drive X', 'Drive Y', 'Speed +', 'Speed −'];

// ===== NEAT‑lite (7→16→4) =====
function randn(){ let u=0,v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random(); return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v); }
function matmulVec(W, x, out){ const rows=W.length, cols=W[0].length; for(let i=0;i<rows;i++){ let s=0; const Wi=W[i]; for(let j=0;j<cols;j++) s+=Wi[j]*x[j]; out[i]=s; } return out; }
function tanhVec(v){ for(let i=0;i<v.length;i++) v[i]=Math.tanh(v[i]); return v; }
function addBias(v,b){ for(let i=0;i<v.length;i++) v[i]+=b[i]; return v; }
function ensureArraySize(arr, length){ return (Array.isArray(arr) && arr.length===length) ? arr : new Array(length); }
function ensureNetOutputSize(net, desired=NET_OUTPUTS){
  if(!net) return net;
  const hiddenDim = Array.isArray(net.W1) ? net.W1.length : (Array.isArray(net.W2?.[0]) ? net.W2[0].length : NET_HIDDEN);
  if(!Array.isArray(net.W2)) net.W2 = [];
  if(!Array.isArray(net.b2)) net.b2 = [];
  for(let i=0;i<net.W2.length;i++){
    const row = Array.isArray(net.W2[i]) ? net.W2[i].slice() : [];
    if(row.length !== hiddenDim){
      net.W2[i] = Array.from({length:hiddenDim}, (_v, idx)=> (idx<row.length && Number.isFinite(row[idx])) ? row[idx] : (Math.random()*2-1)*0.5);
    } else {
      net.W2[i] = row;
    }
  }
  while(net.W2.length < desired){
    net.W2.push(Array.from({length:hiddenDim}, ()=> (Math.random()*2-1)*0.5));
  }
  while(net.b2.length < desired){
    net.b2.push((Math.random()*2-1)*0.2);
  }
  if(net.W2.length > desired) net.W2.length = desired;
  if(net.b2.length > desired) net.b2.length = desired;
  return net;
}

function makeNet(inDim=NET_INPUTS,h=NET_HIDDEN,out=NET_OUTPUTS){
  const net = {
    W1:Array.from({length:h},()=>Array.from({length:inDim},()=> (Math.random()*2-1)*0.5)),
    b1:Array.from({length:h},()=> (Math.random()*2-1)*0.2),
    W2:Array.from({length:out},()=>Array.from({length:h},()=> (Math.random()*2-1)*0.5)),
    b2:Array.from({length:out},()=> (Math.random()*2-1)*0.2)
  };
  return ensureNetOutputSize(net, out);
}
function cloneNet(n){
  const cloned = {
    W1:n.W1.map(r=>r.slice()),
    b1:n.b1.slice(),
    W2:n.W2.map(r=>r.slice()),
    b2:n.b2.slice()
  };
  return ensureNetOutputSize(cloned);
}
function mutateNet(n, rate){
  const sW = params.learn?.mutStrengthW ?? 0.2;
  const sB = params.learn?.mutStrengthB ?? 0.2;
  for(const r of n.W1){
    for(let i=0;i<r.length;i++){
      if(Math.random()<rate) r[i]+=randn()*sW;
    }
  }
  for(let i=0;i<n.b1.length;i++){
    if(Math.random()<rate) n.b1[i]+=randn()*sB;
  }
  for(const r of n.W2){
    for(let i=0;i<r.length;i++){
      if(Math.random()<rate) r[i]+=randn()*sW;
    }
  }
  for(let i=0;i<n.b2.length;i++){
    if(Math.random()<rate) n.b2[i]+=randn()*sB;
  }
}
function crossover(a,b){
  const bias = params.learn?.crossoverBias ?? 0.5;
  const c = cloneNet(a);
  const pick = ()=> (Math.random()<bias);
  for(let i=0;i<c.W1.length;i++){
    for(let j=0;j<c.W1[0].length;j++){
      c.W1[i][j] = pick() ? a.W1[i][j] : b.W1[i][j];
    }
  }
  for(let i=0;i<c.b1.length;i++){
    c.b1[i] = pick() ? a.b1[i] : b.b1[i];
  }
  for(let i=0;i<c.W2.length;i++){
    for(let j=0;j<c.W2[0].length;j++){
      c.W2[i][j] = pick() ? a.W2[i][j] : b.W2[i][j];
    }
  }
  for(let i=0;i<c.b2.length;i++){
    c.b2[i] = pick() ? a.b2[i] : b.b2[i];
  }
  return c;
}
function forward(n, x, capture=null){
  ensureNetOutputSize(n);
  const hidden = capture ? ensureArraySize(capture.hidden, n.b1.length) : new Array(n.b1.length);
  const output = capture ? ensureArraySize(capture.output, n.b2.length) : new Array(n.b2.length);
  matmulVec(n.W1,x,hidden);
  addBias(hidden,n.b1);
  tanhVec(hidden);
  matmulVec(n.W2,hidden,output);
  addBias(output,n.b2);
  tanhVec(output);
  if(capture){
    capture.hidden = hidden;
    capture.output = output;
    const inputStore = ensureArraySize(capture.input, x.length);
    for(let i=0;i<x.length;i++) inputStore[i] = x[i];
    capture.input = inputStore;
  }
  return output;
}
function makePopulation(size){ return Array.from({length:size}, ()=> ({ net:makeNet(), fitness:0 })); }
const evo = { gen:1, populations:{} };

function createEmptyBrainState(gen){
  return {
    fitness:-Infinity,
    teamId:null,
    teamLabel:'',
    teamIcon:'',
    teamColor:'#38bdf8',
    gen:Number.isFinite(gen) ? gen : (evo?.gen || 1),
    net:null,
    agentRef:null,
    activations:{ input:[], hidden:[], output:[], timestamp:0 }
  };
}
const bestBrainState = createEmptyBrainState(evo.gen);
const globalBrainChampion = createEmptyBrainState(evo.gen);
const teamBrainCache = new Map();
let brainViewMode = 'auto';
let brainViewTeamId = null;
let bestBrainDirty = true;

function markBestBrainDirty(){
  bestBrainDirty = true;
}
function clearActivationStore(store){
  if(!store) return;
  store.input.length = 0;
  store.hidden.length = 0;
  store.output.length = 0;
  store.timestamp = 0;
}

function resetBrainState(state, gen){
  if(!state) return;
  state.fitness = -Infinity;
  state.teamId = null;
  state.teamLabel = '';
  state.teamIcon = '';
  state.teamColor = '#38bdf8';
  state.gen = Number.isFinite(gen) ? gen : (evo?.gen || 1);
  state.net = null;
  state.agentRef = null;
  if(!state.activations){
    state.activations = { input:[], hidden:[], output:[], timestamp:0 };
  } else {
    clearActivationStore(state.activations);
  }
}

function ensureTeamBrainCache(teamId){
  if(!teamId) return null;
  let cache = teamBrainCache.get(teamId);
  if(!cache){
    cache = createEmptyBrainState(evo.gen);
    cache.teamId = teamId;
    const team = params?.teams?.find?.((t)=>t.id===teamId);
    if(team){
      cache.teamLabel = team.label || team.id || '';
      cache.teamIcon = team.icon || '●';
      cache.teamColor = team.color || '#38bdf8';
    }
    teamBrainCache.set(teamId, cache);
  }
  return cache;
}

function applyBrainSelection(value){
  const mode = value && value !== 'auto' ? 'team' : 'auto';
  if(mode === 'auto'){
    brainViewMode = 'auto';
    brainViewTeamId = null;
    if(globalBrainChampion.net){
      const teamConfig = {
        id: globalBrainChampion.teamId,
        label: globalBrainChampion.teamLabel,
        icon: globalBrainChampion.teamIcon,
        color: globalBrainChampion.teamColor
      };
      setBestBrainFromNet(globalBrainChampion.net, teamConfig, globalBrainChampion.fitness, globalBrainChampion.gen, globalBrainChampion.agentRef, bestBrainState, globalBrainChampion.activations);
    } else {
      resetBrainState(bestBrainState, evo.gen);
      markBestBrainDirty();
    }
    updateBrainMeta();
    return;
  }

  const team = params.teams.find((t)=>t.id===value);
  if(!team || !team.active){
    brainViewMode = 'auto';
    brainViewTeamId = null;
    if(brainTeamSelect){
      brainTeamSelect.value = 'auto';
    }
    applyBrainSelection('auto');
    return;
  }

  brainViewMode = 'team';
  brainViewTeamId = team.id;
  const cache = ensureTeamBrainCache(team.id);
  if(cache && cache.net){
    setBestBrainFromNet(cache.net, team, cache.fitness, cache.gen, cache.agentRef, bestBrainState, cache.activations);
  } else {
    resetBrainState(bestBrainState, evo.gen);
    bestBrainState.teamId = team.id;
    bestBrainState.teamLabel = team.label || team.id || '';
    bestBrainState.teamIcon = team.icon || '●';
    bestBrainState.teamColor = team.color || '#38bdf8';
    markBestBrainDirty();
  }
  updateBrainMeta();
}

function refreshBrainTeamOptions(){
  if(!brainTeamSelect) return;
  const previous = brainTeamSelect.value;
  brainTeamSelect.innerHTML = '';
  const autoOption = document.createElement('option');
  autoOption.value = 'auto';
  autoOption.textContent = 'Auto — top performer';
  brainTeamSelect.append(autoOption);
  params.teams.forEach((team)=>{
    const option = document.createElement('option');
    option.value = team.id;
    option.textContent = `${team.icon || '●'} ${team.label}`.trim();
    if(!team.active) option.disabled = true;
    brainTeamSelect.append(option);
  });
  let next = previous;
  const candidate = next ? brainTeamSelect.querySelector(`option[value="${next}"]`) : null;
  if(!candidate || candidate.disabled){
    next = 'auto';
  }
  brainTeamSelect.value = next;
  applyBrainSelection(next);
}
function applyBrainVizState(){
  const enabled = !!brainVizEnabled;
  if(brainCanvas){
    if(enabled){
      brainCanvas.removeAttribute('hidden');
    } else {
      brainCanvas.setAttribute('hidden','');
    }
  }
  if(brainPausedEl){
    brainPausedEl.hidden = enabled;
  }
  if(brainVizSection){
    brainVizSection.classList.toggle('brain-viz--hidden', !enabled);
  }
  if(brainToggleBtn){
    brainToggleBtn.textContent = enabled ? 'Hide visualization' : 'Show visualization';
    brainToggleBtn.setAttribute('aria-pressed', enabled ? 'true' : 'false');
    brainToggleBtn.setAttribute('title', enabled
      ? 'Hide the neural network visualization to save performance'
      : 'Show the neural network visualization');
  }
  markBestBrainDirty();
  updateBrainMeta();
  if(enabled){
    renderBestBrain();
  } else if(brainCtx && brainCanvas){
    brainCtx.clearRect(0, 0, brainCanvas.width || 0, brainCanvas.height || 0);
  }
}
if(brainToggleBtn){
  brainToggleBtn.addEventListener('click', ()=>{
    brainVizEnabled = !brainVizEnabled;
    applyBrainVizState();
  });
}
if(brainTeamSelect){
  brainTeamSelect.addEventListener('change', ()=>{
    applyBrainSelection(brainTeamSelect.value);
  });
}
applyBrainVizState();
function resetBestBrainState(gen){
  resetBrainState(bestBrainState, gen);
  resetBrainState(globalBrainChampion, gen);
  teamBrainCache.clear();
  brainViewMode = 'auto';
  brainViewTeamId = null;
  if(brainTeamSelect){
    brainTeamSelect.value = 'auto';
  }
  markBestBrainDirty();
  updateBrainMeta();
}
function ensureBrainCanvasSizing(){
  if(!brainCanvas || !brainCtx) return;
  const rect = brainCanvas.getBoundingClientRect();
  if(rect.width && rect.height){
    brainCanvasWidth = rect.width;
    brainCanvasHeight = rect.height;
    const dpr = window.devicePixelRatio || 1;
    const deviceWidth = Math.max(1, Math.round(rect.width * dpr));
    const deviceHeight = Math.max(1, Math.round(rect.height * dpr));
    if(brainCanvas.width !== deviceWidth || brainCanvas.height !== deviceHeight){
      brainCanvas.width = deviceWidth;
      brainCanvas.height = deviceHeight;
    }
    brainCtx.setTransform(1,0,0,1,0,0);
    brainCtx.scale(dpr, dpr);
  } else {
    brainCanvasWidth = brainCanvasWidth || brainCanvas.width || 560;
    brainCanvasHeight = brainCanvasHeight || brainCanvas.height || 240;
  }
}
function updateBrainMeta(){
  if(brainSubtitleEl){
    const watchingTeam = brainViewMode === 'team';
    if(!brainVizEnabled){
      if(bestBrainState.net){
        brainSubtitleEl.textContent = watchingTeam
          ? 'View paused — team numbers still refresh in the background.'
          : 'View paused — leader numbers still update in real time.';
      } else {
        brainSubtitleEl.textContent = watchingTeam
          ? 'View hidden until this team finds its first leader.'
          : 'View hidden until a leader shows up.';
      }
    } else if(bestBrainState.net){
      if(bestBrainState.agentRef){
        const throttlePercent = typeof bestBrainState.agentRef.getThrottlePercent === 'function'
          ? bestBrainState.agentRef.getThrottlePercent()
          : (Number.isFinite(bestBrainState.agentRef?.speedFactor)
            ? Math.round(bestBrainState.agentRef.speedFactor * 100)
            : 100);
        const prefix = watchingTeam ? 'Team focus' : 'Top contender';
        brainSubtitleEl.textContent = `${prefix} — cyan links boost the signal, pink links reverse it — throttle at ${throttlePercent}% of max`;
      } else {
        brainSubtitleEl.textContent = watchingTeam
          ? 'Saved brain for this team — Speed ± outputs adjust the throttle.'
          : 'Saved best network — Speed ± outputs adjust the throttle.';
      }
    } else {
      brainSubtitleEl.textContent = watchingTeam
        ? 'This team has not produced a leader yet.'
        : 'The first winning brain will appear here soon.';
    }
  }
  if(brainTeamEl){
    if(bestBrainState.net){
      brainTeamEl.textContent = `${bestBrainState.teamIcon || '●'} ${bestBrainState.teamLabel || 'Team'}`.trim();
      brainTeamEl.style.color = bestBrainState.agentRef ? 'var(--ink)' : 'var(--muted)';
    } else {
      if(brainViewMode === 'team' && bestBrainState.teamLabel){
        brainTeamEl.textContent = `${bestBrainState.teamIcon || '●'} ${bestBrainState.teamLabel}`.trim();
      } else {
        brainTeamEl.textContent = 'No leader yet';
      }
      brainTeamEl.style.color = 'var(--muted)';
    }
  }
  if(brainBadgeEl){
    if(bestBrainState.net){
      brainBadgeEl.textContent = bestBrainState.teamIcon || '●';
      const badgeAlpha = bestBrainState.agentRef ? 0.82 : 0.5;
      const glowAlpha = bestBrainState.agentRef ? 0.45 : 0.22;
      brainBadgeEl.style.background = hexToRgba(bestBrainState.teamColor || '#38bdf8', badgeAlpha);
      brainBadgeEl.style.boxShadow = `0 0 18px ${hexToRgba(bestBrainState.teamColor || '#38bdf8', glowAlpha)}`;
      brainBadgeEl.style.color = '#020617';
    } else {
      const fallbackIcon = bestBrainState.teamIcon || '●';
      brainBadgeEl.textContent = fallbackIcon;
      const fallbackColor = bestBrainState.teamColor || '#38bdf8';
      brainBadgeEl.style.background = hexToRgba(fallbackColor, 0.35);
      brainBadgeEl.style.boxShadow = 'none';
      brainBadgeEl.style.color = '#94a3b8';
    }
  }
  if(brainFitnessEl){ brainFitnessEl.textContent = bestBrainState.net ? Math.round(bestBrainState.fitness).toString() : '—'; }
  if(brainGenEl){ brainGenEl.textContent = bestBrainState.net ? `Gen ${bestBrainState.gen}` : 'Gen —'; }
}
function drawBrainPlaceholder(width,height){
  if(!brainCtx) return;
  brainCtx.save();
  const inset = 22;
  const gridWidth = Math.max(0, width - inset*2);
  const gridHeight = Math.max(0, height - inset*2);
  brainCtx.translate(inset, inset);
  brainCtx.strokeStyle = 'rgba(148,163,209,0.22)';
  brainCtx.lineWidth = 1.1;
  const rows = 4, cols = 5;
  for(let i=0;i<=rows;i++){
    const y = (gridHeight/rows)*i;
    brainCtx.beginPath();
    brainCtx.moveTo(0, y);
    brainCtx.lineTo(gridWidth, y);
    brainCtx.stroke();
  }
  for(let j=0;j<=cols;j++){
    const x = (gridWidth/cols)*j;
    brainCtx.beginPath();
    brainCtx.moveTo(x, 0);
    brainCtx.lineTo(x, gridHeight);
    brainCtx.stroke();
  }
  brainCtx.fillStyle = 'rgba(148,163,209,0.68)';
  brainCtx.font = '600 16px "Inter", system-ui, -apple-system, sans-serif';
  brainCtx.textAlign = 'center';
  brainCtx.textBaseline = 'middle';
  brainCtx.fillText('Simulation warming up…', gridWidth/2, gridHeight/2);
  brainCtx.restore();
}
function buildLayerPositions(count, x, top, bottom){
  if(count<=0) return [];
  const positions=[];
  const span = Math.max(0, bottom - top);
  if(count===1){
    positions.push({ x, y: top + span/2 });
    return positions;
  }
  const step = span/(count-1);
  for(let i=0;i<count;i++) positions.push({ x, y: top + step*i });
  return positions;
}
function maxAbsWeight(weights){
  let max=0;
  if(!Array.isArray(weights)) return max;
  for(const row of weights){
    if(!Array.isArray(row)) continue;
    for(const val of row){
      const mag = Math.abs(val);
      if(mag>max) max=mag;
    }
  }
  return max;
}
function drawBrainConnections(fromLayer, toLayer, weights, fromActivations=null, toActivations=null, activityScale=1){
  if(!brainCtx || !fromLayer || !toLayer || !weights) return;
  const maxW = maxAbsWeight(weights) || 1;
  const positiveColor = bestBrainState.teamColor || '#2dd4bf';
  for(let j=0;j<Math.min(toLayer.length, weights.length);j++){
    const row = weights[j];
    const target = toLayer[j];
    const targetAct = Array.isArray(toActivations) ? toActivations[j] : null;
    if(!target || !Array.isArray(row)) continue;
    for(let i=0;i<Math.min(fromLayer.length, row.length);i++){
      const source = fromLayer[i];
      if(!source) continue;
      const weight = row[i];
      if(!Number.isFinite(weight)) continue;
      const sourceAct = Array.isArray(fromActivations) ? fromActivations[i] : null;
      const activity = Math.max(0, Math.min(1, (typeof sourceAct === 'number' ? Math.abs(sourceAct) : 0)));
      const targetActivity = Math.max(0, Math.min(1, (typeof targetAct === 'number' ? Math.abs(targetAct) : 0)));
      const combinedActivity = Math.min(1, (activity*0.7 + targetActivity*0.5) * activityScale);
      const strength = Math.min(1, Math.abs(weight)/maxW);
      const alpha = 0.10 + strength*0.35 + combinedActivity*0.45;
      const width = 0.55 + strength*2.0 + combinedActivity*1.4;
      const colorHex = weight>=0 ? positiveColor : '#f472b6';
      brainCtx.beginPath();
      brainCtx.moveTo(source.x, source.y);
      brainCtx.lineTo(target.x, target.y);
      brainCtx.strokeStyle = hexToRgba(colorHex, alpha);
      brainCtx.lineWidth = width;
      if(combinedActivity>0.02){
        brainCtx.shadowColor = hexToRgba(colorHex, 0.35*combinedActivity + 0.15*strength);
        brainCtx.shadowBlur = 6 + combinedActivity*14;
      }else{
        brainCtx.shadowColor = 'transparent';
        brainCtx.shadowBlur = 0;
      }
      brainCtx.stroke();
    }
  }
  brainCtx.shadowBlur = 0;
  brainCtx.shadowColor = 'transparent';
}
function drawBrainNodes(positions, type, activations=null, activityScale=1){
  if(!brainCtx || !positions) return;
  brainCtx.save();
  const teamColor = bestBrainState.teamColor || '#2dd4bf';
  for(let i=0;i<positions.length;i++){
    const pos = positions[i];
    const value = Array.isArray(activations) ? activations[i] : null;
    const magnitude = Math.max(0, Math.min(1, (typeof value === 'number' ? Math.abs(value) : 0) * activityScale));
    const sign = (typeof value === 'number' && value < 0) ? -1 : 1;
    let radius = 8.5;
    let baseColor = '#38bdf8';
    let accentColor = '#38bdf8';
    let negativeColor = '#f472b6';
    if(type==='hidden'){
      radius = 7;
      baseColor = teamColor;
      accentColor = teamColor;
    }
    if(type==='output'){
      radius = 9.5;
      baseColor = '#f472b6';
      accentColor = '#f472b6';
      negativeColor = '#38bdf8';
    }
    const color = sign >= 0 ? baseColor : negativeColor;
    const strokeColor = sign >= 0 ? accentColor : negativeColor;
    const fillAlpha = 0.18 + magnitude*0.55;
    const strokeAlpha = 0.50 + magnitude*0.45;
    brainCtx.beginPath();
    brainCtx.fillStyle = hexToRgba(color, fillAlpha);
    brainCtx.strokeStyle = hexToRgba(strokeColor, strokeAlpha);
    brainCtx.lineWidth = 1.8;
    if(magnitude>0.02){
      brainCtx.shadowColor = hexToRgba(strokeColor, 0.45*magnitude + 0.18);
      brainCtx.shadowBlur = 8 + magnitude*18;
    } else {
      brainCtx.shadowColor = 'transparent';
      brainCtx.shadowBlur = 0;
    }
    brainCtx.arc(pos.x, pos.y, radius, 0, Math.PI*2);
    brainCtx.fill();
    brainCtx.stroke();
    brainCtx.beginPath();
    brainCtx.shadowBlur = 0;
    brainCtx.shadowColor = 'transparent';
    brainCtx.strokeStyle = 'rgba(255,255,255,0.12)';
    brainCtx.lineWidth = 1;
    brainCtx.arc(pos.x, pos.y, Math.max(1, radius-2.6), 0, Math.PI*2);
    brainCtx.stroke();
  }
  brainCtx.restore();
}
function renderBestBrain(){
  updateBrainMeta();
  if(!brainVizEnabled || !brainCanvas || !brainCtx){
    bestBrainDirty = false;
    return;
  }
  ensureBrainCanvasSizing();
  const width = brainCanvasWidth || brainCanvas.width || 560;
  const height = brainCanvasHeight || brainCanvas.height || 240;
  brainCtx.clearRect(0,0,width,height);
  const net = bestBrainState.net;
  if(!net || !Array.isArray(net.W1) || !Array.isArray(net.W2)){
    drawBrainPlaceholder(width,height);
    bestBrainDirty = false;
    return;
  }
  const inputCount = Array.isArray(net.W1?.[0]) ? net.W1[0].length : 0;
  const hiddenCount = net.W1.length;
  const outputCount = net.W2.length;
  if(!inputCount || !hiddenCount || !outputCount){
    drawBrainPlaceholder(width,height);
    bestBrainDirty = false;
    return;
  }
  const paddingX = Math.min(80, width*0.18);
  const paddingY = Math.min(40, height*0.22);
  const columnSpacing = (width - paddingX*2) / 2;
  const inputLayer = buildLayerPositions(inputCount, paddingX, paddingY, height - paddingY);
  const hiddenLayer = buildLayerPositions(hiddenCount, paddingX + columnSpacing, paddingY, height - paddingY);
  const outputLayer = buildLayerPositions(outputCount, paddingX + columnSpacing*2, paddingY, height - paddingY);
  const activations = bestBrainState.activations || null;
  const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
  let activityScale = 0.25;
  if(bestBrainState.agentRef && activations && Number.isFinite(activations.timestamp)){
    const ageMs = Math.max(0, now - activations.timestamp);
    const freshness = Math.max(0, 1 - Math.min(1, ageMs / 1600));
    activityScale = 0.25 + freshness*0.75;
  } else if(activations && Number.isFinite(activations.timestamp)){
    activityScale = 0.18;
  }
  brainCtx.save();
  brainCtx.lineCap='round';
  brainCtx.lineJoin='round';
  drawBrainConnections(inputLayer, hiddenLayer, net.W1, activations?.input, activations?.hidden, activityScale);
  drawBrainConnections(hiddenLayer, outputLayer, net.W2, activations?.hidden, activations?.output, activityScale);
  brainCtx.restore();
  drawBrainNodes(inputLayer, 'input', activations?.input, activityScale);
  drawBrainNodes(hiddenLayer, 'hidden', activations?.hidden, activityScale);
  drawBrainNodes(outputLayer, 'output', activations?.output, activityScale);
  if(outputLayer.length){
    brainCtx.save();
    brainCtx.font = '600 10px "Inter", system-ui, -apple-system, sans-serif';
    brainCtx.textAlign = 'center';
    brainCtx.textBaseline = 'bottom';
    for(let i=0;i<outputLayer.length;i++){
      const node = outputLayer[i];
      const label = OUTPUT_NODE_LABELS[i] || `Out ${i+1}`;
      brainCtx.fillStyle = 'rgba(148,163,209,0.72)';
      brainCtx.fillText(label, node.x, node.y - 16);
    }
    brainCtx.restore();
  }
  if(activations?.output && outputLayer.length === activations.output.length){
    brainCtx.save();
    brainCtx.font = '600 11px "Inter", system-ui, -apple-system, sans-serif';
    brainCtx.textAlign = 'center';
    brainCtx.textBaseline = 'top';
    for(let i=0;i<outputLayer.length;i++){
      const node = outputLayer[i];
      const value = activations.output[i];
      if(!Number.isFinite(value)) continue;
      const label = value.toFixed(2);
      brainCtx.fillStyle = value >= 0 ? 'rgba(248,250,255,0.78)' : 'rgba(148,163,209,0.78)';
      brainCtx.fillText(label, node.x, node.y + 12);
    }
    brainCtx.restore();
  }
  bestBrainDirty = false;
}
function setBestBrainFromNet(net, teamConfig, fitness, generation, agentRef=null, targetState=bestBrainState, activationsOverride=null){
  if(!targetState) return;
  if(!net || !teamConfig){
    resetBrainState(targetState, generation);
    return;
  }
  targetState.fitness = fitness;
  targetState.teamId = teamConfig.id;
  targetState.teamLabel = teamConfig.label || teamConfig.id || '';
  targetState.teamIcon = teamConfig.icon || '●';
  targetState.teamColor = teamConfig.color || '#38bdf8';
  targetState.gen = Number.isFinite(generation) ? generation : evo.gen;
  targetState.net = cloneNet(net);
  targetState.agentRef = agentRef || null;
  const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
  if(activationsOverride){
    targetState.activations = activationsOverride;
    if(typeof targetState.activations.timestamp !== 'number'){
      targetState.activations.timestamp = now;
    }
  } else if(agentRef && agentRef.activationScratch){
    targetState.activations = agentRef.activationScratch;
    targetState.activations.timestamp = now;
  } else {
    targetState.activations = targetState.activations || { input:[], hidden:[], output:[], timestamp: now };
    if(!Array.isArray(targetState.activations.input)) targetState.activations.input = [];
    if(!Array.isArray(targetState.activations.hidden)) targetState.activations.hidden = [];
    if(!Array.isArray(targetState.activations.output)) targetState.activations.output = [];
    targetState.activations.timestamp = now;
  }
  if(targetState === bestBrainState){
    markBestBrainDirty();
  }
}
function trackBestBrain(agent, teamState){
  if(!agent || !teamState) return;
  const fitness = Number(agent.fitness);
  if(!Number.isFinite(fitness)) return;
  const net = agent.netRef?.net;
  if(!net) return;
  const teamId = teamState.config.id;
  const cache = ensureTeamBrainCache(teamId);
  if(cache){
    if(fitness > cache.fitness){
      setBestBrainFromNet(net, teamState.config, fitness, evo.gen, agent, cache);
      if(brainViewMode === 'team' && brainViewTeamId === teamId){
        setBestBrainFromNet(net, teamState.config, fitness, evo.gen, agent, bestBrainState, cache.activations);
      }
    } else if(cache.agentRef === agent && agent.activationScratch){
      cache.activations = agent.activationScratch;
    }
  }
  if(fitness > globalBrainChampion.fitness){
    setBestBrainFromNet(net, teamState.config, fitness, evo.gen, agent, globalBrainChampion);
    if(brainViewMode === 'auto'){
      setBestBrainFromNet(net, teamState.config, fitness, evo.gen, agent, bestBrainState, globalBrainChampion.activations);
    }
  } else if(globalBrainChampion.teamId === teamId && globalBrainChampion.agentRef === agent && agent.activationScratch){
    globalBrainChampion.activations = agent.activationScratch;
  }
}
params.teams.forEach((team)=>{
  evo.populations[team.id] = makePopulation(team.count);
});
resetBestBrainState(evo.gen);
function getPopulation(teamId){
  if(!evo.populations[teamId]){
    const team = params.teams.find((t)=>t.id===teamId);
    const size = team ? Math.max(0, team.count) : 0;
    evo.populations[teamId] = makePopulation(size);
  }
  return evo.populations[teamId];
}
function resizePop(){
  params.teams.forEach((team)=>{
    const pop = getPopulation(team.id);
    if(pop.length < team.count){
      while(pop.length < team.count) pop.push({ net:makeNet(), fitness:0 });
    } else if(pop.length > team.count){
      pop.length = team.count;
    }
  });
}
function evolveTeam(teamState){
  const pop = getPopulation(teamState.config.id);
  if(!pop.length) return;
  pop.sort((a,b)=> b.fitness - a.fitness);
  const eliteN=Math.max(1, Math.floor(pop.length*params.learn.elite));
  const elites=pop.slice(0,eliteN).map((e)=> cloneNet(e.net));
  const best=pop[0]?.fitness||0;
  teamState.bestFitnessCurrent = best;
  teamState.peakFitness = Math.max(teamState.peakFitness||0, best);
  bestFitnessByTeam[teamState.config.id] = teamState.peakFitness;
  const tournamentFactor = Math.max(1, params.learn.tournamentFactor || 1);
  const freshRatio = clamp(params.learn.fresh || 0, 0, 1);
  const newPop=[];
  for(let i=0;i<eliteN;i++) newPop.push({ net:cloneNet(elites[i]), fitness:0 });
  function pick(){
    const k=Math.min(pop.length, Math.max(2, Math.round(eliteN * tournamentFactor)));
    const a=pop[Math.floor(Math.random()*k)];
    const b=pop[Math.floor(Math.random()*k)];
    return (a.fitness>b.fitness?a:b).net;
  }
  while(newPop.length<pop.length){
    const pa=pick(), pb=pick();
    let child=crossover(pa,pb);
    mutateNet(child, params.learn.mut);
    newPop.push({ net:child, fitness:0 });
  }
  const freshCount = Math.min(pop.length - eliteN, Math.max(0, Math.round(pop.length * freshRatio)));
  for(let i=0;i<freshCount;i++){
    newPop[newPop.length-1-i] = { net:makeNet(), fitness:0 };
  }
  for(let i=0;i<pop.length;i++){
    pop[i].net=newPop[i].net;
    pop[i].fitness=0;
  }
}

// ===== Agent core =====
class Agent{
  constructor(x,y,color,maxSpeed,team){ this.x=x; this.y=y; this.vx=rand(-1,1); this.vy=rand(-1,1); this.color=color; this.baseSpeed=maxSpeed; this.speedFactor=1; this.minSpeedFactor=SPEED_FACTOR_MIN; this.maxSpeedFactor=SPEED_FACTOR_MAX; this.maxSpeed=maxSpeed; this.trail=[]; this.carry=false; this.team=team; this.side=Math.random()<0.5?-1:1; this.stuckT=0; this.wander={x:rand(-1,1), y:rand(-1,1)}; this.activationScratch={ input:[], hidden:[], output:[], timestamp:0 }; this.blockCooldown=0; }
  stepSpeed(v){ this.baseSpeed=v; this.maxSpeed=this.baseSpeed*this.speedFactor; }
  setSpeedFactor(factor){ this.speedFactor=clamp(factor, this.minSpeedFactor, this.maxSpeedFactor); this.maxSpeed=this.baseSpeed*this.speedFactor; }
  adjustSpeedFactor(delta){ if(!Number.isFinite(delta) || delta===0) return; this.setSpeedFactor(this.speedFactor + delta); }
  getThrottlePercent(){ return Math.round(this.speedFactor * 100); }
  steerSeparation(peers, radius=18, gain=0.12){
    let sx=0,sy=0;
    const limit = radius * params.agentScale;
    for(const p of peers){
      if(p===this) continue;
      const dx=this.x-p.x, dy=this.y-p.y;
      const d=Math.hypot(dx,dy);
      if(d>0 && d<limit){ sx+=dx/(d*d); sy+=dy/(d*d); }
    }
    this.vx+=sx*gain;
    this.vy+=sy*gain;
  }
  applyWander(str=0.055, damp=0.92){ this.wander.x=this.wander.x*damp+(Math.random()*2-1)*(1-damp); this.wander.y=this.wander.y*damp+(Math.random()*2-1)*(1-damp); const wn=Math.hypot(this.wander.x,this.wander.y)||1; this.vx+=(this.wander.x/wn)*str; this.vy+=(this.wander.y/wn)*str; }
  avoidObstacles(){
    for(const o of obstacles){
      const clearance = obstacleClearance(o, this.x, this.y);
      if(!clearance) continue;
      const threshold = AGENT_OBSTACLE_THRESHOLD * params.agentScale;
      if(clearance.distance < threshold){
        const push = (threshold - clearance.distance) * 0.055;
        const nx = Number.isFinite(clearance.nx) ? clearance.nx : 0;
        const ny = Number.isFinite(clearance.ny) ? clearance.ny : 0;
        this.vx += nx * push;
        this.vy += ny * push;
      }
    }
  }
  resolveObstaclePenetration(maxIter=4){
    for(let iter=0; iter<maxIter; iter++){
      let adjusted=false;
      for(const o of obstacles){
        const clearance = obstacleClearance(o, this.x, this.y);
        if(!clearance) continue;
        if(clearance.distance < 0){
          let nx = Number.isFinite(clearance.nx) ? clearance.nx : 0;
          let ny = Number.isFinite(clearance.ny) ? clearance.ny : 0;
          const mag = Math.hypot(nx, ny) || 1;
          nx /= mag;
          ny /= mag;
          const push = (-clearance.distance) + 0.5;
          this.x += nx * push;
          this.y += ny * push;
          const vn = this.vx*nx + this.vy*ny;
          if(vn < 0){
            this.vx -= vn * nx;
            this.vy -= vn * ny;
          }
          adjusted = true;
        }
      }
      if(!adjusted) break;
    }
  }
  keepInBounds(){
    const pad = AGENT_BOUNDARY_PADDING * params.agentScale;
    if(this.x<pad){ this.x=pad; this.vx=Math.abs(this.vx); }
    if(this.x>W-pad){ this.x=W-pad; this.vx=-Math.abs(this.vx); }
    if(this.y<pad){ this.y=pad; this.vy=Math.abs(this.vy); }
    if(this.y>H-pad){ this.y=H-pad; this.vy=-Math.abs(this.vy); }
  }
  tickCooldowns(){ if(this.blockCooldown>0) this.blockCooldown--; }
  integrate(){ const sp=Math.hypot(this.vx,this.vy); if(sp>this.maxSpeed){ this.vx*=this.maxSpeed/sp; this.vy*=this.maxSpeed/sp; } this.trail.push({x:this.x,y:this.y}); if(this.trail.length>params.tailLen) this.trail.shift(); this.x+=this.vx; this.y+=this.vy; this.resolveObstaclePenetration(); this.keepInBounds(); this.resolveObstaclePenetration(1); this.stuckT=(sp<0.10)?(this.stuckT+1):0; this.tickCooldowns(); }
}

class Collector extends Agent{
  constructor(x,y,teamState,netRef){
    const cfg=teamState.config;
    super(x,y,teamState.config.color,cfg.speed,teamState.config.id);
    this.teamState=teamState;
    this.netRef=netRef;
    if(this.netRef && this.netRef.net){
      ensureNetOutputSize(this.netRef.net);
    }
    this.fitness=0;
    this.role='collector';
  }
  update(){
    const cfg=this.teamState.config;
    const teamId=cfg.id;
    this.stepSpeed(cfg.speed);
    const myGoal=this.teamState.goal;
    const tgt = this.carry? myGoal : nearest(fruits, this.x, this.y);
    let tx=0,ty=0, dn=1;
    if(tgt){ tx=tgt.x-this.x; ty=tgt.y-this.y; dn=Math.hypot(tx,ty)||1; tx/=dn; ty/=dn; }
    const g = senseGrad(teamId, this.carry? 'home':'food', this.x, this.y);
    const mates = this.teamState.agents;
    let sx=0, sy=0;
    const separationRadius = AGENT_BASE_SEPARATION_RADIUS * params.agentScale;
    for(const p of mates){
      if(p===this) continue;
      const dx=this.x-p.x, dy=this.y-p.y;
      const d=Math.hypot(dx,dy);
      if(d>0 && d<separationRadius){ sx+=dx/(d*d); sy+=dy/(d*d); }
    }
    const input = [tx,ty, g.gx, g.gy, sx, sy, 1.0];
    const capture = this.activationScratch;
    const out = forward(this.netRef.net, input, capture);
    const nowTime = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
    capture.timestamp = nowTime;
    if(bestBrainState.agentRef === this){
      bestBrainState.activations = capture;
      if(brainVizEnabled){
        markBestBrainDirty();
      }
    }
    const driveX = Number.isFinite(out[0]) ? out[0] : 0;
    const driveY = Number.isFinite(out[1]) ? out[1] : 0;
    const accelerate = Number.isFinite(out[2]) ? out[2] : 0;
    const brake = Number.isFinite(out[3]) ? out[3] : 0;
    const throttleSignal = accelerate - brake;
    if(throttleSignal !== 0){
      this.adjustSpeedFactor(throttleSignal * SPEED_FACTOR_ADJUST);
    }
    this.vx += driveX*(0.45 + 0.15*cfg.smart) + (tx*0.15*cfg.strat);
    this.vy += driveY*(0.45 + 0.15*cfg.smart) + (ty*0.15*cfg.strat);
    const pickupRadius = Math.max(AGENT_BASE_PICKUP_RADIUS * params.agentScale, 6);
    if(!this.carry && tgt && Math.hypot(tgt.x-this.x,tgt.y-this.y)<pickupRadius){
      const i=fruits.indexOf(tgt);
      if(i>-1) fruits.splice(i,1);
      this.carry=true;
      this.fitness += PICKUP_REWARD;
      awardTeamPoints(this.teamState, 'pickup', PICKUP_REWARD);
    }
    if(this.carry && Math.hypot(myGoal.x-this.x,myGoal.y-this.y)<myGoal.r){
      this.carry=false;
      myGoal.delivered++;
      this.fitness += DELIVERY_REWARD;
      awardTeamPoints(this.teamState, 'delivery', DELIVERY_REWARD);
    }
    if(this.carry){
      const dGoal=Math.hypot(myGoal.x-this.x,myGoal.y-this.y);
      this.fitness += (1/(1+dGoal))*0.2;
    }
    deposit(teamId, this.carry? 'food':'home', this.x, this.y, 0.30);
    if(this.stuckT>35){
      this.vx += tx*(0.9+0.2*cfg.strat);
      this.vy += ty*(0.9+0.2*cfg.strat);
      this.stuckT=0;
    }
    this.avoidObstacles();
    this.integrate();
  }
}

class Blocker extends Agent{
  constructor(x,y,teamState,netRef){
    const cfg=teamState.config;
    super(x,y,teamState.config.color,cfg.speed,teamState.config.id);
    this.teamState = teamState;
    this.netRef = netRef;
    if(this.netRef && this.netRef.net){
      ensureNetOutputSize(this.netRef.net);
    }
    this.fitness = 0;
    this.role = 'blocker';
  }
  update(){
    const cfg = this.teamState.config;
    this.stepSpeed(cfg.speed);
    const mates = this.teamState.agents;
    let closestCarrier=null, carrierDist=Infinity;
    let closestAny=null, anyDist=Infinity;
    for(const team of activeTeamStates){
      if(team===this.teamState) continue;
      for(const agent of team.agents){
        const dx = agent.x - this.x;
        const dy = agent.y - this.y;
        const dist = Math.hypot(dx,dy);
        if(dist < anyDist){ anyDist = dist; closestAny = agent; }
        if(agent.carry && dist < carrierDist){ carrierDist = dist; closestCarrier = agent; }
      }
    }
    const target = closestCarrier || closestAny;
    const dist = target ? (closestCarrier ? carrierDist : anyDist) : Infinity;
    let tx=0, ty=0;
    if(target && dist>0){ tx=(target.x-this.x)/dist; ty=(target.y-this.y)/dist; }
    let tvx=0, tvy=0;
    if(target){
      const speed = Math.hypot(target.vx, target.vy);
      if(speed>0){
        tvx = target.vx / speed;
        tvy = target.vy / speed;
      } else {
        tvx = tx;
        tvy = ty;
      }
    }
    let sx=0, sy=0;
    const separationRadius = AGENT_BASE_SEPARATION_RADIUS * params.agentScale;
    for(const p of mates){
      if(p===this) continue;
      const dx=this.x-p.x, dy=this.y-p.y;
      const d=Math.hypot(dx,dy);
      if(d>0 && d<separationRadius){ sx+=dx/(d*d); sy+=dy/(d*d); }
    }
    const input = [tx, ty, tvx, tvy, sx, sy, 1.0];
    const capture = this.activationScratch;
    const out = forward(this.netRef.net, input, capture);
    const nowTime = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
    capture.timestamp = nowTime;
    if(bestBrainState.agentRef === this){
      bestBrainState.activations = capture;
      if(brainVizEnabled){
        markBestBrainDirty();
      }
    }
    const driveX = Number.isFinite(out[0]) ? out[0] : 0;
    const driveY = Number.isFinite(out[1]) ? out[1] : 0;
    const accelerate = Number.isFinite(out[2]) ? out[2] : 0;
    const brake = Number.isFinite(out[3]) ? out[3] : 0;
    const throttleSignal = accelerate - brake;
    if(throttleSignal !== 0){
      this.adjustSpeedFactor(throttleSignal * SPEED_FACTOR_ADJUST);
    }
    this.vx += driveX*(0.50 + 0.18*cfg.smart) + (tx*0.22*cfg.strat) + (tvx*0.12*cfg.smart);
    this.vy += driveY*(0.50 + 0.18*cfg.smart) + (ty*0.22*cfg.strat) + (tvy*0.12*cfg.smart);
    if(!target){
      this.applyWander(0.035 + 0.015*cfg.strat);
    }
    if(target){
      const closeness = Math.max(0, 1 - Math.min(dist, 180)/180);
      this.fitness += closeness * 0.6;
    } else {
      this.fitness -= 0.02;
    }
    this.avoidObstacles();
    this.integrate();
  }
}

function enforceAgentCollisions(){
  if(!params.agentCollisions || activeTeamStates.length < 1) return;
  const allAgents = [];
  for(const team of activeTeamStates){
    for(const agent of team.agents){
      allAgents.push(agent);
    }
  }
  if(allAgents.length < 2) return;
  const agentRadius = Math.max(2.5, AGENT_BASE_RADIUS * params.agentScale);
  const minDist = Math.max(3.5, agentRadius * 2);
  for(let i=0;i<allAgents.length;i++){
    const a = allAgents[i];
    for(let j=i+1;j<allAgents.length;j++){
      const b = allAgents[j];
      let dx = b.x - a.x;
      let dy = b.y - a.y;
      let dist = Math.hypot(dx, dy);
      if(dist === 0){
        const angle = Math.random() * Math.PI * 2;
        dx = Math.cos(angle) * 0.001;
        dy = Math.sin(angle) * 0.001;
        dist = Math.hypot(dx, dy);
      }
      if(dist < minDist){
        const nx = dx / dist;
        const ny = dy / dist;
        const overlap = (minDist - dist) * 0.5;
        if(Number.isFinite(overlap)){
          a.x -= nx * overlap;
          a.y -= ny * overlap;
          b.x += nx * overlap;
          b.y += ny * overlap;

          const relVx = b.vx - a.vx;
          const relVy = b.vy - a.vy;
          const vn = relVx * nx + relVy * ny;
          if(vn < 0){
            const impulse = vn * 0.5;
            a.vx += nx * impulse;
            a.vy += ny * impulse;
            b.vx -= nx * impulse;
            b.vy -= ny * impulse;
          }
          a.keepInBounds();
          b.keepInBounds();
          a.resolveObstaclePenetration(1);
          b.resolveObstaclePenetration(1);
        }
      }
    }
  }
}

function applyBlockerInteractions(){
  if(activeTeamStates.length < 2) return;
  const blockers=[];
  const rivals=[];
  for(const team of activeTeamStates){
    for(const agent of team.agents){
      if(agent.role === 'blocker') blockers.push(agent);
      else rivals.push(agent);
    }
  }
  if(blockers.length===0 || rivals.length===0) return;
  const blockRadius = Math.max(BLOCKER_TRIGGER_RADIUS_BASE * params.agentScale, 10);
  const blockRadiusSq = blockRadius * blockRadius;
  for(const blocker of blockers){
    const blockerTeamId = blocker.teamState?.config?.id;
    for(const opponent of rivals){
      if(opponent.team === blockerTeamId) continue;
      const dx = opponent.x - blocker.x;
      const dy = opponent.y - blocker.y;
      const distSq = dx*dx + dy*dy;
      if(distSq > blockRadiusSq) continue;
      if(opponent.carry && opponent.blockCooldown <= 0){
        const dist = Math.sqrt(distSq);
        const proximity = 1 - Math.min(dist / blockRadius, 1);
        const reward = BLOCKER_BLOCK_REWARD * (0.6 + 0.4*proximity);
        const penalty = -BLOCKER_BLOCK_PENALTY * (0.5 + 0.5*proximity);
        spawnFruit(opponent.x, opponent.y);
        opponent.carry = false;
        opponent.blockCooldown = BLOCKER_EVENT_COOLDOWN;
        blocker.blockCooldown = BLOCKER_EVENT_COOLDOWN;
        blocker.fitness += reward;
        awardTeamPoints(blocker.teamState, 'block', reward);
        if(Number.isFinite(penalty)){
          opponent.fitness += penalty;
          registerTeamFumble(opponent.teamState, penalty);
        }
        continue;
      }
      if(blocker.blockCooldown <= 0 && opponent.blockCooldown <= 0 && !opponent.carry){
        const harassmentReward = BLOCKER_BLOCK_REWARD * 0.12;
        blocker.fitness += harassmentReward;
        blocker.blockCooldown = Math.floor(BLOCKER_EVENT_COOLDOWN * 0.5);
        opponent.blockCooldown = Math.floor(BLOCKER_EVENT_COOLDOWN * 0.35);
      }
    }
  }
}

// ===== Setup & loop =====
let lastSpawn=performance.now();
function setup(){
  fruits.length=0;
  activeTeamStates=[];
  const activeTeams = params.teams.filter((team)=> team.active);
  if(activeTeams.length===0){
    params.teams[0].active = true;
    activeTeams.push(params.teams[0]);
    renderTeamRoster();
  }
  makeGrid();
  if(obstacles.length===0){ makeObstacles(params.obstacles); }
  resizePop();
  params.teams.forEach((team)=>{
    resetGoalDelivery(team.id);
    const board = getTeamScoreData(team.id);
    board.score = 0;
    board.pickups = 0;
    board.deliveries = 0;
    board.blocks = 0;
    board.fumbles = 0;
    updateTeamScoreDisplay(team.id);
  });
  for(let i=0;i<params.maxFruits;i++) spawnFruit();
  activeTeamStates = activeTeams.map((team)=>{
    const population = getPopulation(team.id);
    const goal = ensureGoalState(team.id);
    goal.delivered = 0;
    const state = {
      config:team,
      population,
      agents:[],
      goal,
      bestFitnessCurrent:0,
      peakFitness:bestFitnessByTeam[team.id]||0,
      scoreboard:getTeamScoreData(team.id)
    };
    return state;
  });
  activeTeamStates.forEach((state)=>{
    const spawn = state.config.spawn || { x:[0.1,0.9], y:[0.1,0.9] };
    const minX = (spawn.x?.[0] ?? 0.1) * W;
    const maxX = (spawn.x?.[1] ?? 0.9) * W;
    const minY = (spawn.y?.[0] ?? 0.1) * H;
    const maxY = (spawn.y?.[1] ?? 0.9) * H;
    const goal = state.goal;
    const agentPadding = Math.max(AGENT_BASE_RADIUS * params.agentScale, 4);
    for(let i=0;i<state.config.count;i++){
      const netRef = state.population[i] || { net:makeNet(), fitness:0 };
      if(!state.population[i]) state.population[i] = netRef;
      netRef.fitness = 0;
      const AgentClass = state.config.role === 'blocker' ? Blocker : Collector;
      let spawnX = rand(minX, maxX);
      let spawnY = rand(minY, maxY);
      if(goal){
        const maxRadius = Math.max(0, goal.r - agentPadding);
        if(maxRadius === 0){
          spawnX = clamp(goal.x, agentPadding, W - agentPadding);
          spawnY = clamp(goal.y, agentPadding, H - agentPadding);
        } else {
          const minRadius = Math.max(0, maxRadius * 0.35);
          const radius = minRadius + Math.random() * (maxRadius - minRadius);
          const angle = Math.random() * Math.PI * 2;
          spawnX = clamp(goal.x + Math.cos(angle) * radius, agentPadding, W - agentPadding);
          spawnY = clamp(goal.y + Math.sin(angle) * radius, agentPadding, H - agentPadding);
        }
      }
      const agent = new AgentClass(spawnX, spawnY, state, netRef);
      state.agents.push(agent);
    }
  });
  lastSpawn=performance.now();
  refreshStats();
}

function drawTrail(trail,color){
  if(trail.length<2) return;
  const width = Math.max(1.2, AGENT_TRAIL_WIDTH * params.agentScale);
  ctx.lineWidth = width;
  const grad=ctx.createLinearGradient(trail[0].x,trail[0].y,trail[trail.length-1].x,trail[trail.length-1].y);
  grad.addColorStop(0,'rgba(255,255,255,0)');
  grad.addColorStop(1,color);
  ctx.strokeStyle=grad;
  ctx.beginPath();
  ctx.moveTo(trail[0].x,trail[0].y);
  for(let i=1;i<trail.length;i++) ctx.lineTo(trail[i].x,trail[i].y);
  ctx.stroke();
}
function drawGoal(teamState){
  const g = teamState.goal;
  const tint = teamState.config.color;
  ctx.beginPath();
  ctx.arc(g.x,g.y,g.r,0,Math.PI*2);
  ctx.fillStyle=COLORS.goalFill;
  ctx.fill();
  ctx.save();
  ctx.strokeStyle=tint;
  ctx.lineWidth = 4; // static
  ctx.shadowColor='transparent';
  ctx.shadowBlur=0;
  ctx.stroke();
  ctx.restore();
  ctx.fillStyle='#fff';
  ctx.textAlign='center';
  ctx.textBaseline='middle';
  if(teamState.config.role !== 'blocker'){
    ctx.font='bold 18px ui-sans-serif';
    ctx.fillText(String(g.delivered), g.x, g.y);
  }
}

function drawObstacleShape(o, time, preview=false){
  const paletteIndex = (typeof o.paletteIndex === 'number') ? o.paletteIndex : 0;
  const palette = OBSTACLE_COLORS[paletteIndex % OBSTACLE_COLORS.length];
  const phase = (typeof o.phase === 'number') ? o.phase : 0;
  const pulse = preview ? 0.3 + 0.2*Math.sin(time*0.9 + phase) : 0.45 + 0.35*Math.sin(time*0.9 + phase);
  const fillAlpha = preview ? 0.06 + 0.08*pulse : 0.10 + 0.14*pulse;
  const strokeAlpha = preview ? 0.45 : 0.6 + 0.3*pulse;
  const shadowAlpha = preview ? 0.16 : 0.35*pulse;
  ctx.save();
  ctx.shadowColor = hexToRgba(palette, shadowAlpha);
  ctx.shadowBlur = preview ? 10 : 18*pulse;
  const applyStroke = ()=>{ ctx.strokeStyle = hexToRgba(palette, strokeAlpha); };
  switch(o.type){
    case 'rect':{
      const halfW = o.width/2;
      const halfH = o.height/2;
      ctx.fillStyle = hexToRgba(palette, fillAlpha);
      applyStroke();
      ctx.lineWidth = (preview?1.6:2.2) + 0.8*pulse;
      ctx.setLineDash(preview ? [8,6] : []);
      ctx.beginPath();
      ctx.rect(o.x - halfW, o.y - halfH, o.width, o.height);
      ctx.fill();
      ctx.stroke();
      break;
    }
    case 'line':{
      applyStroke();
      ctx.lineWidth = (o.thickness||14) + (preview?0:2)*pulse;
      ctx.lineCap = 'round';
      ctx.setLineDash(preview ? [6,6] : []);
      ctx.beginPath();
      ctx.moveTo(o.x1, o.y1);
      ctx.lineTo(o.x2, o.y2);
      ctx.stroke();
      break;
    }
    case 'half':{
      const start = o.angle - Math.PI/2;
      const end = o.angle + Math.PI/2;
      const startX = o.x + Math.cos(start)*o.r;
      const startY = o.y + Math.sin(start)*o.r;
      ctx.fillStyle = hexToRgba(palette, fillAlpha);
      applyStroke();
      ctx.lineWidth = (preview?1.6:2.3) + 0.8*pulse;
      ctx.setLineDash(preview ? [8,6] : []);
      ctx.beginPath();
      ctx.moveTo(startX, startY);
      ctx.arc(o.x, o.y, o.r, start, end);
      ctx.lineTo(startX, startY);
      ctx.fill();
      ctx.stroke();
      break;
    }
    default:{
      const radius = o.r || getObstacleRadius(o);
      ctx.fillStyle = hexToRgba(palette, fillAlpha);
      applyStroke();
      ctx.lineWidth = 2.1 + 0.9*pulse;
      ctx.setLineDash(preview ? [8,6] : []);
      ctx.beginPath();
      ctx.arc(o.x, o.y, radius, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
      break;
    }
  }
  ctx.restore();
}

function drawTopAgentHighlight(agent, radius){
  if(!params.showTopHighlight) return;
  if(!agent) return;
  const haloRadius = radius + Math.max(4, radius * 0.6);
  ctx.save();
  ctx.lineWidth = Math.max(2, radius * 0.9);
  ctx.strokeStyle = 'rgba(251,191,36,0.85)';
  ctx.shadowColor = 'rgba(251,191,36,0.65)';
  ctx.shadowBlur = 16;
  ctx.beginPath();
  ctx.arc(agent.x, agent.y, haloRadius, 0, Math.PI*2);
  ctx.stroke();
  ctx.restore();

  ctx.save();
  const crownSize = Math.max(16, radius * 3.4);
  ctx.font = `600 ${crownSize}px "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji", "Twemoji Mozilla", sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'bottom';
  ctx.shadowColor = 'rgba(251,191,36,0.6)';
  ctx.shadowBlur = 10;
  ctx.fillText('👑', agent.x, agent.y - radius - 6);
  ctx.restore();
}

function draw(){
  ctx.clearRect(0,0,W,H);

  // Goals (static, no blinking)
  for(const team of activeTeamStates){
    drawGoal(team);
  }

  // Obstacles (ambient pulse)
  const t = performance.now()*0.001;
  for(const o of obstacles){
    drawObstacleShape(o, t, false);
  }
  if(drawingState){
    const preview = buildObstacleFromState(drawingState, true);
    if(preview){
      preview.paletteIndex = manualPaletteCursor % OBSTACLE_COLORS.length;
      drawObstacleShape(preview, t, true);
    }
  }

  // Fruits
  for(const f of fruits){
    ctx.beginPath();
    ctx.arc(f.x,f.y,f.r,0,Math.PI*2);
    ctx.fillStyle=COLORS.fruit;
    ctx.fill();
    ctx.lineWidth=1.5;
    ctx.strokeStyle=COLORS.fruitOutline;
    ctx.stroke();
  }

  // Agents (no shadow flash)
  let topAgent = null;
  let topAgentFitness = -Infinity;
  for(const team of activeTeamStates){
    for(const agent of team.agents){
      const f = Number(agent.fitness);
      if(Number.isFinite(f) && f > topAgentFitness){
        topAgentFitness = f;
        topAgent = agent;
      }
    }
  }
  for(const team of activeTeamStates){
    const outline = team.config.outline || '#0f172a';
    for(const a of team.agents){
      ctx.beginPath();
      const agentRadius = Math.max(2.5, AGENT_BASE_RADIUS * params.agentScale);
      ctx.arc(a.x,a.y,agentRadius,0,Math.PI*2);
      ctx.fillStyle=team.config.color;
      ctx.fill();
      const outlineWidth = Math.max(1.2, 2*params.agentScale);
      ctx.lineWidth=outlineWidth;
      ctx.strokeStyle=outline;
      ctx.stroke();
      if(a.carry){
        const carryOutline = Math.max(1.5, outlineWidth + 0.6*params.agentScale);
        ctx.lineWidth=carryOutline;
        ctx.strokeStyle='#ffff33';
        ctx.stroke();
      }
      drawTrail(a.trail, team.config.color);
      if(params.showTopHighlight && topAgent && a === topAgent){
        drawTopAgentHighlight(a, agentRadius);
      }
    }
  }
}

let simSteps=0, forceNextGen=false, awaitingManualAdvance=false;
function advanceGeneration(){
  for(const teamState of activeTeamStates){
    const pop = getPopulation(teamState.config.id);
    for(let i=0;i<teamState.agents.length && i<pop.length;i++){
      pop[i].fitness += teamState.agents[i].fitness;
    }
    evolveTeam(teamState);
  }
  evo.gen++;
  simSteps=0;
  forceNextGen=false;
  awaitingManualAdvance=false;
  setup();
}
function loop(){
  requestAnimationFrame(loop);

  if(awaitingManualAdvance){
    if(forceNextGen){
      advanceGeneration();
    }
    return;
  }

  const now = performance.now();
  for(const team of activeTeamStates){
    for(const agent of team.agents){
      agent.update();
      trackBestBrain(agent, team);
    }
  }
  enforceAgentCollisions();
  applyBlockerInteractions();
  evaporate();
  if(now - lastSpawn >= params.spawnMs){
    spawnFruit();
    lastSpawn = now;
  }
  draw();
  refreshStats();
  if(bestBrainDirty){
    renderBestBrain();
  }
  simSteps++;

  const reachedLimit = simSteps>=params.learn.genSteps;
  if(forceNextGen || (reachedLimit && params.learn.auto)){
    advanceGeneration();
  }else if(reachedLimit){
    awaitingManualAdvance=true;
  }
}

function applyBestFitnessSnapshot(bestMap){
  if(!bestMap) return;
  for(const [teamId, value] of Object.entries(bestMap)){
    const numeric = Number(value);
    if(!Number.isFinite(numeric)) continue;
    bestFitnessByTeam[teamId] = numeric;
  }
  for(const team of activeTeamStates){
    const stored = bestFitnessByTeam[team.config.id];
    if(Number.isFinite(stored)){
      team.peakFitness = Math.max(team.peakFitness||0, stored);
    }
  }
  refreshStats();
}

function captureTrainingSnapshot(){
  const paramsClone = JSON.parse(JSON.stringify(params));
  const evoTeams = params.teams.map((team)=>{
    const population = getPopulation(team.id);
    return {
      id:team.id,
      active:!!team.active,
      members:population.map((member)=> ({ net:cloneNet(member.net), fitness:member.fitness||0 }))
    };
  });
  return {
    version:2,
    savedAt:new Date().toISOString(),
    params:paramsClone,
    evo:{
      gen:evo.gen,
      teams:evoTeams
    },
    best:Object.fromEntries(Object.entries(bestFitnessByTeam))
  };
}

// Object URL management for downloads
let currentObjectUrl = null;
let currentObjectUrlToken = 0;

function setCurrentObjectUrl(url){
  clearCurrentObjectUrl();
  currentObjectUrl = url;
  currentObjectUrlToken++;
  return { url, token: currentObjectUrlToken };
}

function clearCurrentObjectUrl(expectedToken=null){
  if(expectedToken != null && expectedToken !== currentObjectUrlToken) return;
  if(currentObjectUrl){
    try{ URL.revokeObjectURL(currentObjectUrl); }catch(_err){ /* ignore */ }
    currentObjectUrl = null;
  }
}

function downloadTrainingData(){
  try{
    const snapshot = captureTrainingSnapshot();
    const json = JSON.stringify(snapshot, null, 2);
    const blob = new Blob([json], { type:'application/json' });
    const { url, token } = setCurrentObjectUrl(URL.createObjectURL(blob));
    const genStr = String(snapshot.evo?.gen ?? 1).padStart(3, '0');
    const link = document.createElement('a');
    link.href = url;
    link.download = `foodsim-training-gen${genStr}.json`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    setTimeout(()=> clearCurrentObjectUrl(token), 1000);
  }catch(err){
    console.error('Failed to export training data', err);
    alert('Could not save training data. Please try again.');
  }
}

function applyParamsSnapshot(snapshot){
  if(!snapshot) return;
  if(snapshot.maxFruits != null) setRangeValue('slFruits', snapshot.maxFruits);
  if(snapshot.spawnMs != null) setRangeValue('slSpawn', snapshot.spawnMs);
  if(snapshot.obstacles != null) setRangeValue('slObst', snapshot.obstacles);
  if(snapshot.tailLen != null) setRangeValue('slTail', snapshot.tailLen);
  if(snapshot.agentScale != null) setRangeValue('slAgentScale', Math.round(snapshot.agentScale*100));
  if(snapshot.agentCollisions !== undefined){
    const toggle = Q('chkAgentCollisions');
    if(toggle){
      toggle.checked = !!snapshot.agentCollisions;
      toggle.dispatchEvent(new Event('change', { bubbles:true }));
    }
  }

  if(snapshot.showTopHighlight !== undefined){
    const toggle = Q('chkTopHighlight');
    if(toggle){
      toggle.checked = !!snapshot.showTopHighlight;
      toggle.dispatchEvent(new Event('change', { bubbles:true }));
    }
  }

  if(typeof snapshot.fruitPlacement === 'string'){
    setFruitPlacement(snapshot.fruitPlacement, false);
  }

  if(Array.isArray(snapshot.teams) && snapshot.teams.length){
    const toNumber = (value)=>{
      const numeric = Number(value);
      return Number.isFinite(numeric) ? numeric : null;
    };
    snapshot.teams.forEach((teamSnapshot)=>{
      const target = params.teams.find((t)=>t.id===teamSnapshot.id);
      if(!target) return;
      const count = toNumber(teamSnapshot.count);
      if(count != null) target.count = count;
      const speed = toNumber(teamSnapshot.speed);
      if(speed != null) target.speed = speed;
      const smart = toNumber(teamSnapshot.smart);
      if(smart != null) target.smart = smart;
      const strat = toNumber(teamSnapshot.strat);
      if(strat != null) target.strat = strat;
      const sep = toNumber(teamSnapshot.sep);
      if(sep != null) target.sep = sep;
      if(teamSnapshot.active !== undefined) target.active = !!teamSnapshot.active;
    });
    renderTeamRoster();
    resizePop();
  } else {
    const refTeam = snapshot.green || snapshot.red || null;
    if(refTeam){
      const count = Number(refTeam.count);
      const speed = Number(refTeam.speed);
      const smart = Number(refTeam.smart);
      const strat = Number(refTeam.strat);
      const sep = Number(refTeam.sep);
      params.teams.forEach((team)=>{
        if(Number.isFinite(count)) team.count = count;
        if(Number.isFinite(speed)) team.speed = speed;
        if(Number.isFinite(smart)) team.smart = smart;
        if(Number.isFinite(strat)) team.strat = strat;
        if(Number.isFinite(sep)) team.sep = sep;
      });
    }
    params.teams.forEach((team, index)=>{
      team.active = index < 2;
    });
    renderTeamRoster();
    resizePop();
  }

  if(snapshot.learn){
    if(snapshot.learn.genSteps != null) setRangeValue('slGenSteps', snapshot.learn.genSteps);
    if(snapshot.learn.mut != null) setRangeValue('slMut', Math.round(snapshot.learn.mut*100));
    if(snapshot.learn.elite != null) setRangeValue('slElite', Math.round(snapshot.learn.elite*100));
    if(snapshot.learn.mutStrengthW != null) setRangeValue('slMutStrengthW', Math.round(snapshot.learn.mutStrengthW*100));
    if(snapshot.learn.mutStrengthB != null) setRangeValue('slMutStrengthB', Math.round(snapshot.learn.mutStrengthB*100));
    if(snapshot.learn.crossoverBias != null) setRangeValue('slCrossover', Math.round(snapshot.learn.crossoverBias*100));
    if(snapshot.learn.tournamentFactor != null) setRangeValue('slTournament', Math.round(snapshot.learn.tournamentFactor*10));
    if(snapshot.learn.fresh != null) setRangeValue('slFresh', Math.round(snapshot.learn.fresh*100));
    if(snapshot.learn.auto !== undefined){
      const auto = Q('chkAuto');
      if(auto){
        auto.checked = !!snapshot.learn.auto;
        auto.dispatchEvent(new Event('change', { bubbles:true }));
      }
    }
  }
}

function loadTrainingSnapshot(data){
  if(!data || typeof data !== 'object') throw new Error('Invalid training file.');
  const evoData = data.evo || data;
  if(!evoData) throw new Error('Training file is missing the evo section.');

  const toIndividual = (entry)=>{
    const netData = entry && (entry.net || entry);
    if(!netData || !netData.W1 || !netData.b1 || !netData.W2 || !netData.b2){
      throw new Error('Training file contains malformed network data.');
    }
    return { net:cloneNet(netData), fitness:0 };
  };

  let bestFromSnapshot = {};
  resetBestBrainState(Number(evoData.gen) || 1);
  let bestBrainCandidate = null;

  if(data.params) applyParamsSnapshot(data.params);

  if(Array.isArray(evoData.teams)){
    bestFromSnapshot = {};
    evoData.teams.forEach((teamEntry)=>{
      const members = Array.isArray(teamEntry.members) ? teamEntry.members : [];
      evo.populations[teamEntry.id] = members.map(toIndividual);
      const targetTeam = params.teams.find((t)=>t.id===teamEntry.id);
      if(targetTeam && teamEntry.active !== undefined){
        targetTeam.active = !!teamEntry.active;
      }
      let bestFitness = 0;
      for(const item of members){
        const val = Number(item?.fitness);
        if(Number.isFinite(val) && val > bestFitness) bestFitness = val;
        if(Number.isFinite(val)){
          const netData = item && (item.net || item);
          if(netData && netData.W1 && netData.W2){
            if(!bestBrainCandidate || val > bestBrainCandidate.fitness){
              bestBrainCandidate = { teamId:teamEntry.id, fitness:val, net:cloneNet(netData) };
            }
          }
        }
      }
      bestFromSnapshot[teamEntry.id] = bestFitness;
    });
    renderTeamRoster();
  } else {
    const greensData = Array.isArray(evoData.greens) ? evoData.greens : (Array.isArray(evoData.G) ? evoData.G : null);
    const redsData = Array.isArray(evoData.reds) ? evoData.reds : (Array.isArray(evoData.R) ? evoData.R : null);
    if(!greensData || !redsData) throw new Error('Training file does not contain both team genomes.');

    evo.populations.green = greensData.map(toIndividual);
    evo.populations.red = redsData.map(toIndividual);
    params.teams.forEach((team, index)=>{
      team.active = index < 2;
    });
    renderTeamRoster();

    let bestG = 0;
    for(const item of greensData){
      const val = Number(item?.fitness);
      if(Number.isFinite(val) && val > bestG) bestG = val;
      if(Number.isFinite(val)){
        const netData = item && (item.net || item);
        if(netData && netData.W1 && netData.W2 && (!bestBrainCandidate || val > bestBrainCandidate.fitness)){
          bestBrainCandidate = { teamId:'green', fitness:val, net:cloneNet(netData) };
        }
      }
    }
    let bestR = 0;
    for(const item of redsData){
      const val = Number(item?.fitness);
      if(Number.isFinite(val) && val > bestR) bestR = val;
      if(Number.isFinite(val)){
        const netData = item && (item.net || item);
        if(netData && netData.W1 && netData.W2 && (!bestBrainCandidate || val > bestBrainCandidate.fitness)){
          bestBrainCandidate = { teamId:'red', fitness:val, net:cloneNet(netData) };
        }
      }
    }
    bestFromSnapshot = { green:bestG, red:bestR };
  }

  const parsedGen = Number(evoData.gen);
  evo.gen = Number.isFinite(parsedGen) && parsedGen > 0 ? parsedGen : 1;

  simSteps = 0;
  forceNextGen = false;
  awaitingManualAdvance = false;
  setup();

  if(bestBrainCandidate){
    const teamInfo = params.teams.find((t)=>t.id===bestBrainCandidate.teamId) || { id:bestBrainCandidate.teamId, label:bestBrainCandidate.teamId, icon:'●', color:'#38bdf8' };
    setBestBrainFromNet(bestBrainCandidate.net, teamInfo, bestBrainCandidate.fitness, evo.gen, null, globalBrainChampion);
    const cache = ensureTeamBrainCache(teamInfo.id);
    if(cache){
      setBestBrainFromNet(bestBrainCandidate.net, teamInfo, bestBrainCandidate.fitness, evo.gen, null, cache);
    }
  }

  applyBrainSelection(brainTeamSelect ? brainTeamSelect.value : 'auto');

  const bestCombined = Object.assign({}, bestFromSnapshot, data.best || {});
  applyBestFitnessSnapshot(bestCombined);
}

function handleTrainingFileSelection(evt){
  const input = evt.target;
  const file = input?.files?.[0];
  if(input) input.value = '';
  if(!file) return;
  const reader = new FileReader();
  reader.onload = ()=>{
    try{
      const parsed = JSON.parse(reader.result);
      loadTrainingSnapshot(parsed);
    }catch(err){
      console.error('Failed to load training file', err);
      alert('Could not load training data. Please ensure it was exported from this simulator.');
    }
  };
  reader.onerror = ()=>{
    console.error('Unable to read the selected file', reader.error);
    alert('Could not read the selected file.');
  };
  reader.readAsText(file);
}

const btnSaveTraining = Q('btnSaveTraining');
if(btnSaveTraining){
  btnSaveTraining.addEventListener('click', downloadTrainingData);
}
const btnLoadTraining = Q('btnLoadTraining');
const inputLoadTraining = Q('inputLoadTraining');
if(btnLoadTraining && inputLoadTraining){
  btnLoadTraining.addEventListener('click', ()=> inputLoadTraining.click());
  inputLoadTraining.addEventListener('change', handleTrainingFileSelection);
}

const toolButtons = Array.from(document.querySelectorAll('.tool-btn'));
function setTool(tool){
  if(!toolButtons.length){
    currentTool = tool || TOOL_SELECT;
    return;
  }
  const nextTool = toolButtons.some(btn=>btn.dataset.tool===tool) ? tool : TOOL_SELECT;
  currentTool = nextTool;
  toolButtons.forEach(btn=>{
    const isActive = btn.dataset.tool === nextTool;
    btn.classList.toggle('active', isActive);
    btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
  });
  if(currentTool === TOOL_SELECT){
    drawingState = null;
  }
}

if(toolButtons.length){
  toolButtons.forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const tool = btn.dataset.tool || TOOL_SELECT;
      setTool(tool);
    });
  });
  setTool(TOOL_SELECT);
}

const btnUndoManual = Q('btnUndoManual');
if(btnUndoManual){
  btnUndoManual.addEventListener('click', ()=>{
    for(let i=obstacles.length-1; i>=0; i--){
      if(obstacles[i].manual){
        obstacles.splice(i,1);
        break;
      }
    }
    syncManualObstacleState();
  });
}

const btnClearManual = Q('btnClearManual');
if(btnClearManual){
  btnClearManual.addEventListener('click', ()=>{
    for(let i=obstacles.length-1; i>=0; i--){
      if(obstacles[i].manual){
        obstacles.splice(i,1);
      }
    }
    syncManualObstacleState();
  });
}

syncManualObstacleState();

if(brainCanvas){
  window.addEventListener('resize', ()=>{
    brainCanvasWidth = brainCanvas.clientWidth || brainCanvasWidth;
    brainCanvasHeight = brainCanvas.clientHeight || brainCanvasHeight;
    markBestBrainDirty();
    renderBestBrain();
  });
}

// Bind ranges after DOM ready
['Fruits','Spawn','Obst','Tail','GenSteps'].forEach(k=>{
  bindRange('sl'+k, 'lb'+k, (v)=> v);
});
bindRange('slMut','lbMut',(v)=> `${v}%`);
bindRange('slElite','lbElite',(v)=> `${v}%`);
bindRange('slMutStrengthW','lbMutStrengthW',(v)=> (v/100).toFixed(2));
bindRange('slMutStrengthB','lbMutStrengthB',(v)=> (v/100).toFixed(2));
bindRange('slCrossover','lbCrossover',(v)=> `${v}% A`);
bindRange('slTournament','lbTournament',(v)=> `×${(v/10).toFixed(1)}`);
bindRange('slFresh','lbFresh',(v)=> `${v}%`);
bindRange('slAgentScale','lbAgentScale',(v)=> (v/100).toFixed(2)+'×');
initFruitPlacementControls();
Q('btnReset').onclick = ()=> { awaitingManualAdvance=false; forceNextGen=false; simSteps=0; setup(); };
Q('btnNextGen').onclick = ()=> { forceNextGen = true; };
Q('chkAuto').addEventListener('change', ()=> readParams());
const chkAgentCollisions = Q('chkAgentCollisions');
if(chkAgentCollisions){
  chkAgentCollisions.addEventListener('change', ()=> readParams());
}

const chkTopHighlight = Q('chkTopHighlight');
if(chkTopHighlight){
  chkTopHighlight.addEventListener('change', ()=> readParams());
}

window.addEventListener('beforeunload', clearCurrentObjectUrl);

// Start
initMusicPanel();
renderTeamRoster();
readParams();
setup();
renderBestBrain();
loop();
</script>
</body>
</html>
