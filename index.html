<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>FoodSim â€“ Two Teams with NEAT-lite</title>
  <style>
    :root {
      --bg1:#050516;
      --bg2:#161b3f;
      --panel:rgba(18,24,56,.82);
      --ink:#f1f5ff;
      --muted:#a1a9d8;
      --accent:#f472b6;
      --accent-emerald:#2dd4bf;
      --accent-cyan:#38bdf8;
      --silver:rgba(222,231,255,.55);
    }
    *{box-sizing:border-box}
    body{margin:0; min-height:100vh; display:flex; flex-direction:column; background:radial-gradient(circle at 45% 12%, rgba(87,51,183,.55) 0%, rgba(39,56,121,.85) 45%, var(--bg1) 100%); color:var(--ink); font-family:"Inter",system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;}

    .main-nav{position:sticky; top:0; z-index:200; padding:22px 48px; display:flex; align-items:center; justify-content:space-between; background:linear-gradient(120deg, rgba(15,20,48,.92) 0%, rgba(10,14,34,.75) 60%, rgba(10,14,34,.35) 100%); backdrop-filter:blur(14px); border-bottom:1px solid var(--silver); box-shadow:0 22px 45px rgba(5,9,25,.55)}
    .brand{display:flex; align-items:center; gap:12px; font-size:22px; font-weight:700; letter-spacing:.02em; color:var(--ink)}
    .brand-dot{width:14px; height:14px; border-radius:50%; background:linear-gradient(135deg, var(--accent) 0%, #8b5cf6 100%); box-shadow:0 0 18px rgba(244,114,182,.6)}
    .nav-links{display:flex; align-items:center; gap:12px}
    .pill-link{display:inline-flex; align-items:center; justify-content:center; padding:10px 20px; border-radius:999px; border:1px solid rgba(45,212,191,.45); background:linear-gradient(120deg, rgba(45,212,191,.18), rgba(59,130,246,.18)); color:var(--ink); text-decoration:none; font-size:14px; font-weight:600; letter-spacing:.03em; transition:transform .2s ease, box-shadow .2s ease, filter .2s ease, border-color .2s ease}
    .pill-link.secondary{border-color:rgba(139,92,246,.45); background:linear-gradient(120deg, rgba(139,92,246,.18), rgba(244,114,182,.18))}
    .pill-link:hover{transform:translateY(-1px); filter:brightness(1.05); box-shadow:0 16px 32px rgba(45,212,191,.25)}
    .pill-link:focus-visible{outline:2px solid rgba(56,189,248,.65); outline-offset:3px}

    main{flex:1; display:flex; justify-content:center; align-items:flex-start; padding:40px 48px 64px}
    .wrap{display:flex; align-items:flex-start; justify-content:center; gap:40px; width:100%; max-width:2000px}
    canvas{border-radius:24px; background:#04091f; box-shadow:0 0 45px rgba(15,23,61,.65), inset 0 0 22px rgba(118,133,255,.12); cursor:crosshair; border:1px solid var(--silver);}

    .side{width:420px; flex:0 1 420px; display:flex; flex-direction:column; gap:20px}
    .panel{background:var(--panel); border:1px solid var(--silver); padding:22px; border-radius:20px; backdrop-filter:blur(16px); box-shadow:0 18px 45px rgba(5,7,24,.55); position:relative}
    .panel-head{display:flex; align-items:center; justify-content:space-between; gap:12px; cursor:pointer; user-select:none; padding-bottom:10px; margin-bottom:14px; border-bottom:1px dashed rgba(189,206,255,.28)}
    .panel-head .h{margin:0; font-size:17px; letter-spacing:.03em}
    .chev{font-weight:900; font-size:16px; opacity:.75; transition:transform .25s ease}
    .panel-body{max-height:1200px; overflow:hidden; transition:max-height .35s ease, opacity .25s ease; opacity:1}
    .panel.collapsed .panel-body{max-height:0; opacity:.0}
    .panel.collapsed .chev{transform:rotate(-90deg)}

    .grid{display:grid; grid-template-columns: 1fr 1.3fr auto; gap:12px 12px; align-items:center}
    .label{font-size:13px; color:var(--muted); letter-spacing:.02em}
    .val{font-family:ui-monospace,Menlo,Consolas,monospace; font-size:12px; padding:4px 8px; border-radius:8px; background:rgba(10,16,46,.7); border:1px solid var(--silver); color:var(--accent-cyan); box-shadow:inset 0 0 12px rgba(56,189,248,.12)}
    input[type=range]{width:100%; accent-color:var(--accent-cyan)}
    .btn{display:block; width:100%; padding:12px 14px; border-radius:12px; border:1px solid rgba(45,212,191,.45); background:linear-gradient(120deg, rgba(45,212,191,.18), rgba(59,130,246,.18)); color:var(--ink); cursor:pointer; text-align:center; margin-top:14px; font-weight:600; letter-spacing:.02em; transition:transform .2s ease, box-shadow .2s ease, filter .2s ease}
    .btn:hover{filter:brightness(1.08); transform:translateY(-1px); box-shadow:0 20px 36px rgba(45,212,191,.28)}
    .tool-hint{margin:0 0 14px; font-size:12px; line-height:1.6; color:var(--muted)}
    .tool-buttons{display:grid; grid-template-columns:repeat(auto-fit,minmax(120px,1fr)); gap:10px}
    .tool-btn{padding:10px 12px; border-radius:12px; border:1px solid rgba(59,130,246,.28); background:rgba(18,27,66,.6); color:var(--ink); font-size:13px; font-weight:600; letter-spacing:.02em; cursor:pointer; transition:transform .2s ease, box-shadow .2s ease, filter .2s ease, border-color .2s ease}
    .tool-btn:hover{filter:brightness(1.05); transform:translateY(-1px); box-shadow:0 12px 26px rgba(59,130,246,.22)}
    .tool-btn.active{border-color:rgba(45,212,191,.65); background:linear-gradient(120deg, rgba(45,212,191,.24), rgba(59,130,246,.24)); box-shadow:0 14px 28px rgba(45,212,191,.24)}
    .sub{font-weight:800; font-size:14px; opacity:.9; margin:10px 0 8px; letter-spacing:.05em; color:var(--ink)}
    .music-lead{font-size:13px; line-height:1.6; opacity:.85; margin:0 0 14px}
    .music-select{display:flex; flex-direction:column; gap:6px}
    .music-dropdown{width:100%; padding:10px 12px; border-radius:12px; border:1px solid var(--silver); background:rgba(12,18,44,.82); color:var(--ink); font-size:13px; font-family:inherit; letter-spacing:.01em; box-shadow:inset 0 0 12px rgba(118,133,255,.15)}
    .music-controls{display:flex; align-items:center; gap:12px; margin-top:12px; flex-wrap:wrap}
    .music-controls .btn{flex:0 0 auto; width:auto; padding:10px 18px; margin-top:0}
    .music-volume{display:flex; flex:1; align-items:center; gap:10px; min-width:200px}
    .music-volume .label{min-width:60px}
    .music-volume input[type=range]{flex:1}
    .music-meta{margin-top:14px; font-size:12px; line-height:1.6; background:rgba(11,16,44,.65); border:1px solid var(--silver); padding:12px 14px; border-radius:14px; box-shadow:inset 0 0 14px rgba(138,92,246,.12)}
    .music-status{display:flex; align-items:center; gap:8px; font-size:12px; text-transform:uppercase; letter-spacing:.08em; opacity:.82; color:var(--accent-cyan)}
    .music-attr{opacity:.72}
    .sr-only{position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0}

    @media (max-width:1200px){
      .wrap{flex-direction:column; align-items:center}
      .side{width:100%; max-width:720px}
    }
    @media (max-width:900px){
      main{padding:32px 28px 56px}
    }
    @media (max-width:768px){
      .main-nav{flex-direction:column; align-items:flex-start; gap:16px; padding:18px 24px}
      .nav-links{flex-wrap:wrap}
      main{padding:28px 20px 56px}
      .wrap{gap:28px}
      canvas{width:100%; height:auto}
      .side{max-width:100%}
    }
  </style>
</head>
<body>
  <header class="main-nav">
    <div class="brand"><span class="brand-dot"></span>FoodSim NEAT Lab</div>
    <nav class="nav-links" aria-label="Primary navigation">
      <a class="pill-link" href="#world">Playfield</a>
      <a class="pill-link" href="#panel-global">Controls</a>
      <a class="pill-link secondary" href="learn-neat.html">How NEAT works</a>
    </nav>
  </header>
  <main>
  <div class="wrap">
    <!-- Left panel: Learning (NEAT) -->
    <aside class="side" id="left-panel">
      <div class="panel" id="panel-learn">
        <div class="panel-head"><div class="h">Learning (NEAT-lite)</div><span class="chev">â–¾</span></div>
        <div class="panel-body">
          <div class="grid">
            <div class="label">Steps / gen</div>
            <input id="slGenSteps" type="range" min="600" max="100000000" value="2800"><div class="val" id="lbGenSteps">2800</div>

            <div class="label">Mutation %</div>
            <input id="slMut" type="range" min="1" max="80" value="16"><div class="val" id="lbMut">16</div>

            <div class="label">Elite ratio</div>
            <input id="slElite" type="range" min="5" max="50" value="20"><div class="val" id="lbElite">0.20</div>
          </div>
          <div class="grid" style="margin-top:8px">
            <div class="label">Auto next gen</div>
            <input id="chkAuto" type="checkbox" checked><div class="val" id="lbAuto">on</div>
          </div>
          <div class="sub" style="margin-top:10px">Status</div>
          <div class="grid">
            <div class="label">Generation</div><div></div><div class="val" id="lbGen">1</div>
            <div class="label">Best ðŸŸ¢</div><div></div><div class="val" id="lbBestG">0</div>
            <div class="label">Best ðŸ”´</div><div></div><div class="val" id="lbBestR">0</div>
          </div>
          <button id="btnNextGen" class="btn">Advance generation now</button>
          <button id="btnSaveTraining" class="btn">Save training (.json)</button>
          <button id="btnLoadTraining" class="btn">Load trainingâ€¦</button>
          <input type="file" id="inputLoadTraining" accept="application/json" style="display:none">
        </div>
      </div>
    </aside>

    <!-- Middle: playfield -->
    <canvas id="world" width="1100" height="640"></canvas>

    <!-- Right panels: controls and teams -->
    <aside class="side" id="right-panel">
      <div class="panel" id="panel-global">
        <div class="panel-head"><div class="h">Global controls</div><span class="chev">â–¾</span></div>
        <div class="panel-body">
          <div class="grid">
            <div class="label">Fruit (max)</div>
            <input id="slFruits" type="range" min="2" max="1000" value="32"><div class="val" id="lbFruits">32</div>

            <div class="label">Spawn (ms)</div>
            <input id="slSpawn" type="range" min="120" max="15000" value="900"><div class="val" id="lbSpawn">900</div>

            <div class="label">Obstacles</div>
            <input id="slObst" type="range" min="0" max="40" value="8"><div class="val" id="lbObst">8</div>

            <div class="label">Trail length</div>
            <input id="slTail" type="range" min="4" max="1500" value="24"><div class="val" id="lbTail">24</div>
          </div>
          <button id="btnReset" class="btn">Restart</button>
        </div>
      </div>

      <div class="panel" id="panel-toolbox">
        <div class="panel-head"><div class="h">Obstacle toolbox</div><span class="chev">â–¾</span></div>
        <div class="panel-body">
          <p class="tool-hint">Choose a tool to draw glowing obstacles directly on the field.</p>
          <div class="tool-buttons" role="group" aria-label="Obstacle drawing tools">
            <button class="tool-btn active" data-tool="select" aria-pressed="true">Move</button>
            <button class="tool-btn" data-tool="circle" aria-pressed="false">Circle</button>
            <button class="tool-btn" data-tool="rect" aria-pressed="false">Rectangle</button>
            <button class="tool-btn" data-tool="line" aria-pressed="false">Line</button>
            <button class="tool-btn" data-tool="half" aria-pressed="false">Half circle</button>
          </div>
          <button id="btnClearManual" class="btn">Clear manual obstacles</button>
        </div>
      </div>

      <div class="panel" id="panel-teams">
        <div class="panel-head"><div class="h">Team settings</div><span class="chev">â–¾</span></div>
        <div class="panel-body">
          <div class="sub">ðŸŸ¢ Greens</div>
          <div class="grid">
            <div class="label">Count</div>
            <input id="slGCount" type="range" min="2" max="200" value="28"><div class="val" id="lbGCount">28</div>
            <div class="label">Speed</div>
            <input id="slGSpeed" type="range" min="10" max="600" value="260"><div class="val" id="lbGSpeed">2.60</div>
            <div class="label">Awareness</div>
            <input id="slGSmart" type="range" min="0" max="300" value="180"><div class="val" id="lbGSmart">1.80</div>
            <div class="label">Strategy</div>
            <input id="slGStrat" type="range" min="0" max="300" value="140"><div class="val" id="lbGStrat">1.40</div>
            <div class="label">Separation</div>
            <input id="slGSep" type="range" min="0" max="300" value="110"><div class="val" id="lbGSep">1.10</div>
          </div>

          <div class="sub" style="margin-top:14px">ðŸ”´ Reds</div>
          <div class="grid">
            <div class="label">Count</div>
            <input id="slRCount" type="range" min="2" max="200" value="28"><div class="val" id="lbRCount">28</div>
            <div class="label">Speed</div>
            <input id="slRSpeed" type="range" min="10" max="600" value="260"><div class="val" id="lbRSpeed">2.60</div>
            <div class="label">Awareness</div>
            <input id="slRSmart" type="range" min="0" max="300" value="180"><div class="val" id="lbRSmart">1.80</div>
            <div class="label">Strategy</div>
            <input id="slRStrat" type="range" min="0" max="300" value="140"><div class="val" id="lbRStrat">1.40</div>
            <div class="label">Separation</div>
            <input id="slRSep" type="range" min="0" max="300" value="110"><div class="val" id="lbRSep">1.10</div>
          </div>
        </div>
      </div>

      <div class="panel" id="panel-music">
        <div class="panel-head"><div class="h">Ambient Sound Lounge</div><span class="chev">â–¾</span></div>
        <div class="panel-body">
          <p class="music-lead">Slip into focus with a hand-picked selection of calm, looping ambient tracks.</p>
          <div class="music-select">
            <label class="label" for="selMusic">Curated playlist</label>
            <select id="selMusic" class="music-dropdown"></select>
          </div>
          <div class="music-controls">
            <button id="btnMusicToggle" class="btn">Play</button>
            <div class="music-volume">
              <span class="label">Volume</span>
              <input id="slMusicVolume" type="range" min="0" max="100" value="55">
              <span class="val" id="lbMusicVolume">55%</span>
            </div>
          </div>
          <div class="music-meta">
            <div class="music-status"><span id="lbMusicState">Paused</span></div>
            <div id="lbMusicNow" class="music-attr">Choose a track to begin.</div>
            <div id="lbMusicSource" class="music-attr">Royalty-free ambient selections streamed from Pixabay artists.</div>
          </div>
        </div>
      </div>
    </aside>
  </div>
  </main>


<script>
// ===== Utils for UI =====
const Q = (id)=>document.getElementById(id);
function bindRange(sl, lb, fmt=(v)=>v){ const s=Q(sl), l=Q(lb); const apply=()=>{ l.textContent = fmt(+s.value); readParams(); }; s.addEventListener('input', apply); apply(); }

function setRangeValue(id, value){
  const el = Q(id);
  if(!el) return;
  const min = el.min !== undefined ? Number(el.min) : Number(value);
  const max = el.max !== undefined ? Number(el.max) : Number(value);
  const clamped = Math.min(max, Math.max(min, Number(value)));
  if(String(el.value) !== String(clamped)){
    el.value = clamped;
  }
  el.dispatchEvent(new Event('input', { bubbles:true }));
}

// === Make panels collapsible ===
(function makePanelsCollapsible(){
  const panels = document.querySelectorAll('.panel');
  panels.forEach((p)=>{
    const head = p.querySelector('.panel-head');
    if(!head) return;
    head.addEventListener('click', (e)=>{
      // Ignore clicks on inputs inside header (none for now)
      p.classList.toggle('collapsed');
    });
  });
})();

// ===== Colors =====
const COLORS = {
  green: '#00ff91',
  red:   '#ff0055',
  fruit: '#ffd43b',
  goal:  '#3b82f6',
  goalFill: 'rgba(59,130,246,0.18)',
  greenOutline:'#003322',
  redOutline:'#5a001a',
  fruitOutline:'#000'
};

const OBSTACLE_COLORS = ['#38bdf8', '#f472b6', '#2dd4bf'];

function hexToRgba(hex, alpha){
  const h = hex.replace('#','');
  const bigint = parseInt(h,16);
  const r=(bigint>>16)&255;
  const g=(bigint>>8)&255;
  const b=bigint&255;
  return `rgba(${r},${g},${b},${alpha})`;
}

const canvas = document.getElementById('world');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

const TOOL_SELECT='select';
const TOOL_CIRCLE='circle';
const TOOL_RECT='rect';
const TOOL_LINE='line';
const TOOL_HALF='half';

let currentTool = TOOL_SELECT;
let drawingState = null;
let manualPaletteCursor = 0;
let dragRadius = 0;

// ===== Parameters =====
const params = {
  maxFruits: 32,
  spawnMs: 900,
  obstacles: 8,
  tailLen: 24,
  green: { count:28, speed:2.60, smart:1.80, strat:1.40, sep:1.10 },
  red:   { count:28, speed:2.60, smart:1.80, strat:1.40, sep:1.10 },
  learn: { genSteps:2800, mut:0.16, elite:0.20, auto:true }
};
let lastObstCount = params.obstacles;

const MUSIC_TRACKS = [
  {
    title: 'Forest Haze',
    artist: 'FoodSim Ensemble',
    source: 'Procedurally generated drone in C â€“ loops seamlessly offline.',
    duration: 24,
    render: renderForestHaze
  },
  {
    title: 'Cloudlight',
    artist: 'FoodSim Ensemble',
    source: 'Procedurally generated airy chords in F major â€“ works without internet.',
    duration: 20,
    render: renderCloudlight
  },
  {
    title: 'Luminous Air',
    artist: 'FoodSim Ensemble',
    source: 'Procedurally generated evolving pad built into this demo.',
    duration: 26,
    render: renderLuminousAir
  }
];
let currentTrackIndex = 0;
let currentTrackToken = 0;
let currentTrackBuffer = null;
let isMusicPlaying = false;

let currentObjectUrl = null;
let currentObjectUrlToken = 0;

function setCurrentObjectUrl(url){
  clearCurrentObjectUrl();
  currentObjectUrl = url;
  currentObjectUrlToken++;
  return { url, token: currentObjectUrlToken };
}

function clearCurrentObjectUrl(expectedToken=null){
  if(expectedToken != null && expectedToken !== currentObjectUrlToken) return;
  if(currentObjectUrl){
    try{ URL.revokeObjectURL(currentObjectUrl); }catch(_err){ /* ignore */ }
    currentObjectUrl = null;
  }
}

let audioCtx = null;
let masterGain = null;
let currentSource = null;
const trackBufferCache = new Map();
let pendingTrackPromise = null;
let pendingVolume = 0.55;
let musicToggleBtn = null;

function ensureAudioContext(){
  if(audioCtx) return audioCtx;
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  if(!AudioCtx){
    throw new Error('Web Audio API not supported');
  }
  audioCtx = new AudioCtx();
  masterGain = audioCtx.createGain();
  masterGain.gain.value = pendingVolume;
  masterGain.connect(audioCtx.destination);
  return audioCtx;
}

async function resumeAudioContext(){
  const ctx = ensureAudioContext();
  if(ctx.state === 'suspended'){
    await ctx.resume();
  }
  return ctx;
}

function readParams(){
  params.maxFruits = +Q('slFruits').value; Q('lbFruits').textContent=params.maxFruits;
  params.spawnMs = +Q('slSpawn').value; Q('lbSpawn').textContent=params.spawnMs;
  params.obstacles = +Q('slObst').value; Q('lbObst').textContent=params.obstacles; if(params.obstacles !== lastObstCount){ makeObstacles(params.obstacles); lastObstCount = params.obstacles; }
  params.tailLen = +Q('slTail').value; Q('lbTail').textContent=params.tailLen;

  params.green.count = +Q('slGCount').value; Q('lbGCount').textContent=params.green.count;
  params.green.speed = (+Q('slGSpeed').value)/100; Q('lbGSpeed').textContent=params.green.speed.toFixed(2);
  params.green.smart = (+Q('slGSmart').value)/100; Q('lbGSmart').textContent=params.green.smart.toFixed(2);
  params.green.strat = (+Q('slGStrat').value)/100; Q('lbGStrat').textContent=params.green.strat.toFixed(2);
  params.green.sep   = (+Q('slGSep').value)/100; Q('lbGSep').textContent=params.green.sep.toFixed(2);

  params.red.count = +Q('slRCount').value; Q('lbRCount').textContent=params.red.count;
  params.red.speed = (+Q('slRSpeed').value)/100; Q('lbRSpeed').textContent=params.red.speed.toFixed(2);
  params.red.smart = (+Q('slRSmart').value)/100; Q('lbRSmart').textContent=params.red.smart.toFixed(2);
  params.red.strat = (+Q('slRStrat').value)/100; Q('lbRStrat').textContent=params.red.strat.toFixed(2);
  params.red.sep   = (+Q('slRSep').value)/100; Q('lbRSep').textContent=params.red.sep.toFixed(2);

  params.learn.genSteps = +Q('slGenSteps').value; Q('lbGenSteps').textContent=params.learn.genSteps;
  params.learn.mut = (+Q('slMut').value)/100; Q('lbMut').textContent=Math.round(params.learn.mut*100);
  params.learn.elite = (+Q('slElite').value)/100; Q('lbElite').textContent=params.learn.elite.toFixed(2);
  params.learn.auto = Q('chkAuto').checked; Q('lbAuto').textContent = params.learn.auto? 'on':'off';
  if(params.learn.auto && awaitingManualAdvance){
    forceNextGen = true;
  }
}
function updateMusicMeta(track, stateOverride=null){
  if(!track) return;
  const state = stateOverride || (isMusicPlaying ? 'Playing' : 'Paused');
  Q('lbMusicState').textContent = state;
  Q('lbMusicNow').textContent = `${track.title} â€” ${track.artist}`;
  Q('lbMusicSource').textContent = track.source;
}

let awaitingAudioUnlock = false;

function updateMusicButton(){
  if(!musicToggleBtn) return;
  musicToggleBtn.textContent = isMusicPlaying ? 'Pause' : 'Play';
  musicToggleBtn.setAttribute('aria-pressed', isMusicPlaying ? 'true' : 'false');
}

function stopCurrentTrack(silent=false){
  if(currentSource){
    try{ currentSource.stop(); }catch(err){ /* ignore stop errors */ }
    currentSource.disconnect();
    currentSource = null;
  }
  isMusicPlaying = false;
  if(!silent){
    updateMusicMeta(MUSIC_TRACKS[currentTrackIndex], 'Paused');
    updateMusicButton();
  }
}

function createAudioBuffer(channels, length, sampleRate){
  if(typeof AudioBuffer === 'function'){
    return new AudioBuffer({ numberOfChannels: channels, length, sampleRate });
  }
  const OfflineCtx = window.OfflineAudioContext || window.webkitOfflineAudioContext;
  if(OfflineCtx){
    const offline = new OfflineCtx(channels, length, sampleRate);
    return offline.createBuffer(channels, length, sampleRate);
  }
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  if(AudioCtx){
    const tempCtx = new AudioCtx();
    const buffer = tempCtx.createBuffer(channels, length, sampleRate);
    if(typeof tempCtx.close === 'function') tempCtx.close();
    return buffer;
  }
  throw new Error('Web Audio API not supported');
}

async function ensureTrackBuffer(track, sampleRate){
  let buffersForRate = trackBufferCache.get(sampleRate);
  if(!buffersForRate){
    buffersForRate = new Map();
    trackBufferCache.set(sampleRate, buffersForRate);
  }
  if(buffersForRate.has(track)) return buffersForRate.get(track);
  const buffer = generateProceduralBuffer(track, sampleRate);
  buffersForRate.set(track, buffer);
  return buffer;
}

function generateProceduralBuffer(track, sampleRate){
  const duration = Math.max(4, track.duration || 20);
  const length = Math.max(1, Math.floor(duration * sampleRate));
  const buffer = createAudioBuffer(2, length, sampleRate);
  const left = buffer.getChannelData(0);
  const right = buffer.getChannelData(1);
  track.render(left, right, sampleRate, duration);
  return buffer;
}

function requestAudioUnlock(){
  if(awaitingAudioUnlock) return;
  awaitingAudioUnlock = true;
  const resume = async ()=>{
    document.removeEventListener('pointerdown', resume);
    document.removeEventListener('keydown', resume);
    awaitingAudioUnlock = false;
    try{
      await playCurrentTrack();
    }catch(err){
      handlePlaybackFailure(err, MUSIC_TRACKS[currentTrackIndex]);
    }
  };
  document.addEventListener('pointerdown', resume, { once:true });
  document.addEventListener('keydown', resume, { once:true });
}

function handlePlaybackFailure(err, track){
  if(!err) return;
  const activeTrack = track || MUSIC_TRACKS[currentTrackIndex];
  isMusicPlaying = false;
  if(err.name === 'NotAllowedError' || err.name === 'SecurityError'){
    updateMusicMeta(activeTrack, 'Tap to enable audio');
    updateMusicButton();
    requestAudioUnlock();
    console.warn('Music playback is blocked until the page receives a user interaction.', err);
  } else if(err.message === 'Web Audio API not supported' || err.name === 'NotSupportedError'){
    updateMusicMeta(activeTrack, 'Audio unavailable');
    Q('lbMusicNow').textContent = 'This browser cannot synthesize the selected track.';
    updateMusicButton();
    console.error('Music playback failed', err);
  } else {
    updateMusicMeta(activeTrack, 'Playback failed');
    updateMusicButton();
    console.error('Music playback failed', err);
  }
}

async function playCurrentTrack(){
  const track = MUSIC_TRACKS[currentTrackIndex];
  try{
    const ctx = await resumeAudioContext();
    const buffer = await ensureTrackBuffer(track, ctx.sampleRate);
    currentTrackBuffer = buffer;
    stopCurrentTrack(true);
    const source = ctx.createBufferSource();
    source.buffer = buffer;
    source.loop = true;
    source.connect(masterGain);
    source.start();
    currentSource = source;
    isMusicPlaying = true;
    source.addEventListener('ended', ()=>{
      if(currentSource === source){
        isMusicPlaying = false;
        updateMusicMeta(track, 'Paused');
        updateMusicButton();
      }
    });
    updateMusicMeta(track, 'Playing');
    updateMusicButton();
  }catch(err){
    handlePlaybackFailure(err, track);
    throw err;
  }
}

async function setMusicTrack(index, autoplay=false){
  if(index<0 || index>=MUSIC_TRACKS.length) return;
  const track = MUSIC_TRACKS[index];
  const shouldAutoplay = autoplay || isMusicPlaying;
  currentTrackIndex = index;
  const token = ++currentTrackToken;

  stopCurrentTrack(true);
  updateMusicButton();
  updateMusicMeta(track, 'Preparingâ€¦');

  let sampleRate = 44100;
  try{
    const ctx = ensureAudioContext();
    sampleRate = ctx.sampleRate || sampleRate;
  }catch(err){
    handlePlaybackFailure(err, track);
    return;
  }

  const promise = ensureTrackBuffer(track, sampleRate)
    .then(async buffer => {
      if(token !== currentTrackToken) return;
      currentTrackBuffer = buffer;
      if(shouldAutoplay){
        await playCurrentTrack();
      } else {
        isMusicPlaying = false;
        updateMusicMeta(track, 'Ready');
        updateMusicButton();
      }
    })
    .catch(err => {
      handlePlaybackFailure(err, track);
    })
    .finally(()=>{
      if(token === currentTrackToken){
        pendingTrackPromise = null;
      }
    });

  pendingTrackPromise = promise;
  return promise;
}

function initMusicPanel(){
  const select = Q('selMusic');
  musicToggleBtn = Q('btnMusicToggle');
  const vol = Q('slMusicVolume');
  const volLabel = Q('lbMusicVolume');

  MUSIC_TRACKS.forEach((track, idx)=>{
    const opt = document.createElement('option');
    opt.value = idx;
    opt.textContent = `${track.title} â€” ${track.artist}`;
    select.appendChild(opt);
  });
  select.value = String(currentTrackIndex);

  const applyVolume = ()=>{
    const value = Math.round(vol.value);
    pendingVolume = value/100;
    if(masterGain){
      masterGain.gain.setValueAtTime(pendingVolume, masterGain.context.currentTime);
    }
    volLabel.textContent = `${value}%`;
  };
  applyVolume();
  vol.addEventListener('input', applyVolume);

  musicToggleBtn.addEventListener('click', async ()=>{
    if(isMusicPlaying){
      stopCurrentTrack();
    } else {
      musicToggleBtn.disabled = true;
      try{
        await playCurrentTrack();
      }catch(err){
        // handled in playCurrentTrack
      }finally{
        musicToggleBtn.disabled = false;
      }
    }
  });

  select.addEventListener('change', ()=>{
    const idx = parseInt(select.value, 10);
    setMusicTrack(idx, isMusicPlaying);
  });

  updateMusicButton();
  setMusicTrack(currentTrackIndex, false);
}

const TAU = Math.PI * 2;

function seededNoise(idx, offset=0){
  const x = Math.sin((idx + offset) * 12.9898) * 43758.5453123;
  return (x - Math.floor(x)) * 2 - 1;
}

function applyStereoFadeEnvelope(left, right, sampleRate, seconds){
  const fadeSamples = Math.min(Math.floor(seconds * sampleRate), Math.floor(left.length/2));
  if(fadeSamples <= 0) return;
  const total = left.length;
  for(let i=0; i<total; i++){
    let gain = 1;
    if(i < fadeSamples){
      gain *= i / fadeSamples;
    }
    if(total - i < fadeSamples){
      gain *= (total - i) / fadeSamples;
    }
    left[i] *= gain;
    right[i] *= gain;
  }
}

function normalizeStereo(left, right, target=0.82){
  let peak = 0;
  for(let i=0;i<left.length;i++){
    const l = Math.abs(left[i]);
    const r = Math.abs(right[i]);
    if(l>peak) peak=l;
    if(r>peak) peak=r;
  }
  if(peak > 0){
    const scale = target/peak;
    for(let i=0;i<left.length;i++){
      left[i] *= scale;
      right[i] *= scale;
    }
  }
}

function renderForestHaze(left, right, sampleRate, duration){
  const total = left.length;
  for(let i=0;i<total;i++){
    const t = i / sampleRate;
    const slow = Math.sin(t * 0.045 * TAU);
    const slow2 = Math.sin(t * 0.062 * TAU + 1.3);
    const voiceA = Math.sin(TAU * (110 + slow * 2.5) * t);
    const voiceB = Math.sin(TAU * (165 + slow2 * 2.0) * t + 0.6);
    const voiceC = Math.sin(TAU * (220 + Math.sin(t * 0.018 * TAU) * 3.5) * t + 1.1);
    const shimmer = Math.sin(TAU * (55 + Math.sin(t * 0.01 * TAU) * 4) * t) * 0.35;
    const noise = seededNoise(i, 4.2) * 0.06 * (0.4 + 0.6 * Math.sin(t * 0.08 * TAU + 2));
    const pad = (voiceA * 0.5 + voiceB * 0.42 + voiceC * 0.36 + shimmer * 0.28) * 0.48 + noise;
    const pan = Math.sin(t * 0.017 * TAU + 2.1) * 0.32;
    left[i] = pad * (1 - pan);
    right[i] = pad * (1 + pan);
  }
  applyStereoFadeEnvelope(left, right, sampleRate, 2.6);
  normalizeStereo(left, right, 0.68);
}

function renderCloudlight(left, right, sampleRate, duration){
  const total = left.length;
  const voices = [349.23, 440.0, 523.25];
  const weights = [0.46, 0.34, 0.28];
  for(let i=0;i<total;i++){
    const t = i / sampleRate;
    let l=0, r=0;
    const pulse = 0.55 + 0.45 * Math.sin(t * 0.12 * TAU);
    for(let v=0; v<voices.length; v++){
      const detune = Math.sin(t * (0.03 + v*0.018) * TAU + v) * 3.5;
      const freq = voices[v] + detune;
      const voice = Math.sin(TAU * freq * t + v * 0.8);
      const pan = (v - 1) * 0.35 + Math.sin(t * 0.05 * TAU + v) * 0.12;
      const amp = weights[v] * pulse;
      l += voice * amp * (1 - pan);
      r += voice * amp * (1 + pan);
    }
    const sparkle = seededNoise(i * 1.7, 8.2) * 0.045 * (0.35 + 0.65 * Math.sin(t * 0.42 * TAU));
    left[i] = l + sparkle;
    right[i] = r + sparkle * 0.85;
  }
  applyStereoFadeEnvelope(left, right, sampleRate, 1.6);
  normalizeStereo(left, right, 0.74);
}

function renderLuminousAir(left, right, sampleRate, duration){
  const total = left.length;
  for(let i=0;i<total;i++){
    const t = i / sampleRate;
    const drift = Math.sin(t * 0.022 * TAU);
    const voiceA = Math.sin(TAU * (196 + drift * 5) * t) * 0.55;
    const voiceB = Math.sin(TAU * (294 + Math.sin(t * 0.019 * TAU + 2) * 7) * t + 1.2) * 0.48;
    const airy = Math.sin(TAU * (147 + Math.sin(t * 0.083 * TAU) * 2.5) * t + 2.6) * 0.42;
    const mod = 0.6 + 0.4 * Math.sin(t * 0.07 * TAU + 1.7);
    const pad = (voiceA + voiceB + airy) * 0.32 * mod;
    const breath = seededNoise(i * 0.9, 1.7) * 0.055 * (0.3 + 0.7 * Math.sin(t * 0.11 * TAU));
    const shimmer = Math.sin(TAU * (880 + Math.sin(t * 0.5 * TAU) * 18) * t) * 0.028;
    const pan = Math.sin(t * 0.026 * TAU + 0.5) * 0.38;
    left[i] = pad * (1 - pan) + breath + shimmer * 0.6;
    right[i] = pad * (1 + pan) + breath * 0.92 + shimmer;
  }
  applyStereoFadeEnvelope(left, right, sampleRate, 2.8);
  normalizeStereo(left, right, 0.7);
}

// ===== Data structures =====
const greens=[], reds=[], fruits=[], obstacles=[];

// Pheromone grid â€“ separate fields per team
let grid, GW, GH, CS = 22; // cell size
function makeGrid(){ GW=Math.floor(W/CS); GH=Math.floor(H/CS);
  grid={ foodG:new Float32Array(GW*GH), homeG:new Float32Array(GW*GH), foodR:new Float32Array(GW*GH), homeR:new Float32Array(GW*GH) };
}
const gi=(x,y)=> y*GW + x;
const clampi=(v,a,b)=> v<a?a:(v>b?b:v);
function deposit(field,x,y,amt){ const cx=clampi((x/CS)|0,0,GW-1), cy=clampi((y/CS)|0,0,GH-1); grid[field][gi(cx,cy)] += amt; }
function senseGrad(field,x,y){ const cx=clampi((x/CS)|0,0,GW-1), cy=clampi((y/CS)|0,0,GH-1); let best=-1e9,bx=cx,by=cy; for(let dy=-1;dy<=1;dy++) for(let dx=-1;dx<=1;dx++){ const nx=clampi(cx+dx,0,GW-1), ny=clampi(cy+dy,0,GH-1); const v=grid[field][gi(nx,ny)]; if(v>best){best=v; bx=nx; by=ny;} } return {gx:(bx-cx), gy:(by-cy), val:grid[field][gi(bx,by)]}; }
function evaporate(){ const keep=0.985; const names=['foodG','homeG','foodR','homeR']; const tmps={}; for(const n of names) tmps[n]=new Float32Array(GW*GH); for(const n of names){ const src=grid[n], dst=tmps[n]; for(let y=0;y<GH;y++){ for(let x=0;x<GW;x++){ let v=src[gi(x,y)]*keep; let sum=v*0.4; let cnt=0; for(let dy=-1;dy<=1;dy++) for(let dx=-1;dx<=1;dx++) if(dx||dy){ const nx=clampi(x+dx,0,GW-1), ny=clampi(y+dy,0,GH-1); sum += src[gi(nx,ny)]*0.075; cnt++; } dst[gi(x,y)]= sum/(0.4+0.075*cnt); } } } for(const n of names) grid[n]=tmps[n]; }

// Goals â€“ one per team (draggable)
const goalG={ x:W*0.86, y:H*0.35, r:34, delivered:0 },
      goalR={ x:W*0.14, y:H*0.65, r:34, delivered:0 };
let dragTarget=null, dragDX=0, dragDY=0, dragKind=null, dragIndex=-1;

function getCanvasCoords(evt){
  const rect = canvas.getBoundingClientRect();
  return {
    x: evt.clientX - rect.left,
    y: evt.clientY - rect.top
  };
}

function obstacleHitTest(o, px, py, tolerance=8){
  switch(o.type){
    case 'rect':{
      const halfW = o.width/2 + tolerance;
      const halfH = o.height/2 + tolerance;
      return Math.abs(px - o.x) <= halfW && Math.abs(py - o.y) <= halfH;
    }
    case 'line':{
      const t = distanceToSegment(px, py, o.x1, o.y1, o.x2, o.y2);
      const radius = (o.thickness||12)/2 + tolerance;
      return t.distance <= radius;
    }
    case 'half':{
      const dx = px - o.x;
      const dy = py - o.y;
      const radius = o.r + tolerance;
      const dist = Math.hypot(dx, dy);
      if(dist > radius) return false;
      const facingX = Math.cos(o.angle);
      const facingY = Math.sin(o.angle);
      const proj = dx*facingX + dy*facingY;
      if(proj >= -tolerance) return true;
      const perpX = -facingY;
      const perpY = facingX;
      const ax = o.x - perpX * o.r;
      const ay = o.y - perpY * o.r;
      const bx = o.x + perpX * o.r;
      const by = o.y + perpY * o.r;
      const seg = distanceToSegment(px, py, ax, ay, bx, by);
      return seg.distance <= tolerance;
    }
    default:{
      const r = typeof o.r === 'number' ? o.r : Math.max(16, (o.hitRadius||20));
      return Math.hypot(px - o.x, py - o.y) <= r + tolerance;
    }
  }
}

function getObstacleRadius(o){
  switch(o.type){
    case 'rect':
      return Math.hypot(o.width, o.height) * 0.5;
    case 'line':{
      const halfLen = Math.hypot(o.x2 - o.x1, o.y2 - o.y1) * 0.5;
      return halfLen + (o.thickness||12)/2;
    }
    case 'half':
      return o.r;
    default:
      return o.r || 24;
  }
}

function getObstacleExtents(o){
  switch(o.type){
    case 'rect':
      return { hx:o.width/2, hy:o.height/2 };
    case 'line':{
      const halfWidth = (o.thickness||12)/2;
      const halfDx = Math.abs(o.x2 - o.x1)/2;
      const halfDy = Math.abs(o.y2 - o.y1)/2;
      return { hx:halfDx + halfWidth, hy:halfDy + halfWidth };
    }
    case 'half':
      return { hx:o.r, hy:o.r };
    default:
      const r = o.r || 20;
      return { hx:r, hy:r };
  }
}

function moveObstacleTo(o, nx, ny){
  const dx = nx - o.x;
  const dy = ny - o.y;
  o.x = nx;
  o.y = ny;
  if(o.type === 'line'){
    o.x1 += dx; o.y1 += dy;
    o.x2 += dx; o.y2 += dy;
  }
}

function distanceToSegment(px, py, x1, y1, x2, y2){
  const vx = x2 - x1;
  const vy = y2 - y1;
  const lenSq = vx*vx + vy*vy;
  let t = 0;
  if(lenSq > 0){
    t = ((px - x1)*vx + (py - y1)*vy) / lenSq;
    t = Math.max(0, Math.min(1, t));
  }
  const cx = x1 + vx*t;
  const cy = y1 + vy*t;
  const dx = px - cx;
  const dy = py - cy;
  const dist = Math.hypot(dx, dy);
  const inv = dist>0 ? 1/dist : 0;
  return { distance:dist, cx, cy, nx:dx*inv, ny:dy*inv };
}

function clampObstacleCenter(o, cx, cy){
  const ext = getObstacleExtents(o);
  const hx = ext.hx || 0;
  const hy = ext.hy || 0;
  const minX = hx + 4;
  const maxX = W - hx - 4;
  const minY = hy + 4;
  const maxY = H - hy - 4;
  return {
    x: Math.max(minX, Math.min(maxX, cx)),
    y: Math.max(minY, Math.min(maxY, cy))
  };
}

function keepObstacleInside(o){
  const clamped = clampObstacleCenter(o, o.x, o.y);
  moveObstacleTo(o, clamped.x, clamped.y);
}

function buildObstacleFromState(state, preview=false){
  if(!state) return null;
  const { tool, startX, startY, currentX, currentY } = state;
  const dx = currentX - startX;
  const dy = currentY - startY;
  switch(tool){
    case TOOL_CIRCLE:{
      const radius = Math.hypot(dx, dy);
      if(!preview && radius < 12) return null;
      if(preview && radius < 2) return null;
      return { type:'circle', x:startX, y:startY, r: Math.max(radius, preview?radius:12) };
    }
    case TOOL_RECT:{
      const width = Math.abs(dx);
      const height = Math.abs(dy);
      if(!preview && (width < 16 || height < 16)) return null;
      if(preview && (width < 2 && height < 2)) return null;
      const cx = (startX + currentX) / 2;
      const cy = (startY + currentY) / 2;
      return { type:'rect', x:cx, y:cy, width: Math.max(width, preview?width:16), height: Math.max(height, preview?height:16) };
    }
    case TOOL_LINE:{
      const length = Math.hypot(dx, dy);
      if(!preview && length < 24) return null;
      if(preview && length < 4) return null;
      const cx = (startX + currentX) / 2;
      const cy = (startY + currentY) / 2;
      return {
        type:'line',
        x:cx,
        y:cy,
        x1:startX,
        y1:startY,
        x2:currentX,
        y2:currentY,
        thickness:14
      };
    }
    case TOOL_HALF:{
      const radius = Math.hypot(dx, dy);
      if(!preview && radius < 18) return null;
      if(preview && radius < 4) return null;
      const angle = Math.atan2(dy, dx);
      return { type:'half', x:startX, y:startY, r: Math.max(radius, preview?radius:18), angle };
    }
    default:
      return null;
  }
}

function createCircleObstacle(x, y, r, paletteIndex=0, manual=false){
  return { type:'circle', x, y, r, paletteIndex, phase:Math.random()*Math.PI*2, manual };
}

canvas.addEventListener('mousedown', (e)=>{
  const {x, y} = getCanvasCoords(e);
  if(currentTool !== TOOL_SELECT){
    drawingState = { tool:currentTool, startX:x, startY:y, currentX:x, currentY:y };
    return;
  }
  dragTarget=null; dragKind=null; dragIndex=-1; dragRadius=0;
  for(let i=obstacles.length-1; i>=0; i--){
    const o=obstacles[i];
    if(obstacleHitTest(o, x, y)){
      dragTarget=o; dragKind='obst'; dragIndex=i; dragDX=o.x - x; dragDY=o.y - y; dragRadius=getObstacleRadius(o); return;
    }
  }
  if(Math.hypot(x-goalG.x,y-goalG.y) <= goalG.r+12){ dragTarget=goalG; dragKind='goalG'; dragDX=goalG.x-x; dragDY=goalG.y-y; return; }
  if(Math.hypot(x-goalR.x,y-goalR.y) <= goalR.r+12){ dragTarget=goalR; dragKind='goalR'; dragDX=goalR.x-x; dragDY=goalR.y-y; return; }
});

window.addEventListener('mousemove', (e)=>{
  const {x, y} = getCanvasCoords(e);
  if(drawingState){
    drawingState.currentX = x;
    drawingState.currentY = y;
  }
  if(!dragTarget) return;
  if(dragKind==='obst'){
    const desiredX = x + dragDX;
    const desiredY = y + dragDY;
    const clamped = clampObstacleCenter(dragTarget, desiredX, desiredY);
    if(!obstacleOverlaps(clamped.x, clamped.y, dragRadius, dragIndex)){
      moveObstacleTo(dragTarget, clamped.x, clamped.y);
    }
  } else {
    const nx = Math.max(dragTarget.r+8, Math.min(W - dragTarget.r - 8, x + dragDX));
    const ny = Math.max(dragTarget.r+8, Math.min(H - dragTarget.r - 8, y + dragDY));
    dragTarget.x = nx;
    dragTarget.y = ny;
  }
});

window.addEventListener('mouseup', ()=>{
  if(drawingState){
    const created = buildObstacleFromState(drawingState);
    if(created){
      const paletteIndex = manualPaletteCursor % OBSTACLE_COLORS.length;
      created.manual = true;
      created.paletteIndex = paletteIndex;
      created.phase = Math.random()*Math.PI*2;
      manualPaletteCursor = (manualPaletteCursor + 1) % OBSTACLE_COLORS.length;
      keepObstacleInside(created);
      obstacles.push(created);
    }
    drawingState = null;
  }
  dragTarget=null; dragKind=null; dragIndex=-1; dragRadius=0;
});

// Utils
function rand(a,b){ return a + Math.random()*(b-a); }
function nearest(arr,x,y){ if(!arr.length) return null; let best=arr[0],bd=1e9; for(const o of arr){ const d=Math.hypot(o.x-x,o.y-y); if(d<bd){bd=d; best=o;} } return best; }
const OBSTACLE_PADDING = 12;
function obstacleOverlaps(x,y,r, ignoreIndex=-1){
  for(let i=0;i<obstacles.length;i++){
    if(i===ignoreIndex) continue;
    const o=obstacles[i];
    const otherR = getObstacleRadius(o);
    if(Math.hypot(x-o.x,y-o.y) < r + otherR + OBSTACLE_PADDING) return true;
  }
  return false;
}

function isPointInsideObstacle(o, x, y, padding=0){
  switch(o.type){
    case 'rect':{
      const halfW = o.width/2 + padding;
      const halfH = o.height/2 + padding;
      return Math.abs(x - o.x) <= halfW && Math.abs(y - o.y) <= halfH;
    }
    case 'line':{
      const seg = distanceToSegment(x, y, o.x1, o.y1, o.x2, o.y2);
      const radius = (o.thickness||14)/2 + padding;
      return seg.distance <= radius;
    }
    case 'half':{
      const dx = x - o.x;
      const dy = y - o.y;
      const radius = o.r + padding;
      const dist = Math.hypot(dx, dy);
      if(dist <= radius){
        const facingX = Math.cos(o.angle);
        const facingY = Math.sin(o.angle);
        const proj = dx*facingX + dy*facingY;
        if(proj >= -padding) return true;
      }
      const perpX = -Math.sin(o.angle);
      const perpY = Math.cos(o.angle);
      const ax = o.x - perpX * o.r;
      const ay = o.y - perpY * o.r;
      const bx = o.x + perpX * o.r;
      const by = o.y + perpY * o.r;
      const seg = distanceToSegment(x, y, ax, ay, bx, by);
      return seg.distance <= padding;
    }
    default:
      return Math.hypot(x-o.x,y-o.y) <= (o.r || getObstacleRadius(o)) + padding;
  }
}

function pointInsideObstacle(x,y){
  for(const o of obstacles){
    if(isPointInsideObstacle(o, x, y, 7)) return true;
  }
  return false;
}

function obstacleClearance(o, px, py){
  const margin = 8;
  switch(o.type){
    case 'rect':{
      const halfW = o.width/2 + margin;
      const halfH = o.height/2 + margin;
      const dx = px - o.x;
      const dy = py - o.y;
      const ax = Math.abs(dx) - halfW;
      const ay = Math.abs(dy) - halfH;
      if(ax <= 0 && ay <= 0){
        if(ax > ay){
          const nx = Math.sign(dx) || 1;
          return { distance: ax, nx, ny:0 };
        } else {
          const ny = Math.sign(dy) || 1;
          return { distance: ay, nx:0, ny };
        }
      }
      const outsideX = Math.max(ax, 0);
      const outsideY = Math.max(ay, 0);
      const dist = Math.hypot(outsideX, outsideY);
      let nx = 0, ny = 0;
      if(dist > 0){
        nx = outsideX ? (outsideX/dist) * Math.sign(dx || 1) : 0;
        ny = outsideY ? (outsideY/dist) * Math.sign(dy || 1) : 0;
      } else {
        if(ax > 0) nx = Math.sign(dx) || 1;
        if(ay > 0) ny = Math.sign(dy) || 1;
      }
      return { distance: dist, nx, ny };
    }
    case 'line':{
      const seg = distanceToSegment(px, py, o.x1, o.y1, o.x2, o.y2);
      const radius = (o.thickness||14)/2 + margin;
      let nx = seg.nx;
      let ny = seg.ny;
      if(seg.distance === 0){
        const vx = o.x2 - o.x1;
        const vy = o.y2 - o.y1;
        const len = Math.hypot(vx, vy) || 1;
        nx = -vy / len;
        ny = vx / len;
        const midX = (o.x1 + o.x2) / 2;
        const midY = (o.y1 + o.y2) / 2;
        if((px - midX)*nx + (py - midY)*ny < 0){
          nx = -nx;
          ny = -ny;
        }
      }
      return { distance: seg.distance - radius, nx, ny };
    }
    case 'half':{
      const dx = px - o.x;
      const dy = py - o.y;
      const facingX = Math.cos(o.angle);
      const facingY = Math.sin(o.angle);
      const proj = dx*facingX + dy*facingY;
      if(proj >= 0){
        const dist = Math.hypot(dx, dy);
        const radius = o.r + margin;
        const inv = dist>0 ? 1/dist : 0;
        const nx = inv>0 ? dx*inv : facingX;
        const ny = inv>0 ? dy*inv : facingY;
        return { distance: dist - radius, nx, ny };
      }
      const perpX = -Math.sin(o.angle);
      const perpY = Math.cos(o.angle);
      const ax = o.x - perpX * o.r;
      const ay = o.y - perpY * o.r;
      const bx = o.x + perpX * o.r;
      const by = o.y + perpY * o.r;
      const seg = distanceToSegment(px, py, ax, ay, bx, by);
      let nx = seg.nx;
      let ny = seg.ny;
      if(seg.distance === 0){
        nx = facingX;
        ny = facingY;
      }
      return { distance: seg.distance - margin, nx, ny };
    }
    default:{
      const dx = px - o.x;
      const dy = py - o.y;
      const dist = Math.hypot(dx, dy);
      const radius = (o.r || getObstacleRadius(o)) + margin;
      const inv = dist>0 ? 1/dist : 0;
      const nx = inv>0 ? dx*inv : 1;
      const ny = inv>0 ? dy*inv : 0;
      return { distance: dist - radius, nx, ny };
    }
  }
}
function findFreeFruitSpot(maxTry=80){ for(let i=0;i<maxTry;i++){ const x=rand(40,W-40), y=rand(40,H-40); if(!pointInsideObstacle(x,y)) return {x,y}; } return null; }
function spawnFruit(x=null,y=null){ if(fruits.length>=params.maxFruits) return; if(x==null||y==null){ const pos=findFreeFruitSpot(); if(!pos) return; x=pos.x; y=pos.y; } if(pointInsideObstacle(x,y)){ const pos=findFreeFruitSpot(); if(!pos) return; x=pos.x; y=pos.y; } fruits.push({x,y,r:6,color:COLORS.fruit}); }
function makeObstacles(n){
  const manual = obstacles.filter(o=>o.manual);
  obstacles.length = 0;
  for(const m of manual){
    obstacles.push(m);
  }
  const paletteLen=OBSTACLE_COLORS.length;
  for(let i=0;i<n;i++){
    let r=rand(16,40);
    let placed=false;
    for(let tries=0; tries<420 && !placed; tries++){
      if(tries===240) r=Math.max(12,r*0.85);
      if(tries===360) r=Math.max(10,r*0.85);
      const x=rand(80,W-80);
      const y=rand(60,H-60);
      if(Math.hypot(x-goalG.x,y-goalG.y)<goalG.r+r+40) continue;
      if(Math.hypot(x-goalR.x,y-goalR.y)<goalR.r+r+40) continue;
      if(obstacleOverlaps(x,y,r)) continue;
      obstacles.push(createCircleObstacle(x,y,r,i%paletteLen,false));
      placed=true;
    }
    if(!placed){
      const step=36;
      outer: for(let gy=60; gy<=H-60 && !placed; gy+=step){
        for(let gx=80; gx<=W-80; gx+=step){
          if(Math.hypot(gx-goalG.x,gy-goalG.y)<goalG.r+r+40) continue;
          if(Math.hypot(gx-goalR.x,gy-goalR.y)<goalR.r+r+40) continue;
          if(obstacleOverlaps(gx,gy,r)) continue;
          obstacles.push(createCircleObstacle(gx,gy,r,i%paletteLen,false));
          placed=true;
          break outer;
        }
      }
    }
    if(!placed){
      const fallback = obstacles[obstacles.length-1] || {x:W*0.5,y:H*0.5,r:20};
      let angle=Math.random()*TAU;
      let dist=getObstacleRadius(fallback) + r + OBSTACLE_PADDING + 4;
      for(let steps=0; steps<60 && !placed; steps++){
        const x=Math.max(r+4, Math.min(W-r-4, fallback.x + Math.cos(angle)*dist));
        const y=Math.max(r+4, Math.min(H-r-4, fallback.y + Math.sin(angle)*dist));
        if(obstacleOverlaps(x,y,r)){
          dist += r*0.35 + OBSTACLE_PADDING;
          angle += 0.4;
          continue;
        }
        obstacles.push(createCircleObstacle(x,y,r,i%paletteLen,false));
        placed=true;
      }
    }
    if(!placed){
      const smallR = Math.max(10, r*0.8);
      for(let tries=0; tries<240 && !placed; tries++){
        const x=rand(80,W-80);
        const y=rand(60,H-60);
        if(Math.hypot(x-goalG.x,y-goalG.y)<goalG.r+smallR+32) continue;
        if(Math.hypot(x-goalR.x,y-goalR.y)<goalR.r+smallR+32) continue;
        if(obstacleOverlaps(x,y,smallR)) continue;
        obstacles.push(createCircleObstacle(x,y,smallR,i%paletteLen,false));
        placed=true;
      }
    }
  }
}



// ===== NEATâ€‘lite (7â†’16â†’2) =====
function randn(){ let u=0,v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random(); return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v); }
function matmulVec(W, x, out){ const rows=W.length, cols=W[0].length; for(let i=0;i<rows;i++){ let s=0; const Wi=W[i]; for(let j=0;j<cols;j++) s+=Wi[j]*x[j]; out[i]=s; } return out; }
function tanhVec(v){ for(let i=0;i<v.length;i++) v[i]=Math.tanh(v[i]); return v; }
function addBias(v,b){ for(let i=0;i<v.length;i++) v[i]+=b[i]; return v; }
function makeNet(inDim=7,h=16,out=2){ return { W1:Array.from({length:h},()=>Array.from({length:inDim},()=> (Math.random()*2-1)*0.5)), b1:Array.from({length:h},()=> (Math.random()*2-1)*0.2), W2:Array.from({length:out},()=>Array.from({length:h},()=> (Math.random()*2-1)*0.5)), b2:Array.from({length:out},()=> (Math.random()*2-1)*0.2) }; }
function cloneNet(n){ return { W1:n.W1.map(r=>r.slice()), b1:n.b1.slice(), W2:n.W2.map(r=>r.slice()), b2:n.b2.slice() }; }
function mutateNet(n, rate){ const sW=0.2, sB=0.2; for(const r of n.W1) for(let i=0;i<r.length;i++) if(Math.random()<rate) r[i]+=randn()*sW; for(let i=0;i<n.b1.length;i++) if(Math.random()<rate) n.b1[i]+=randn()*sB; for(const r of n.W2) for(let i=0;i<r.length;i++) if(Math.random()<rate) r[i]+=randn()*sW; for(let i=0;i<n.b2.length;i++) if(Math.random()<rate) n.b2[i]+=randn()*sB; }
function crossover(a,b){ const c=cloneNet(a); for(let i=0;i<c.W1.length;i++) for(let j=0;j<c.W1[0].length;j++) c.W1[i][j]=(Math.random()<0.5?a.W1[i][j]:b.W1[i][j]); for(let i=0;i<c.b1.length;i++) c.b1[i]=(Math.random()<0.5?a.b1[i]:b.b1[i]); for(let i=0;i<c.W2.length;i++) for(let j=0;j<c.W2[0].length;j++) c.W2[i][j]=(Math.random()<0.5?a.W2[i][j]:b.W2[i][j]); for(let i=0;i<c.b2.length;i++) c.b2[i]=(Math.random()<0.5?a.b2[i]:b.b2[i]); return c; }
function forward(n, x){ const h=new Array(n.b1.length).fill(0), o=new Array(n.b2.length).fill(0); matmulVec(n.W1,x,h); addBias(h,n.b1); tanhVec(h); matmulVec(n.W2,h,o); addBias(o,n.b2); tanhVec(o); return o; }
function makePopulation(size){ return Array.from({length:size}, ()=> ({ net:makeNet(), fitness:0 })); }
const evo = { gen:1, G: makePopulation(28), R: makePopulation(28) };
function resizePop(){ if(evo.G.length!==params.green.count){ if(evo.G.length<params.green.count){ while(evo.G.length<params.green.count) evo.G.push({ net:makeNet(), fitness:0 }); } else { evo.G.length=params.green.count; } } if(evo.R.length!==params.red.count){ if(evo.R.length<params.red.count){ while(evo.R.length<params.red.count) evo.R.push({ net:makeNet(), fitness:0 }); } else { evo.R.length=params.red.count; } } }
function nextGeneration(team){ const pop=evo[team]; pop.sort((a,b)=> b.fitness - a.fitness); const eliteN=Math.max(1, Math.floor(pop.length*params.learn.elite)); const elites=pop.slice(0,eliteN).map(e=> cloneNet(e.net)); const best=pop[0]?.fitness||0; if(team==='G') Q('lbBestG').textContent=best.toFixed(0); else Q('lbBestR').textContent=best.toFixed(0); const newPop=[]; for(let i=0;i<eliteN;i++) newPop.push({ net:cloneNet(elites[i]), fitness:0 }); function pick(){ const k=Math.min(pop.length, Math.max(2,eliteN*2)); const a=pop[Math.floor(Math.random()*k)], b=pop[Math.floor(Math.random()*k)]; return (a.fitness>b.fitness?a:b).net; } while(newPop.length<pop.length){ const pa=pick(), pb=pick(); let child=crossover(pa,pb); mutateNet(child, params.learn.mut); newPop.push({ net:child, fitness:0 }); } for(let i=0;i<pop.length;i++){ pop[i].net=newPop[i].net; pop[i].fitness=0; } }

// ===== Agent core =====
class Agent{
  constructor(x,y,color,maxSpeed,team){ this.x=x; this.y=y; this.vx=rand(-1,1); this.vy=rand(-1,1); this.color=color; this.maxSpeed=maxSpeed; this.trail=[]; this.carry=false; this.team=team; this.side=Math.random()<0.5?-1:1; this.stuckT=0; this.wander={x:rand(-1,1), y:rand(-1,1)}; }
  stepSpeed(v){ this.maxSpeed=v; }
  steerSeparation(peers, radius=18, gain=0.12){ let sx=0,sy=0; for(const p of peers){ if(p===this) continue; const dx=this.x-p.x, dy=this.y-p.y; const d=Math.hypot(dx,dy); if(d>0 && d<radius){ sx+=dx/(d*d); sy+=dy/(d*d); } } this.vx+=sx*gain; this.vy+=sy*gain; }
  applyWander(str=0.055, damp=0.92){ this.wander.x=this.wander.x*damp+(Math.random()*2-1)*(1-damp); this.wander.y=this.wander.y*damp+(Math.random()*2-1)*(1-damp); const wn=Math.hypot(this.wander.x,this.wander.y)||1; this.vx+=(this.wander.x/wn)*str; this.vy+=(this.wander.y/wn)*str; }
  avoidObstacles(){
    for(const o of obstacles){
      const clearance = obstacleClearance(o, this.x, this.y);
      if(!clearance) continue;
      const threshold = 12;
      if(clearance.distance < threshold){
        const push = (threshold - clearance.distance) * 0.055;
        const nx = Number.isFinite(clearance.nx) ? clearance.nx : 0;
        const ny = Number.isFinite(clearance.ny) ? clearance.ny : 0;
        this.vx += nx * push;
        this.vy += ny * push;
      }
    }
  }
  keepInBounds(){ if(this.x<10){this.x=10; this.vx=Math.abs(this.vx);} if(this.x>W-10){this.x=W-10; this.vx=-Math.abs(this.vx);} if(this.y<10){this.y=10; this.vy=Math.abs(this.vy);} if(this.y>H-10){this.y=H-10; this.vy=-Math.abs(this.vy);} }
  integrate(){ const sp=Math.hypot(this.vx,this.vy); if(sp>this.maxSpeed){ this.vx*=this.maxSpeed/sp; this.vy*=this.maxSpeed/sp; } this.trail.push({x:this.x,y:this.y}); if(this.trail.length>params.tailLen) this.trail.shift(); this.x+=this.vx; this.y+=this.vy; this.stuckT=(sp<0.10)?(this.stuckT+1):0; }
}

class Collector extends Agent{
  constructor(x,y,team,netRef){ const cfg=(team==='G')? params.green: params.red; const color=(team==='G')? COLORS.green: COLORS.red; super(x,y,color,cfg.speed,team); this.netRef=netRef; this.fitness=0; }
  update(){ const cfg=(this.team==='G')? params.green: params.red; const myFood=(this.team==='G')? 'foodG':'foodR'; const myHome=(this.team==='G')? 'homeG':'homeR'; const myGoal=(this.team==='G')? goalG:goalR; this.stepSpeed(cfg.speed);
    const tgt = this.carry? myGoal : nearest(fruits, this.x, this.y);
    let tx=0,ty=0, dn=1; if(tgt){ tx=tgt.x-this.x; ty=tgt.y-this.y; dn=Math.hypot(tx,ty)||1; tx/=dn; ty/=dn; }
    const g = senseGrad(this.carry? myHome: myFood, this.x, this.y);
    const mates = (this.team==='G')? greens: reds; let sx=0, sy=0; for(const p of mates){ if(p===this) continue; const dx=this.x-p.x, dy=this.y-p.y; const d=Math.hypot(dx,dy); if(d>0 && d<22){ sx+=dx/(d*d); sy+=dy/(d*d); } }
    const input = [tx,ty, g.gx, g.gy, sx, sy, 1.0];
    const out = forward(this.netRef.net, input);
    this.vx += out[0]*(0.45 + 0.15*cfg.smart) + (tx*0.15*cfg.strat);
    this.vy += out[1]*(0.45 + 0.15*cfg.smart) + (ty*0.15*cfg.strat);
    if(!this.carry && tgt && Math.hypot(tgt.x-this.x,tgt.y-this.y)<9){ const i=fruits.indexOf(tgt); if(i>-1) fruits.splice(i,1); this.carry=true; this.fitness += 8; }
    if(this.carry && Math.hypot(myGoal.x-this.x,myGoal.y-this.y)<myGoal.r){ this.carry=false; myGoal.delivered++; this.fitness += 120; }
    if(this.carry){ const dGoal=Math.hypot(myGoal.x-this.x,myGoal.y-this.y); this.fitness += (1/(1+dGoal))*0.2; }
    deposit(this.carry? myFood: myHome, this.x, this.y, 0.30);
    if(this.stuckT>35){ this.vx += tx*(0.9+0.2*cfg.strat); this.vy += ty*(0.9+0.2*cfg.strat); this.stuckT=0; }
    this.avoidObstacles(); this.keepInBounds(); this.integrate();
  }
}

// ===== Setup & loop =====
let lastSpawn=performance.now();
function setup(){ greens.length=0; reds.length=0; fruits.length=0; goalG.delivered=0; goalR.delivered=0; makeGrid(); if(obstacles.length===0){ makeObstacles(params.obstacles); } resizePop(); for(let i=0;i<params.maxFruits;i++) spawnFruit(); for(let i=0;i<params.green.count;i++) greens.push(new Collector(rand(40,W*0.45), rand(40,H-40), 'G', evo.G[i])); for(let i=0;i<params.red.count;i++) reds.push(new Collector(rand(W*0.55,W-40), rand(40,H-40), 'R', evo.R[i])); lastSpawn=performance.now(); Q('lbGen').textContent=evo.gen; }

function drawTrail(trail,color){ if(trail.length<2) return; ctx.lineWidth=2; const grad=ctx.createLinearGradient(trail[0].x,trail[0].y,trail[trail.length-1].x,trail[trail.length-1].y); grad.addColorStop(0,'rgba(255,255,255,0)'); grad.addColorStop(1,color); ctx.strokeStyle=grad; ctx.beginPath(); ctx.moveTo(trail[0].x,trail[0].y); for(let i=1;i<trail.length;i++) ctx.lineTo(trail[i].x,trail[i].y); ctx.stroke(); }
function drawGoal(g, tint){
  ctx.beginPath();
  ctx.arc(g.x,g.y,g.r,0,Math.PI*2);
  ctx.fillStyle=COLORS.goalFill;
  ctx.fill();
  ctx.save();
  ctx.strokeStyle=tint;
  ctx.lineWidth = 4; // static
  ctx.shadowColor='transparent';
  ctx.shadowBlur=0;
  ctx.stroke();
  ctx.restore();
  ctx.fillStyle='#fff';
  ctx.font='bold 18px ui-sans-serif';
  ctx.textAlign='center';
  ctx.textBaseline='middle';
  ctx.fillText(String(g.delivered), g.x, g.y);
}

function drawObstacleShape(o, time, preview=false){
  const paletteIndex = (typeof o.paletteIndex === 'number') ? o.paletteIndex : 0;
  const palette = OBSTACLE_COLORS[paletteIndex % OBSTACLE_COLORS.length];
  const phase = (typeof o.phase === 'number') ? o.phase : 0;
  const pulse = preview ? 0.3 + 0.2*Math.sin(time*0.9 + phase) : 0.45 + 0.35*Math.sin(time*0.9 + phase);
  const fillAlpha = preview ? 0.06 + 0.08*pulse : 0.10 + 0.14*pulse;
  const strokeAlpha = preview ? 0.45 : 0.6 + 0.3*pulse;
  const shadowAlpha = preview ? 0.16 : 0.35*pulse;
  ctx.save();
  ctx.shadowColor = hexToRgba(palette, shadowAlpha);
  ctx.shadowBlur = preview ? 10 : 18*pulse;
  const applyStroke = ()=>{ ctx.strokeStyle = hexToRgba(palette, strokeAlpha); };
  switch(o.type){
    case 'rect':{
      const halfW = o.width/2;
      const halfH = o.height/2;
      ctx.fillStyle = hexToRgba(palette, fillAlpha);
      applyStroke();
      ctx.lineWidth = (preview?1.6:2.2) + 0.8*pulse;
      ctx.setLineDash(preview ? [8,6] : []);
      ctx.beginPath();
      ctx.rect(o.x - halfW, o.y - halfH, o.width, o.height);
      ctx.fill();
      ctx.stroke();
      break;
    }
    case 'line':{
      applyStroke();
      ctx.lineWidth = (o.thickness||14) + (preview?0:2)*pulse;
      ctx.lineCap = 'round';
      ctx.setLineDash(preview ? [6,6] : []);
      ctx.beginPath();
      ctx.moveTo(o.x1, o.y1);
      ctx.lineTo(o.x2, o.y2);
      ctx.stroke();
      break;
    }
    case 'half':{
      const start = o.angle - Math.PI/2;
      const end = o.angle + Math.PI/2;
      const startX = o.x + Math.cos(start)*o.r;
      const startY = o.y + Math.sin(start)*o.r;
      ctx.fillStyle = hexToRgba(palette, fillAlpha);
      applyStroke();
      ctx.lineWidth = (preview?1.6:2.3) + 0.8*pulse;
      ctx.setLineDash(preview ? [8,6] : []);
      ctx.beginPath();
      ctx.moveTo(startX, startY);
      ctx.arc(o.x, o.y, o.r, start, end);
      ctx.lineTo(startX, startY);
      ctx.fill();
      ctx.stroke();
      break;
    }
    default:{
      const radius = o.r || getObstacleRadius(o);
      ctx.fillStyle = hexToRgba(palette, fillAlpha);
      applyStroke();
      ctx.lineWidth = 2.1 + 0.9*pulse;
      ctx.setLineDash(preview ? [8,6] : []);
      ctx.beginPath();
      ctx.arc(o.x, o.y, radius, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
      break;
    }
  }
  ctx.restore();
}

function draw(){
  ctx.clearRect(0,0,W,H);

  // Goals (static, no blinking)
  drawGoal(goalG, COLORS.green);
  drawGoal(goalR, COLORS.red);

  // Obstacles (ambient pulse)
  const t = performance.now()*0.001;
  for(const o of obstacles){
    drawObstacleShape(o, t, false);
  }
  if(drawingState){
    const preview = buildObstacleFromState(drawingState, true);
    if(preview){
      preview.paletteIndex = manualPaletteCursor % OBSTACLE_COLORS.length;
      drawObstacleShape(preview, t, true);
    }
  }

  // Fruits
  for(const f of fruits){
    ctx.beginPath();
    ctx.arc(f.x,f.y,f.r,0,Math.PI*2);
    ctx.fillStyle=COLORS.fruit;
    ctx.fill();
    ctx.lineWidth=1.5;
    ctx.strokeStyle=COLORS.fruitOutline;
    ctx.stroke();
  }

  // Agents (no shadow flash)
  for(const a of greens){
    ctx.beginPath();
    ctx.arc(a.x,a.y,5,0,Math.PI*2);
    ctx.fillStyle=COLORS.green;
    ctx.fill();
    ctx.lineWidth=2;
    ctx.strokeStyle=COLORS.greenOutline;
    ctx.stroke();
    if(a.carry){ ctx.lineWidth=2; ctx.strokeStyle='#ffff33'; ctx.stroke(); }
    drawTrail(a.trail, COLORS.green);
  }
  for(const a of reds){
    ctx.beginPath();
    ctx.arc(a.x,a.y,5.5,0,Math.PI*2);
    ctx.fillStyle=COLORS.red;
    ctx.fill();
    ctx.lineWidth=2;
    ctx.strokeStyle=COLORS.redOutline;
    ctx.stroke();
    if(a.carry){ ctx.lineWidth=2; ctx.strokeStyle='#ffff33'; ctx.stroke(); }
    drawTrail(a.trail, COLORS.red);
  }
}

let simSteps=0, forceNextGen=false, awaitingManualAdvance=false;
function advanceGeneration(){
  for(let i=0;i<greens.length;i++) evo.G[i].fitness += greens[i].fitness;
  for(let i=0;i<reds.length;i++) evo.R[i].fitness += reds[i].fitness;
  nextGeneration('G');
  nextGeneration('R');
  evo.gen++;
  Q('lbGen').textContent=evo.gen;
  simSteps=0;
  forceNextGen=false;
  awaitingManualAdvance=false;
  setup();
}
function loop(){
  requestAnimationFrame(loop);

  if(awaitingManualAdvance){
    if(forceNextGen){
      advanceGeneration();
    }
    return;
  }

  const now = performance.now();
  for(const a of greens) a.update();
  for(const a of reds) a.update();
  evaporate();
  if(now - lastSpawn >= params.spawnMs){
    spawnFruit();
    lastSpawn = now;
  }
  draw();
  simSteps++;

  const reachedLimit = simSteps>=params.learn.genSteps;
  if(forceNextGen || (reachedLimit && params.learn.auto)){
    advanceGeneration();
  }else if(reachedLimit){
    awaitingManualAdvance=true;
  }
}

function updateBestLabels(bestG, bestR){
  if(Number.isFinite(bestG)){
    Q('lbBestG').textContent = Number(bestG).toFixed(0);
  }
  if(Number.isFinite(bestR)){
    Q('lbBestR').textContent = Number(bestR).toFixed(0);
  }
}

function captureTrainingSnapshot(){
  const paramsClone = JSON.parse(JSON.stringify(params));
  const bestGreenValue = Number(Q('lbBestG').textContent);
  const bestRedValue = Number(Q('lbBestR').textContent);
  const bestGreen = Number.isFinite(bestGreenValue) ? bestGreenValue : 0;
  const bestRed = Number.isFinite(bestRedValue) ? bestRedValue : 0;
  return {
    version:1,
    savedAt:new Date().toISOString(),
    params:paramsClone,
    evo:{
      gen:evo.gen,
      greens:evo.G.map((member)=> ({ net:cloneNet(member.net), fitness:member.fitness||0 })),
      reds:evo.R.map((member)=> ({ net:cloneNet(member.net), fitness:member.fitness||0 }))
    },
    best:{ green:bestGreen, red:bestRed }
  };
}

function downloadTrainingData(){
  try{
    const snapshot = captureTrainingSnapshot();
    const json = JSON.stringify(snapshot, null, 2);
    const blob = new Blob([json], { type:'application/json' });
    const { url, token } = setCurrentObjectUrl(URL.createObjectURL(blob));
    const genStr = String(snapshot.evo?.gen ?? 1).padStart(3, '0');
    const link = document.createElement('a');
    link.href = url;
    link.download = `foodsim-training-gen${genStr}.json`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    setTimeout(()=> clearCurrentObjectUrl(token), 1000);
  }catch(err){
    console.error('Failed to export training data', err);
    alert('Could not save training data. Please try again.');
  }
}

function applyParamsSnapshot(snapshot){
  if(!snapshot) return;
  if(snapshot.maxFruits != null) setRangeValue('slFruits', snapshot.maxFruits);
  if(snapshot.spawnMs != null) setRangeValue('slSpawn', snapshot.spawnMs);
  if(snapshot.obstacles != null) setRangeValue('slObst', snapshot.obstacles);
  if(snapshot.tailLen != null) setRangeValue('slTail', snapshot.tailLen);

  if(snapshot.green){
    if(snapshot.green.count != null) setRangeValue('slGCount', snapshot.green.count);
    if(snapshot.green.speed != null) setRangeValue('slGSpeed', Math.round(snapshot.green.speed*100));
    if(snapshot.green.smart != null) setRangeValue('slGSmart', Math.round(snapshot.green.smart*100));
    if(snapshot.green.strat != null) setRangeValue('slGStrat', Math.round(snapshot.green.strat*100));
    if(snapshot.green.sep != null) setRangeValue('slGSep', Math.round(snapshot.green.sep*100));
  }

  if(snapshot.red){
    if(snapshot.red.count != null) setRangeValue('slRCount', snapshot.red.count);
    if(snapshot.red.speed != null) setRangeValue('slRSpeed', Math.round(snapshot.red.speed*100));
    if(snapshot.red.smart != null) setRangeValue('slRSmart', Math.round(snapshot.red.smart*100));
    if(snapshot.red.strat != null) setRangeValue('slRStrat', Math.round(snapshot.red.strat*100));
    if(snapshot.red.sep != null) setRangeValue('slRSep', Math.round(snapshot.red.sep*100));
  }

  if(snapshot.learn){
    if(snapshot.learn.genSteps != null) setRangeValue('slGenSteps', snapshot.learn.genSteps);
    if(snapshot.learn.mut != null) setRangeValue('slMut', Math.round(snapshot.learn.mut*100));
    if(snapshot.learn.elite != null) setRangeValue('slElite', Math.round(snapshot.learn.elite*100));
    if(snapshot.learn.auto !== undefined){
      const auto = Q('chkAuto');
      if(auto){
        auto.checked = !!snapshot.learn.auto;
        auto.dispatchEvent(new Event('change', { bubbles:true }));
      }
    }
  }
}

function loadTrainingSnapshot(data){
  if(!data || typeof data !== 'object') throw new Error('Invalid training file.');
  const evoData = data.evo || data;
  if(!evoData) throw new Error('Training file is missing the evo section.');
  const greensData = Array.isArray(evoData.greens) ? evoData.greens : (Array.isArray(evoData.G) ? evoData.G : null);
  const redsData = Array.isArray(evoData.reds) ? evoData.reds : (Array.isArray(evoData.R) ? evoData.R : null);
  if(!greensData || !redsData) throw new Error('Training file does not contain both team genomes.');

  let computedBestG = 0;
  for(const item of greensData){
    const val = Number(item?.fitness);
    if(Number.isFinite(val) && val > computedBestG) computedBestG = val;
  }
  let computedBestR = 0;
  for(const item of redsData){
    const val = Number(item?.fitness);
    if(Number.isFinite(val) && val > computedBestR) computedBestR = val;
  }
  const bestGreenStored = Number(data.best?.green);
  const bestRedStored = Number(data.best?.red);
  const bestGreen = Number.isFinite(bestGreenStored) ? bestGreenStored : computedBestG;
  const bestRed = Number.isFinite(bestRedStored) ? bestRedStored : computedBestR;

  if(data.params) applyParamsSnapshot(data.params);

  const toIndividual = (entry)=>{
    const netData = entry && (entry.net || entry);
    if(!netData || !netData.W1 || !netData.b1 || !netData.W2 || !netData.b2){
      throw new Error('Training file contains malformed network data.');
    }
    return { net:cloneNet(netData), fitness:0 };
  };

  evo.G = greensData.map(toIndividual);
  evo.R = redsData.map(toIndividual);
  const parsedGen = Number(evoData.gen);
  evo.gen = Number.isFinite(parsedGen) && parsedGen > 0 ? parsedGen : 1;

  setRangeValue('slGCount', evo.G.length);
  setRangeValue('slRCount', evo.R.length);

  simSteps = 0;
  forceNextGen = false;
  awaitingManualAdvance = false;
  setup();
  updateBestLabels(bestGreen, bestRed);
}

function handleTrainingFileSelection(evt){
  const input = evt.target;
  const file = input?.files?.[0];
  if(input) input.value = '';
  if(!file) return;
  const reader = new FileReader();
  reader.onload = ()=>{
    try{
      const parsed = JSON.parse(reader.result);
      loadTrainingSnapshot(parsed);
    }catch(err){
      console.error('Failed to load training file', err);
      alert('Could not load training data. Please ensure it was exported from this simulator.');
    }
  };
  reader.onerror = ()=>{
    console.error('Unable to read the selected file', reader.error);
    alert('Could not read the selected file.');
  };
  reader.readAsText(file);
}

const btnSaveTraining = Q('btnSaveTraining');
if(btnSaveTraining){
  btnSaveTraining.addEventListener('click', downloadTrainingData);
}
const btnLoadTraining = Q('btnLoadTraining');
const inputLoadTraining = Q('inputLoadTraining');
if(btnLoadTraining && inputLoadTraining){
  btnLoadTraining.addEventListener('click', ()=> inputLoadTraining.click());
  inputLoadTraining.addEventListener('change', handleTrainingFileSelection);
}

const toolButtons = Array.from(document.querySelectorAll('.tool-btn'));
function setTool(tool){
  if(!toolButtons.length){
    currentTool = tool || TOOL_SELECT;
    return;
  }
  const nextTool = toolButtons.some(btn=>btn.dataset.tool===tool) ? tool : TOOL_SELECT;
  currentTool = nextTool;
  toolButtons.forEach(btn=>{
    const isActive = btn.dataset.tool === nextTool;
    btn.classList.toggle('active', isActive);
    btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
  });
  if(currentTool === TOOL_SELECT){
    drawingState = null;
  }
}

if(toolButtons.length){
  toolButtons.forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const tool = btn.dataset.tool || TOOL_SELECT;
      setTool(tool);
    });
  });
  setTool(TOOL_SELECT);
}

const btnClearManual = Q('btnClearManual');
if(btnClearManual){
  btnClearManual.addEventListener('click', ()=>{
    for(let i=obstacles.length-1; i>=0; i--){
      if(obstacles[i].manual){
        obstacles.splice(i,1);
      }
    }
    manualPaletteCursor = 0;
  });
}

// Bind ranges after DOM ready
['Fruits','Spawn','Obst','Tail','GCount','GSpeed','GSmart','GStrat','GSep','RCount','RSpeed','RSmart','RStrat','RSep','GenSteps','Mut','Elite'].forEach(k=>{
  bindRange('sl'+k, 'lb'+k, (v)=> (k.includes('Speed')||k.includes('Smart')||k.includes('Strat')||k.includes('Sep')) ? (v/100).toFixed(2) : v);
});
Q('btnReset').onclick = ()=> { awaitingManualAdvance=false; forceNextGen=false; simSteps=0; setup(); };
Q('btnNextGen').onclick = ()=> { forceNextGen = true; };
Q('chkAuto').addEventListener('change', ()=> readParams());

window.addEventListener('beforeunload', clearCurrentObjectUrl);

// Start
initMusicPanel();
readParams();
setup();
loop();
</script>
</body>
</html>
