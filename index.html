<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>FoodSim â€“ Two Teams with NEAT-lite</title>
  <style>
    :root {
      --bg1:#050516;
      --bg2:#161b3f;
      --panel:rgba(18,24,56,.82);
      --ink:#f1f5ff;
      --muted:#a1a9d8;
      --accent:#f472b6;
      --accent-emerald:#2dd4bf;
      --accent-cyan:#38bdf8;
      --silver:rgba(222,231,255,.55);
    }
    *{box-sizing:border-box}
    body{margin:0; min-height:100vh; display:flex; flex-direction:column; background:radial-gradient(circle at 45% 12%, rgba(87,51,183,.55) 0%, rgba(39,56,121,.85) 45%, var(--bg1) 100%); color:var(--ink); font-family:"Inter",system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;}

    .main-nav{position:sticky; top:0; z-index:200; padding:22px 48px; display:flex; align-items:center; justify-content:space-between; background:linear-gradient(120deg, rgba(15,20,48,.92) 0%, rgba(10,14,34,.75) 60%, rgba(10,14,34,.35) 100%); backdrop-filter:blur(14px); border-bottom:1px solid var(--silver); box-shadow:0 22px 45px rgba(5,9,25,.55)}
    .brand{display:flex; align-items:center; gap:12px; font-size:22px; font-weight:700; letter-spacing:.02em; color:var(--ink)}
    .brand-dot{width:14px; height:14px; border-radius:50%; background:linear-gradient(135deg, var(--accent) 0%, #8b5cf6 100%); box-shadow:0 0 18px rgba(244,114,182,.6)}
    .nav-links{display:flex; align-items:center; gap:12px}
    .pill-link{display:inline-flex; align-items:center; justify-content:center; padding:10px 20px; border-radius:999px; border:1px solid rgba(45,212,191,.45); background:linear-gradient(120deg, rgba(45,212,191,.18), rgba(59,130,246,.18)); color:var(--ink); text-decoration:none; font-size:14px; font-weight:600; letter-spacing:.03em; transition:transform .2s ease, box-shadow .2s ease, filter .2s ease, border-color .2s ease}
    .pill-link.secondary{border-color:rgba(139,92,246,.45); background:linear-gradient(120deg, rgba(139,92,246,.18), rgba(244,114,182,.18))}
    .pill-link:hover{transform:translateY(-1px); filter:brightness(1.05); box-shadow:0 16px 32px rgba(45,212,191,.25)}
    .pill-link:focus-visible{outline:2px solid rgba(56,189,248,.65); outline-offset:3px}

    main{flex:1; display:flex; justify-content:center; align-items:flex-start; padding:40px 48px 64px}
    .wrap{display:flex; align-items:flex-start; justify-content:center; gap:40px; width:100%; max-width:1600px}
    canvas{border-radius:24px; background:#04091f; box-shadow:0 0 45px rgba(15,23,61,.65), inset 0 0 22px rgba(118,133,255,.12); cursor:crosshair; border:1px solid var(--silver);}

    .side{width:380px; display:flex; flex-direction:column; gap:20px}
    .panel{background:var(--panel); border:1px solid var(--silver); padding:22px; border-radius:20px; backdrop-filter:blur(16px); box-shadow:0 18px 45px rgba(5,7,24,.55); position:relative}
    .panel-head{display:flex; align-items:center; justify-content:space-between; gap:12px; cursor:pointer; user-select:none; padding-bottom:10px; margin-bottom:14px; border-bottom:1px dashed rgba(189,206,255,.28)}
    .panel-head .h{margin:0; font-size:17px; letter-spacing:.03em}
    .chev{font-weight:900; font-size:16px; opacity:.75; transition:transform .25s ease}
    .panel-body{max-height:1200px; overflow:hidden; transition:max-height .35s ease, opacity .25s ease; opacity:1}
    .panel.collapsed .panel-body{max-height:0; opacity:.0}
    .panel.collapsed .chev{transform:rotate(-90deg)}

    .grid{display:grid; grid-template-columns: 1fr 1.3fr auto; gap:12px 12px; align-items:center}
    .label{font-size:13px; color:var(--muted); letter-spacing:.02em}
    .val{font-family:ui-monospace,Menlo,Consolas,monospace; font-size:12px; padding:4px 8px; border-radius:8px; background:rgba(10,16,46,.7); border:1px solid var(--silver); color:var(--accent-cyan); box-shadow:inset 0 0 12px rgba(56,189,248,.12)}
    input[type=range]{width:100%; accent-color:var(--accent-cyan)}
    .btn{display:block; width:100%; padding:12px 14px; border-radius:12px; border:1px solid rgba(45,212,191,.45); background:linear-gradient(120deg, rgba(45,212,191,.18), rgba(59,130,246,.18)); color:var(--ink); cursor:pointer; text-align:center; margin-top:14px; font-weight:600; letter-spacing:.02em; transition:transform .2s ease, box-shadow .2s ease, filter .2s ease}
    .btn:hover{filter:brightness(1.08); transform:translateY(-1px); box-shadow:0 20px 36px rgba(45,212,191,.28)}
    .sub{font-weight:800; font-size:14px; opacity:.9; margin:10px 0 8px; letter-spacing:.05em; color:var(--ink)}
    .music-lead{font-size:13px; line-height:1.6; opacity:.85; margin:0 0 14px}
    .music-select{display:flex; flex-direction:column; gap:6px}
    .music-dropdown{width:100%; padding:10px 12px; border-radius:12px; border:1px solid var(--silver); background:rgba(12,18,44,.82); color:var(--ink); font-size:13px; font-family:inherit; letter-spacing:.01em; box-shadow:inset 0 0 12px rgba(118,133,255,.15)}
    .music-controls{display:flex; align-items:center; gap:12px; margin-top:12px; flex-wrap:wrap}
    .music-controls .btn{flex:0 0 auto; width:auto; padding:10px 18px; margin-top:0}
    .music-volume{display:flex; flex:1; align-items:center; gap:10px; min-width:200px}
    .music-volume .label{min-width:60px}
    .music-volume input[type=range]{flex:1}
    .music-meta{margin-top:14px; font-size:12px; line-height:1.6; background:rgba(11,16,44,.65); border:1px solid var(--silver); padding:12px 14px; border-radius:14px; box-shadow:inset 0 0 14px rgba(138,92,246,.12)}
    .music-status{display:flex; align-items:center; gap:8px; font-size:12px; text-transform:uppercase; letter-spacing:.08em; opacity:.82; color:var(--accent-cyan)}
    .music-attr{opacity:.72}
    .sr-only{position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0}

    @media (max-width:1200px){
      .wrap{flex-direction:column; align-items:center}
      .side{width:100%; max-width:720px}
    }
    @media (max-width:900px){
      main{padding:32px 28px 56px}
    }
    @media (max-width:768px){
      .main-nav{flex-direction:column; align-items:flex-start; gap:16px; padding:18px 24px}
      .nav-links{flex-wrap:wrap}
      main{padding:28px 20px 56px}
      .wrap{gap:28px}
      canvas{width:100%; height:auto}
      .side{max-width:100%}
    }
  </style>
</head>
<body>
  <header class="main-nav">
    <div class="brand"><span class="brand-dot"></span>FoodSim NEAT Lab</div>
    <nav class="nav-links" aria-label="Huvudmeny">
      <a class="pill-link" href="#world">SpelfÃ¤lt</a>
      <a class="pill-link" href="#panel-global">Kontroller</a>
      <a class="pill-link secondary" href="learn-neat.html">SÃ¥ funkar NEAT</a>
    </nav>
  </header>
  <main>
  <div class="wrap">
    <!-- Left panel: Learning (NEAT) -->
    <aside class="side" id="left-panel">
      <div class="panel" id="panel-learn">
        <div class="panel-head"><div class="h">Learning (NEAT-lite)</div><span class="chev">â–¾</span></div>
        <div class="panel-body">
          <div class="grid">
            <div class="label">Steps / gen</div>
            <input id="slGenSteps" type="range" min="600" max="8000" value="2800"><div class="val" id="lbGenSteps">2800</div>

            <div class="label">Mutation %</div>
            <input id="slMut" type="range" min="1" max="80" value="16"><div class="val" id="lbMut">16</div>

            <div class="label">Elite ratio</div>
            <input id="slElite" type="range" min="5" max="50" value="20"><div class="val" id="lbElite">0.20</div>
          </div>
          <div class="grid" style="margin-top:8px">
            <div class="label">Auto next gen</div>
            <input id="chkAuto" type="checkbox" checked><div class="val" id="lbAuto">on</div>
          </div>
          <div class="sub" style="margin-top:10px">Status</div>
          <div class="grid">
            <div class="label">Generation</div><div></div><div class="val" id="lbGen">1</div>
            <div class="label">Best ðŸŸ¢</div><div></div><div class="val" id="lbBestG">0</div>
            <div class="label">Best ðŸ”´</div><div></div><div class="val" id="lbBestR">0</div>
          </div>
          <button id="btnNextGen" class="btn">Advance generation now</button>
          <button id="btnSaveTraining" class="btn">Save training (.json)</button>
          <button id="btnLoadTraining" class="btn">Load trainingâ€¦</button>
          <input type="file" id="inputLoadTraining" accept="application/json" style="display:none">
        </div>
      </div>
    </aside>

    <!-- Middle: playfield -->
    <canvas id="world" width="1100" height="640"></canvas>

    <!-- Right panels: controls and teams -->
    <aside class="side" id="right-panel">
      <div class="panel" id="panel-global">
        <div class="panel-head"><div class="h">Global controls</div><span class="chev">â–¾</span></div>
        <div class="panel-body">
          <div class="grid">
            <div class="label">Fruit (max)</div>
            <input id="slFruits" type="range" min="2" max="160" value="32"><div class="val" id="lbFruits">32</div>

            <div class="label">Spawn (ms)</div>
            <input id="slSpawn" type="range" min="120" max="5000" value="900"><div class="val" id="lbSpawn">900</div>

            <div class="label">Obstacles</div>
            <input id="slObst" type="range" min="0" max="40" value="8"><div class="val" id="lbObst">8</div>

            <div class="label">Trail length</div>
            <input id="slTail" type="range" min="4" max="200" value="24"><div class="val" id="lbTail">24</div>
          </div>
          <button id="btnReset" class="btn">Restart</button>
        </div>
      </div>

      <div class="panel" id="panel-teams">
        <div class="panel-head"><div class="h">Team settings</div><span class="chev">â–¾</span></div>
        <div class="panel-body">
          <div class="sub">ðŸŸ¢ Greens</div>
          <div class="grid">
            <div class="label">Count</div>
            <input id="slGCount" type="range" min="2" max="200" value="28"><div class="val" id="lbGCount">28</div>
            <div class="label">Speed</div>
            <input id="slGSpeed" type="range" min="10" max="600" value="260"><div class="val" id="lbGSpeed">2.60</div>
            <div class="label">Awareness</div>
            <input id="slGSmart" type="range" min="0" max="300" value="180"><div class="val" id="lbGSmart">1.80</div>
            <div class="label">Strategy</div>
            <input id="slGStrat" type="range" min="0" max="300" value="140"><div class="val" id="lbGStrat">1.40</div>
            <div class="label">Separation</div>
            <input id="slGSep" type="range" min="0" max="300" value="110"><div class="val" id="lbGSep">1.10</div>
          </div>

          <div class="sub" style="margin-top:14px">ðŸ”´ Reds</div>
          <div class="grid">
            <div class="label">Count</div>
            <input id="slRCount" type="range" min="2" max="200" value="28"><div class="val" id="lbRCount">28</div>
            <div class="label">Speed</div>
            <input id="slRSpeed" type="range" min="10" max="600" value="260"><div class="val" id="lbRSpeed">2.60</div>
            <div class="label">Awareness</div>
            <input id="slRSmart" type="range" min="0" max="300" value="180"><div class="val" id="lbRSmart">1.80</div>
            <div class="label">Strategy</div>
            <input id="slRStrat" type="range" min="0" max="300" value="140"><div class="val" id="lbRStrat">1.40</div>
            <div class="label">Separation</div>
            <input id="slRSep" type="range" min="0" max="300" value="110"><div class="val" id="lbRSep">1.10</div>
          </div>
        </div>
      </div>

      <div class="panel" id="panel-music">
        <div class="panel-head"><div class="h">Ambient Sound Lounge</div><span class="chev">â–¾</span></div>
        <div class="panel-body">
          <p class="music-lead">Slip into focus with a hand-picked selection of calm, looping ambient tracks.</p>
          <div class="music-select">
            <label class="label" for="selMusic">Curated playlist</label>
            <select id="selMusic" class="music-dropdown"></select>
          </div>
          <div class="music-controls">
            <button id="btnMusicToggle" class="btn">Play</button>
            <div class="music-volume">
              <span class="label">Volume</span>
              <input id="slMusicVolume" type="range" min="0" max="100" value="55">
              <span class="val" id="lbMusicVolume">55%</span>
            </div>
          </div>
          <div class="music-meta">
            <div class="music-status"><span id="lbMusicState">Paused</span></div>
            <div id="lbMusicNow" class="music-attr">Choose a track to begin.</div>
            <div id="lbMusicSource" class="music-attr">Royalty-free ambient selections streamed from Pixabay artists.</div>
          </div>
        </div>
      </div>
    </aside>
  </div>
  </main>

  <audio id="bgm" preload="metadata" loop crossorigin="anonymous"></audio>

<script>
// ===== Utils for UI =====
const Q = (id)=>document.getElementById(id);
function bindRange(sl, lb, fmt=(v)=>v){ const s=Q(sl), l=Q(lb); const apply=()=>{ l.textContent = fmt(+s.value); readParams(); }; s.addEventListener('input', apply); apply(); }

function setRangeValue(id, value){
  const el = Q(id);
  if(!el) return;
  const min = el.min !== undefined ? Number(el.min) : Number(value);
  const max = el.max !== undefined ? Number(el.max) : Number(value);
  const clamped = Math.min(max, Math.max(min, Number(value)));
  if(String(el.value) !== String(clamped)){
    el.value = clamped;
  }
  el.dispatchEvent(new Event('input', { bubbles:true }));
}

// === Make panels collapsible ===
(function makePanelsCollapsible(){
  const panels = document.querySelectorAll('.panel');
  panels.forEach((p)=>{
    const head = p.querySelector('.panel-head');
    if(!head) return;
    head.addEventListener('click', (e)=>{
      // Ignore clicks on inputs inside header (none for now)
      p.classList.toggle('collapsed');
    });
  });
})();

// ===== Colors =====
const COLORS = {
  green: '#00ff91',
  red:   '#ff0055',
  fruit: '#ffd43b',
  goal:  '#3b82f6',
  goalFill: 'rgba(59,130,246,0.18)',
  obstS: 'rgba(226,232,240,0.90)',
  obstF: 'rgba(226,232,240,0.08)',
  greenOutline:'#003322',
  redOutline:'#5a001a',
  fruitOutline:'#000'
};

const canvas = document.getElementById('world');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

// ===== Parameters =====
const params = {
  maxFruits: 32,
  spawnMs: 900,
  obstacles: 8,
  tailLen: 24,
  green: { count:28, speed:2.60, smart:1.80, strat:1.40, sep:1.10 },
  red:   { count:28, speed:2.60, smart:1.80, strat:1.40, sep:1.10 },
  learn: { genSteps:2800, mut:0.16, elite:0.20, auto:true }
};
let lastObstCount = params.obstacles;

const MUSIC_TRACKS = [
  {
    title: 'Forest Haze',
    artist: 'Dream-Protocol',
    source: 'Pixabay â€” Ambient Meditation by dream-protocol',
    url: 'https://cdn.pixabay.com/download/audio/2022/10/21/audio_3f225524d86.mp3?filename=deep-in-forest-ambient-12484.mp3'
  },
  {
    title: 'Cloudlight',
    artist: 'Lesfm',
    source: 'Pixabay â€” Meditation by Lesfm',
    url: 'https://cdn.pixabay.com/download/audio/2022/03/15/audio_c083352499.mp3?filename=ambient-110366.mp3'
  },
  {
    title: 'Luminous Air',
    artist: 'Ashot-Danielyan-Composer',
    source: 'Pixabay â€” Ambient Piano by Ashot-Danielyan-Composer',
    url: 'https://cdn.pixabay.com/download/audio/2023/02/27/audio_aa79d23c34.mp3?filename=ambient-piano-14352.mp3'
  }
];
const musicAudio = document.getElementById('bgm');
let currentTrackIndex = 0;
let currentObjectUrl = null;
let currentTrackToken = 0;
let musicFetchController = null;

function readParams(){
  params.maxFruits = +Q('slFruits').value; Q('lbFruits').textContent=params.maxFruits;
  params.spawnMs = +Q('slSpawn').value; Q('lbSpawn').textContent=params.spawnMs;
  params.obstacles = +Q('slObst').value; Q('lbObst').textContent=params.obstacles; if(params.obstacles !== lastObstCount){ makeObstacles(params.obstacles); lastObstCount = params.obstacles; }
  params.tailLen = +Q('slTail').value; Q('lbTail').textContent=params.tailLen;

  params.green.count = +Q('slGCount').value; Q('lbGCount').textContent=params.green.count;
  params.green.speed = (+Q('slGSpeed').value)/100; Q('lbGSpeed').textContent=params.green.speed.toFixed(2);
  params.green.smart = (+Q('slGSmart').value)/100; Q('lbGSmart').textContent=params.green.smart.toFixed(2);
  params.green.strat = (+Q('slGStrat').value)/100; Q('lbGStrat').textContent=params.green.strat.toFixed(2);
  params.green.sep   = (+Q('slGSep').value)/100; Q('lbGSep').textContent=params.green.sep.toFixed(2);

  params.red.count = +Q('slRCount').value; Q('lbRCount').textContent=params.red.count;
  params.red.speed = (+Q('slRSpeed').value)/100; Q('lbRSpeed').textContent=params.red.speed.toFixed(2);
  params.red.smart = (+Q('slRSmart').value)/100; Q('lbRSmart').textContent=params.red.smart.toFixed(2);
  params.red.strat = (+Q('slRStrat').value)/100; Q('lbRStrat').textContent=params.red.strat.toFixed(2);
  params.red.sep   = (+Q('slRSep').value)/100; Q('lbRSep').textContent=params.red.sep.toFixed(2);

  params.learn.genSteps = +Q('slGenSteps').value; Q('lbGenSteps').textContent=params.learn.genSteps;
  params.learn.mut = (+Q('slMut').value)/100; Q('lbMut').textContent=Math.round(params.learn.mut*100);
  params.learn.elite = (+Q('slElite').value)/100; Q('lbElite').textContent=params.learn.elite.toFixed(2);
  params.learn.auto = Q('chkAuto').checked; Q('lbAuto').textContent = params.learn.auto? 'on':'off';
}
function updateMusicMeta(track, stateOverride=null){
  if(!track) return;
  const state = stateOverride || (musicAudio.paused ? 'Paused' : 'Playing');
  Q('lbMusicState').textContent = state;
  Q('lbMusicNow').textContent = `${track.title} â€” ${track.artist}`;
  Q('lbMusicSource').textContent = track.source;
}

let awaitingAudioUnlock = false;

function clearCurrentObjectUrl(){
  if(currentObjectUrl){
    URL.revokeObjectURL(currentObjectUrl);
    currentObjectUrl = null;
  }
}

function abortMusicFetch(){
  if(musicFetchController){
    if(typeof musicFetchController.abort === 'function'){
      musicFetchController.abort();
    }
    musicFetchController = null;
  }
}

function requestAudioUnlock(){
  if(awaitingAudioUnlock) return;
  awaitingAudioUnlock = true;
  const resume = ()=>{
    document.removeEventListener('pointerdown', resume);
    document.removeEventListener('keydown', resume);
    awaitingAudioUnlock = false;
    playCurrentTrack();
  };
  document.addEventListener('pointerdown', resume);
  document.addEventListener('keydown', resume);
}

function handlePlayError(err){
  if(!err) return;
  if(err.name === 'NotAllowedError' || err.name === 'SecurityError'){
    updateMusicMeta(MUSIC_TRACKS[currentTrackIndex], 'Tap to enable audio');
    requestAudioUnlock();
    console.warn('Music playback is blocked until the page receives a user interaction.', err);
  } else if(err.name === 'AbortError'){
    // Interruption during load â€“ ignore to avoid confusing messaging
  } else if(err.name === 'NotSupportedError'){
    updateMusicMeta(MUSIC_TRACKS[currentTrackIndex], 'Load failed');
    Q('lbMusicNow').textContent = 'This browser cannot play the selected track.';
    console.error('Music playback failed', err);
  } else {
    updateMusicMeta(MUSIC_TRACKS[currentTrackIndex], 'Playback failed');
    console.error('Music playback failed', err);
  }
}

function playCurrentTrack(){
  const promise = musicAudio.play();
  if(promise){
    promise.catch(handlePlayError);
  }
}

async function setMusicTrack(index, autoplay=false){
  if(index<0 || index>=MUSIC_TRACKS.length) return;

  const track = MUSIC_TRACKS[index];
  const wasPlaying = !musicAudio.paused && !!musicAudio.src;

  musicAudio.pause();
  abortMusicFetch();
  clearCurrentObjectUrl();
  musicAudio.removeAttribute('src');
  try{
    musicAudio.load();
  }catch(err){
    console.warn('Unable to reset audio element before loading a new track.', err);
  }

  currentTrackIndex = index;
  const shouldAutoplay = autoplay || wasPlaying;
  const token = ++currentTrackToken;

  updateMusicMeta(track, 'Loadingâ€¦');

  if(typeof fetch !== 'function'){
    musicAudio.src = track.url;
    musicAudio.load();
    if(shouldAutoplay){
      playCurrentTrack();
    } else {
      updateMusicMeta(track, 'Ready');
    }
    return;
  }

  try{
    const controller = typeof AbortController === 'function' ? new AbortController() : null;
    musicFetchController = controller;
    const fetchOptions = controller ? { signal: controller.signal, mode:'cors' } : { mode:'cors' };
    const response = await fetch(track.url, fetchOptions);
    if(!response.ok){
      throw new Error(`HTTP ${response.status}`);
    }
    const blob = await response.blob();
    if(token !== currentTrackToken) return;

    const objectUrl = URL.createObjectURL(blob);
    currentObjectUrl = objectUrl;
    musicAudio.src = objectUrl;
    musicAudio.load();

    if(shouldAutoplay){
      playCurrentTrack();
    } else {
      updateMusicMeta(track, 'Ready');
    }
  }catch(err){
    if(err.name === 'AbortError') return;
    console.error('Failed to load music track', err);
    updateMusicMeta(track, 'Load failed');
    Q('lbMusicNow').textContent = 'Try another track from the list.';
  }finally{
    if(token === currentTrackToken){
      musicFetchController = null;
    }
  }
}

function initMusicPanel(){
  const select = Q('selMusic');
  const toggle = Q('btnMusicToggle');
  const vol = Q('slMusicVolume');
  const volLabel = Q('lbMusicVolume');

  MUSIC_TRACKS.forEach((track, idx)=>{
    const opt = document.createElement('option');
    opt.value = idx;
    opt.textContent = `${track.title} â€” ${track.artist}`;
    select.appendChild(opt);
  });
  select.value = String(currentTrackIndex);

  const applyVolume = ()=>{
    const value = Math.round(vol.value);
    musicAudio.volume = value/100;
    volLabel.textContent = `${value}%`;
  };
  vol.addEventListener('input', applyVolume);
  applyVolume();

  select.addEventListener('change', ()=>{
    const idx = Number(select.value);
    const shouldAutoplay = !musicAudio.paused && !!musicAudio.src;
    setMusicTrack(idx, shouldAutoplay);
  });

  toggle.addEventListener('click', ()=>{
    if(!musicAudio.src){
      setMusicTrack(Number(select.value), true);
      return;
    }
    if(musicAudio.paused){
      playCurrentTrack();
    } else {
      musicAudio.pause();
    }
  });

  musicAudio.addEventListener('play', ()=>{
    toggle.textContent = 'Pause';
    updateMusicMeta(MUSIC_TRACKS[currentTrackIndex], 'Playing');
  });
  musicAudio.addEventListener('pause', ()=>{
    toggle.textContent = 'Play';
    updateMusicMeta(MUSIC_TRACKS[currentTrackIndex], 'Paused');
  });
  musicAudio.addEventListener('loadeddata', ()=>{
    const status = musicAudio.paused ? 'Ready' : 'Playing';
    updateMusicMeta(MUSIC_TRACKS[currentTrackIndex], status);
  });
  musicAudio.addEventListener('waiting', ()=>{
    updateMusicMeta(MUSIC_TRACKS[currentTrackIndex], 'Bufferingâ€¦');
  });
  musicAudio.addEventListener('canplaythrough', ()=>{
    const status = musicAudio.paused ? 'Ready' : 'Playing';
    updateMusicMeta(MUSIC_TRACKS[currentTrackIndex], status);
    if(!musicAudio.paused){
      playCurrentTrack();
    }
  });
  musicAudio.addEventListener('error', ()=>{
    clearCurrentObjectUrl();
    updateMusicMeta(MUSIC_TRACKS[currentTrackIndex], 'Load failed');
    Q('lbMusicNow').textContent = 'Try another track from the list.';
  });

  setMusicTrack(currentTrackIndex, false);
}

// ===== Datastrukturer =====
const greens=[], reds=[], fruits=[], obstacles=[];

// Pheromone grid â€“ separate fields per team
let grid, GW, GH, CS = 22; // cellstorlek
function makeGrid(){ GW=Math.floor(W/CS); GH=Math.floor(H/CS);
  grid={ foodG:new Float32Array(GW*GH), homeG:new Float32Array(GW*GH), foodR:new Float32Array(GW*GH), homeR:new Float32Array(GW*GH) };
}
const gi=(x,y)=> y*GW + x;
const clampi=(v,a,b)=> v<a?a:(v>b?b:v);
function deposit(field,x,y,amt){ const cx=clampi((x/CS)|0,0,GW-1), cy=clampi((y/CS)|0,0,GH-1); grid[field][gi(cx,cy)] += amt; }
function senseGrad(field,x,y){ const cx=clampi((x/CS)|0,0,GW-1), cy=clampi((y/CS)|0,0,GH-1); let best=-1e9,bx=cx,by=cy; for(let dy=-1;dy<=1;dy++) for(let dx=-1;dx<=1;dx++){ const nx=clampi(cx+dx,0,GW-1), ny=clampi(cy+dy,0,GH-1); const v=grid[field][gi(nx,ny)]; if(v>best){best=v; bx=nx; by=ny;} } return {gx:(bx-cx), gy:(by-cy), val:grid[field][gi(bx,by)]}; }
function evaporate(){ const keep=0.985; const names=['foodG','homeG','foodR','homeR']; const tmps={}; for(const n of names) tmps[n]=new Float32Array(GW*GH); for(const n of names){ const src=grid[n], dst=tmps[n]; for(let y=0;y<GH;y++){ for(let x=0;x<GW;x++){ let v=src[gi(x,y)]*keep; let sum=v*0.4; let cnt=0; for(let dy=-1;dy<=1;dy++) for(let dx=-1;dx<=1;dx++) if(dx||dy){ const nx=clampi(x+dx,0,GW-1), ny=clampi(y+dy,0,GH-1); sum += src[gi(nx,ny)]*0.075; cnt++; } dst[gi(x,y)]= sum/(0.4+0.075*cnt); } } } for(const n of names) grid[n]=tmps[n]; }

// Goals â€“ one per team (draggable)
const goalG={ x:W*0.86, y:H*0.35, r:34, delivered:0 },
      goalR={ x:W*0.14, y:H*0.65, r:34, delivered:0 };
let dragTarget=null, dragDX=0, dragDY=0, dragKind=null, dragIndex=-1;
canvas.addEventListener('mousedown', (e)=>{
  const r=canvas.getBoundingClientRect();
  const x=e.clientX - r.left, y=e.clientY - r.top;
  dragTarget=null; dragKind=null; dragIndex=-1;
  // Prioritize obstacles (topmost first)
  for(let i=obstacles.length-1; i>=0; i--){
    const o=obstacles[i];
    if(Math.hypot(x-o.x, y-o.y) <= o.r + 8){
      dragTarget=o; dragKind='obst'; dragIndex=i; dragDX=o.x - x; dragDY=o.y - y; return;
    }
  }
  // Goal rings
  if(Math.hypot(x-goalG.x,y-goalG.y) <= goalG.r+12){ dragTarget=goalG; dragKind='goalG'; dragDX=goalG.x-x; dragDY=goalG.y-y; return; }
  if(Math.hypot(x-goalR.x,y-goalR.y) <= goalR.r+12){ dragTarget=goalR; dragKind='goalR'; dragDX=goalR.x-x; dragDY=goalR.y-y; return; }
});
window.addEventListener('mousemove', (e)=>{
  if(!dragTarget) return;
  const r=canvas.getBoundingClientRect();
  const x=e.clientX - r.left, y=e.clientY - r.top;
  if(dragKind==='obst'){
    dragTarget.x = Math.max(dragTarget.r+4, Math.min(W - dragTarget.r - 4, x + dragDX));
    dragTarget.y = Math.max(dragTarget.r+4, Math.min(H - dragTarget.r - 4, y + dragDY));
  } else {
    dragTarget.x = Math.max(dragTarget.r+8, Math.min(W - dragTarget.r - 8, x + dragDX));
    dragTarget.y = Math.max(dragTarget.r+8, Math.min(H - dragTarget.r - 8, y + dragDY));
  }
});
window.addEventListener('mouseup', ()=>{ dragTarget=null; dragKind=null; dragIndex=-1; });

// Utils
function rand(a,b){ return a + Math.random()*(b-a); }
function nearest(arr,x,y){ if(!arr.length) return null; let best=arr[0],bd=1e9; for(const o of arr){ const d=Math.hypot(o.x-x,o.y-y); if(d<bd){bd=d; best=o;} } return best; }
function pointInsideObstacle(x,y){ for(const o of obstacles){ if(Math.hypot(x-o.x,y-o.y) < o.r + 7) return true; } return false; }
function findFreeFruitSpot(maxTry=80){ for(let i=0;i<maxTry;i++){ const x=rand(40,W-40), y=rand(40,H-40); if(!pointInsideObstacle(x,y)) return {x,y}; } return null; }
function spawnFruit(x=null,y=null){ if(fruits.length>=params.maxFruits) return; if(x==null||y==null){ const pos=findFreeFruitSpot(); if(!pos) return; x=pos.x; y=pos.y; } if(pointInsideObstacle(x,y)){ const pos=findFreeFruitSpot(); if(!pos) return; x=pos.x; y=pos.y; } fruits.push({x,y,r:6,color:COLORS.fruit}); }
function makeObstacles(n){ obstacles.length=0; for(let i=0;i<n;i++){ const r=rand(16,40); let tries=0,x,y; do{ x=rand(80,W-80); y=rand(60,H-60); tries++; } while(tries<80 && (Math.hypot(x-goalG.x,y-goalG.y)<goalG.r+50 || Math.hypot(x-goalR.x,y-goalR.y)<goalR.r+50)); obstacles.push({x,y,r}); } }

// ===== NEATâ€‘lite (7â†’16â†’2) =====
function randn(){ let u=0,v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random(); return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v); }
function matmulVec(W, x, out){ const rows=W.length, cols=W[0].length; for(let i=0;i<rows;i++){ let s=0; const Wi=W[i]; for(let j=0;j<cols;j++) s+=Wi[j]*x[j]; out[i]=s; } return out; }
function tanhVec(v){ for(let i=0;i<v.length;i++) v[i]=Math.tanh(v[i]); return v; }
function addBias(v,b){ for(let i=0;i<v.length;i++) v[i]+=b[i]; return v; }
function makeNet(inDim=7,h=16,out=2){ return { W1:Array.from({length:h},()=>Array.from({length:inDim},()=> (Math.random()*2-1)*0.5)), b1:Array.from({length:h},()=> (Math.random()*2-1)*0.2), W2:Array.from({length:out},()=>Array.from({length:h},()=> (Math.random()*2-1)*0.5)), b2:Array.from({length:out},()=> (Math.random()*2-1)*0.2) }; }
function cloneNet(n){ return { W1:n.W1.map(r=>r.slice()), b1:n.b1.slice(), W2:n.W2.map(r=>r.slice()), b2:n.b2.slice() }; }
function mutateNet(n, rate){ const sW=0.2, sB=0.2; for(const r of n.W1) for(let i=0;i<r.length;i++) if(Math.random()<rate) r[i]+=randn()*sW; for(let i=0;i<n.b1.length;i++) if(Math.random()<rate) n.b1[i]+=randn()*sB; for(const r of n.W2) for(let i=0;i<r.length;i++) if(Math.random()<rate) r[i]+=randn()*sW; for(let i=0;i<n.b2.length;i++) if(Math.random()<rate) n.b2[i]+=randn()*sB; }
function crossover(a,b){ const c=cloneNet(a); for(let i=0;i<c.W1.length;i++) for(let j=0;j<c.W1[0].length;j++) c.W1[i][j]=(Math.random()<0.5?a.W1[i][j]:b.W1[i][j]); for(let i=0;i<c.b1.length;i++) c.b1[i]=(Math.random()<0.5?a.b1[i]:b.b1[i]); for(let i=0;i<c.W2.length;i++) for(let j=0;j<c.W2[0].length;j++) c.W2[i][j]=(Math.random()<0.5?a.W2[i][j]:b.W2[i][j]); for(let i=0;i<c.b2.length;i++) c.b2[i]=(Math.random()<0.5?a.b2[i]:b.b2[i]); return c; }
function forward(n, x){ const h=new Array(n.b1.length).fill(0), o=new Array(n.b2.length).fill(0); matmulVec(n.W1,x,h); addBias(h,n.b1); tanhVec(h); matmulVec(n.W2,h,o); addBias(o,n.b2); tanhVec(o); return o; }
function makePopulation(size){ return Array.from({length:size}, ()=> ({ net:makeNet(), fitness:0 })); }
const evo = { gen:1, G: makePopulation(28), R: makePopulation(28) };
function resizePop(){ if(evo.G.length!==params.green.count){ if(evo.G.length<params.green.count){ while(evo.G.length<params.green.count) evo.G.push({ net:makeNet(), fitness:0 }); } else { evo.G.length=params.green.count; } } if(evo.R.length!==params.red.count){ if(evo.R.length<params.red.count){ while(evo.R.length<params.red.count) evo.R.push({ net:makeNet(), fitness:0 }); } else { evo.R.length=params.red.count; } } }
function nextGeneration(team){ const pop=evo[team]; pop.sort((a,b)=> b.fitness - a.fitness); const eliteN=Math.max(1, Math.floor(pop.length*params.learn.elite)); const elites=pop.slice(0,eliteN).map(e=> cloneNet(e.net)); const best=pop[0]?.fitness||0; if(team==='G') Q('lbBestG').textContent=best.toFixed(0); else Q('lbBestR').textContent=best.toFixed(0); const newPop=[]; for(let i=0;i<eliteN;i++) newPop.push({ net:cloneNet(elites[i]), fitness:0 }); function pick(){ const k=Math.min(pop.length, Math.max(2,eliteN*2)); const a=pop[Math.floor(Math.random()*k)], b=pop[Math.floor(Math.random()*k)]; return (a.fitness>b.fitness?a:b).net; } while(newPop.length<pop.length){ const pa=pick(), pb=pick(); let child=crossover(pa,pb); mutateNet(child, params.learn.mut); newPop.push({ net:child, fitness:0 }); } for(let i=0;i<pop.length;i++){ pop[i].net=newPop[i].net; pop[i].fitness=0; } }

// ===== Agentbas =====
class Agent{
  constructor(x,y,color,maxSpeed,team){ this.x=x; this.y=y; this.vx=rand(-1,1); this.vy=rand(-1,1); this.color=color; this.maxSpeed=maxSpeed; this.trail=[]; this.carry=false; this.team=team; this.side=Math.random()<0.5?-1:1; this.stuckT=0; this.wander={x:rand(-1,1), y:rand(-1,1)}; }
  stepSpeed(v){ this.maxSpeed=v; }
  steerSeparation(peers, radius=18, gain=0.12){ let sx=0,sy=0; for(const p of peers){ if(p===this) continue; const dx=this.x-p.x, dy=this.y-p.y; const d=Math.hypot(dx,dy); if(d>0 && d<radius){ sx+=dx/(d*d); sy+=dy/(d*d); } } this.vx+=sx*gain; this.vy+=sy*gain; }
  applyWander(str=0.055, damp=0.92){ this.wander.x=this.wander.x*damp+(Math.random()*2-1)*(1-damp); this.wander.y=this.wander.y*damp+(Math.random()*2-1)*(1-damp); const wn=Math.hypot(this.wander.x,this.wander.y)||1; this.vx+=(this.wander.x/wn)*str; this.vy+=(this.wander.y/wn)*str; }
  avoidObstacles(){ for(const o of obstacles){ const dx=this.x-o.x, dy=this.y-o.y; const d=Math.hypot(dx,dy); const minD=o.r+8; if(d<minD+12){ const push=(minD+12-d)*0.055; const nx=dx/(d||1), ny=dy/(d||1); this.vx+=nx*push; this.vy+=ny*push; } } }
  keepInBounds(){ if(this.x<10){this.x=10; this.vx=Math.abs(this.vx);} if(this.x>W-10){this.x=W-10; this.vx=-Math.abs(this.vx);} if(this.y<10){this.y=10; this.vy=Math.abs(this.vy);} if(this.y>H-10){this.y=H-10; this.vy=-Math.abs(this.vy);} }
  integrate(){ const sp=Math.hypot(this.vx,this.vy); if(sp>this.maxSpeed){ this.vx*=this.maxSpeed/sp; this.vy*=this.maxSpeed/sp; } this.trail.push({x:this.x,y:this.y}); if(this.trail.length>params.tailLen) this.trail.shift(); this.x+=this.vx; this.y+=this.vy; this.stuckT=(sp<0.10)?(this.stuckT+1):0; }
}

class Collector extends Agent{
  constructor(x,y,team,netRef){ const cfg=(team==='G')? params.green: params.red; const color=(team==='G')? COLORS.green: COLORS.red; super(x,y,color,cfg.speed,team); this.netRef=netRef; this.fitness=0; }
  update(){ const cfg=(this.team==='G')? params.green: params.red; const myFood=(this.team==='G')? 'foodG':'foodR'; const myHome=(this.team==='G')? 'homeG':'homeR'; const myGoal=(this.team==='G')? goalG:goalR; this.stepSpeed(cfg.speed);
    const tgt = this.carry? myGoal : nearest(fruits, this.x, this.y);
    let tx=0,ty=0, dn=1; if(tgt){ tx=tgt.x-this.x; ty=tgt.y-this.y; dn=Math.hypot(tx,ty)||1; tx/=dn; ty/=dn; }
    const g = senseGrad(this.carry? myHome: myFood, this.x, this.y);
    const mates = (this.team==='G')? greens: reds; let sx=0, sy=0; for(const p of mates){ if(p===this) continue; const dx=this.x-p.x, dy=this.y-p.y; const d=Math.hypot(dx,dy); if(d>0 && d<22){ sx+=dx/(d*d); sy+=dy/(d*d); } }
    const input = [tx,ty, g.gx, g.gy, sx, sy, 1.0];
    const out = forward(this.netRef.net, input);
    this.vx += out[0]*(0.45 + 0.15*cfg.smart) + (tx*0.15*cfg.strat);
    this.vy += out[1]*(0.45 + 0.15*cfg.smart) + (ty*0.15*cfg.strat);
    if(!this.carry && tgt && Math.hypot(tgt.x-this.x,tgt.y-this.y)<9){ const i=fruits.indexOf(tgt); if(i>-1) fruits.splice(i,1); this.carry=true; this.fitness += 8; }
    if(this.carry && Math.hypot(myGoal.x-this.x,myGoal.y-this.y)<myGoal.r){ this.carry=false; myGoal.delivered++; this.fitness += 120; }
    if(this.carry){ const dGoal=Math.hypot(myGoal.x-this.x,myGoal.y-this.y); this.fitness += (1/(1+dGoal))*0.2; }
    deposit(this.carry? myFood: myHome, this.x, this.y, 0.30);
    if(this.stuckT>35){ this.vx += tx*(0.9+0.2*cfg.strat); this.vy += ty*(0.9+0.2*cfg.strat); this.stuckT=0; }
    this.avoidObstacles(); this.keepInBounds(); this.integrate();
  }
}

// ===== Setup & loop =====
let lastSpawn=performance.now();
function setup(){ greens.length=0; reds.length=0; fruits.length=0; goalG.delivered=0; goalR.delivered=0; makeGrid(); if(obstacles.length===0){ makeObstacles(params.obstacles); } resizePop(); for(let i=0;i<params.maxFruits;i++) spawnFruit(); for(let i=0;i<params.green.count;i++) greens.push(new Collector(rand(40,W*0.45), rand(40,H-40), 'G', evo.G[i])); for(let i=0;i<params.red.count;i++) reds.push(new Collector(rand(W*0.55,W-40), rand(40,H-40), 'R', evo.R[i])); lastSpawn=performance.now(); Q('lbGen').textContent=evo.gen; }

function drawTrail(trail,color){ if(trail.length<2) return; ctx.lineWidth=2; const grad=ctx.createLinearGradient(trail[0].x,trail[0].y,trail[trail.length-1].x,trail[trail.length-1].y); grad.addColorStop(0,'rgba(255,255,255,0)'); grad.addColorStop(1,color); ctx.strokeStyle=grad; ctx.beginPath(); ctx.moveTo(trail[0].x,trail[0].y); for(let i=1;i<trail.length;i++) ctx.lineTo(trail[i].x,trail[i].y); ctx.stroke(); }
function drawGoal(g, tint){
  ctx.beginPath();
  ctx.arc(g.x,g.y,g.r,0,Math.PI*2);
  ctx.fillStyle=COLORS.goalFill;
  ctx.fill();
  ctx.save();
  ctx.strokeStyle=tint;
  ctx.lineWidth = 4; // static
  ctx.shadowColor='transparent';
  ctx.shadowBlur=0;
  ctx.stroke();
  ctx.restore();
  ctx.fillStyle='#fff';
  ctx.font='bold 18px ui-sans-serif';
  ctx.textAlign='center';
  ctx.textBaseline='middle';
  ctx.fillText(String(g.delivered), g.x, g.y);
}
function draw(){
  ctx.clearRect(0,0,W,H);

  // Goals (static, no blinking)
  drawGoal(goalG, COLORS.green);
  drawGoal(goalR, COLORS.red);

  // Obstacles (static stroke)
  for(const o of obstacles){
    ctx.beginPath();
    ctx.arc(o.x,o.y,o.r,0,Math.PI*2);
    ctx.fillStyle=COLORS.obstF;
    ctx.fill();
    ctx.strokeStyle=COLORS.obstS;
    ctx.lineWidth=2;
    ctx.stroke();
  }

  // Fruits
  for(const f of fruits){
    ctx.beginPath();
    ctx.arc(f.x,f.y,f.r,0,Math.PI*2);
    ctx.fillStyle=COLORS.fruit;
    ctx.fill();
    ctx.lineWidth=1.5;
    ctx.strokeStyle=COLORS.fruitOutline;
    ctx.stroke();
  }

  // Agents (no shadow flash)
  for(const a of greens){
    ctx.beginPath();
    ctx.arc(a.x,a.y,5,0,Math.PI*2);
    ctx.fillStyle=COLORS.green;
    ctx.fill();
    ctx.lineWidth=2;
    ctx.strokeStyle=COLORS.greenOutline;
    ctx.stroke();
    if(a.carry){ ctx.lineWidth=2; ctx.strokeStyle='#ffff33'; ctx.stroke(); }
    drawTrail(a.trail, COLORS.green);
  }
  for(const a of reds){
    ctx.beginPath();
    ctx.arc(a.x,a.y,5.5,0,Math.PI*2);
    ctx.fillStyle=COLORS.red;
    ctx.fill();
    ctx.lineWidth=2;
    ctx.strokeStyle=COLORS.redOutline;
    ctx.stroke();
    if(a.carry){ ctx.lineWidth=2; ctx.strokeStyle='#ffff33'; ctx.stroke(); }
    drawTrail(a.trail, COLORS.red);
  }
}

let simSteps=0, forceNextGen=false;
function loop(){
  requestAnimationFrame(loop);
  const now = performance.now();
  for(const a of greens) a.update();
  for(const a of reds) a.update();
  evaporate();
  if(now - lastSpawn >= params.spawnMs){
    spawnFruit();
    lastSpawn = now;
  }
  draw();
  simSteps++;
  const end = simSteps>=params.learn.genSteps || forceNextGen;
  if(end){
    for(let i=0;i<greens.length;i++) evo.G[i].fitness += greens[i].fitness;
    for(let i=0;i<reds.length;i++) evo.R[i].fitness += reds[i].fitness;
    nextGeneration('G');
    nextGeneration('R');
    evo.gen++;
    Q('lbGen').textContent=evo.gen;
    simSteps=0;
    forceNextGen=false;
    setup();
  }
}

function updateBestLabels(bestG, bestR){
  if(Number.isFinite(bestG)){
    Q('lbBestG').textContent = Number(bestG).toFixed(0);
  }
  if(Number.isFinite(bestR)){
    Q('lbBestR').textContent = Number(bestR).toFixed(0);
  }
}

function captureTrainingSnapshot(){
  const paramsClone = JSON.parse(JSON.stringify(params));
  const bestGreenValue = Number(Q('lbBestG').textContent);
  const bestRedValue = Number(Q('lbBestR').textContent);
  const bestGreen = Number.isFinite(bestGreenValue) ? bestGreenValue : 0;
  const bestRed = Number.isFinite(bestRedValue) ? bestRedValue : 0;
  return {
    version:1,
    savedAt:new Date().toISOString(),
    params:paramsClone,
    evo:{
      gen:evo.gen,
      greens:evo.G.map((member)=> ({ net:cloneNet(member.net), fitness:member.fitness||0 })),
      reds:evo.R.map((member)=> ({ net:cloneNet(member.net), fitness:member.fitness||0 }))
    },
    best:{ green:bestGreen, red:bestRed }
  };
}

function downloadTrainingData(){
  try{
    const snapshot = captureTrainingSnapshot();
    const json = JSON.stringify(snapshot, null, 2);
    const blob = new Blob([json], { type:'application/json' });
    const url = URL.createObjectURL(blob);
    const genStr = String(snapshot.evo?.gen ?? 1).padStart(3, '0');
    const link = document.createElement('a');
    link.href = url;
    link.download = `foodsim-training-gen${genStr}.json`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    setTimeout(()=> URL.revokeObjectURL(url), 1000);
  }catch(err){
    console.error('Failed to export training data', err);
    alert('Could not save training data. Please try again.');
  }
}

function applyParamsSnapshot(snapshot){
  if(!snapshot) return;
  if(snapshot.maxFruits != null) setRangeValue('slFruits', snapshot.maxFruits);
  if(snapshot.spawnMs != null) setRangeValue('slSpawn', snapshot.spawnMs);
  if(snapshot.obstacles != null) setRangeValue('slObst', snapshot.obstacles);
  if(snapshot.tailLen != null) setRangeValue('slTail', snapshot.tailLen);

  if(snapshot.green){
    if(snapshot.green.count != null) setRangeValue('slGCount', snapshot.green.count);
    if(snapshot.green.speed != null) setRangeValue('slGSpeed', Math.round(snapshot.green.speed*100));
    if(snapshot.green.smart != null) setRangeValue('slGSmart', Math.round(snapshot.green.smart*100));
    if(snapshot.green.strat != null) setRangeValue('slGStrat', Math.round(snapshot.green.strat*100));
    if(snapshot.green.sep != null) setRangeValue('slGSep', Math.round(snapshot.green.sep*100));
  }

  if(snapshot.red){
    if(snapshot.red.count != null) setRangeValue('slRCount', snapshot.red.count);
    if(snapshot.red.speed != null) setRangeValue('slRSpeed', Math.round(snapshot.red.speed*100));
    if(snapshot.red.smart != null) setRangeValue('slRSmart', Math.round(snapshot.red.smart*100));
    if(snapshot.red.strat != null) setRangeValue('slRStrat', Math.round(snapshot.red.strat*100));
    if(snapshot.red.sep != null) setRangeValue('slRSep', Math.round(snapshot.red.sep*100));
  }

  if(snapshot.learn){
    if(snapshot.learn.genSteps != null) setRangeValue('slGenSteps', snapshot.learn.genSteps);
    if(snapshot.learn.mut != null) setRangeValue('slMut', Math.round(snapshot.learn.mut*100));
    if(snapshot.learn.elite != null) setRangeValue('slElite', Math.round(snapshot.learn.elite*100));
    if(snapshot.learn.auto !== undefined){
      const auto = Q('chkAuto');
      if(auto){
        auto.checked = !!snapshot.learn.auto;
        auto.dispatchEvent(new Event('change', { bubbles:true }));
      }
    }
  }
}

function loadTrainingSnapshot(data){
  if(!data || typeof data !== 'object') throw new Error('Invalid training file.');
  const evoData = data.evo || data;
  if(!evoData) throw new Error('Training file is missing the evo section.');
  const greensData = Array.isArray(evoData.greens) ? evoData.greens : (Array.isArray(evoData.G) ? evoData.G : null);
  const redsData = Array.isArray(evoData.reds) ? evoData.reds : (Array.isArray(evoData.R) ? evoData.R : null);
  if(!greensData || !redsData) throw new Error('Training file does not contain both team genomes.');

  let computedBestG = 0;
  for(const item of greensData){
    const val = Number(item?.fitness);
    if(Number.isFinite(val) && val > computedBestG) computedBestG = val;
  }
  let computedBestR = 0;
  for(const item of redsData){
    const val = Number(item?.fitness);
    if(Number.isFinite(val) && val > computedBestR) computedBestR = val;
  }
  const bestGreenStored = Number(data.best?.green);
  const bestRedStored = Number(data.best?.red);
  const bestGreen = Number.isFinite(bestGreenStored) ? bestGreenStored : computedBestG;
  const bestRed = Number.isFinite(bestRedStored) ? bestRedStored : computedBestR;

  if(data.params) applyParamsSnapshot(data.params);

  const toIndividual = (entry)=>{
    const netData = entry && (entry.net || entry);
    if(!netData || !netData.W1 || !netData.b1 || !netData.W2 || !netData.b2){
      throw new Error('Training file contains malformed network data.');
    }
    return { net:cloneNet(netData), fitness:0 };
  };

  evo.G = greensData.map(toIndividual);
  evo.R = redsData.map(toIndividual);
  const parsedGen = Number(evoData.gen);
  evo.gen = Number.isFinite(parsedGen) && parsedGen > 0 ? parsedGen : 1;

  setRangeValue('slGCount', evo.G.length);
  setRangeValue('slRCount', evo.R.length);

  simSteps = 0;
  forceNextGen = false;
  setup();
  updateBestLabels(bestGreen, bestRed);
}

function handleTrainingFileSelection(evt){
  const input = evt.target;
  const file = input?.files?.[0];
  if(input) input.value = '';
  if(!file) return;
  const reader = new FileReader();
  reader.onload = ()=>{
    try{
      const parsed = JSON.parse(reader.result);
      loadTrainingSnapshot(parsed);
    }catch(err){
      console.error('Failed to load training file', err);
      alert('Could not load training data. Please ensure it was exported from this simulator.');
    }
  };
  reader.onerror = ()=>{
    console.error('Unable to read the selected file', reader.error);
    alert('Could not read the selected file.');
  };
  reader.readAsText(file);
}

const btnSaveTraining = Q('btnSaveTraining');
if(btnSaveTraining){
  btnSaveTraining.addEventListener('click', downloadTrainingData);
}
const btnLoadTraining = Q('btnLoadTraining');
const inputLoadTraining = Q('inputLoadTraining');
if(btnLoadTraining && inputLoadTraining){
  btnLoadTraining.addEventListener('click', ()=> inputLoadTraining.click());
  inputLoadTraining.addEventListener('change', handleTrainingFileSelection);
}

// Bind ranges after DOM ready
['Fruits','Spawn','Obst','Tail','GCount','GSpeed','GSmart','GStrat','GSep','RCount','RSpeed','RSmart','RStrat','RSep','GenSteps','Mut','Elite'].forEach(k=>{
  bindRange('sl'+k, 'lb'+k, (v)=> (k.includes('Speed')||k.includes('Smart')||k.includes('Strat')||k.includes('Sep')) ? (v/100).toFixed(2) : v);
});
Q('btnReset').onclick = ()=> setup();
Q('btnNextGen').onclick = ()=> { forceNextGen = true; };
Q('chkAuto').addEventListener('change', ()=> readParams());

window.addEventListener('beforeunload', clearCurrentObjectUrl);

// Start
initMusicPanel();
readParams();
setup();
loop();
</script>
</body>
</html>
